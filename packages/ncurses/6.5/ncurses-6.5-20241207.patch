# ncurses 6.5 - patch 20241207 - Thomas E. Dickey
#
# ------------------------------------------------------------------------------
#
# Ncurses 6.5 is at
#   https://invisible-island.net/archives/ncurses/
#   https://invisible-mirror.net/archives/ncurses/
#   https://ftp.gnu.org/gnu/ncurses/
#
# Patches for ncurses 6.5 can be found at
#   https://invisible-island.net/archives/ncurses/6.5
#   https://invisible-mirror.net/archives/ncurses/6.5
#
# ------------------------------------------------------------------------------
# https://invisible-island.net/archives/ncurses/6.5/ncurses-6.5-20241207.patch.gz
# patch by Thomas E. Dickey <dickey@invisible-island.net>
# created  Sun Dec  8 02:11:12 UTC 2024
# ------------------------------------------------------------------------------
# NEWS                               |    5 
# VERSION                            |    2 
# dist.mk                            |    4 
# form/fld_arg.c                     |    6 -
# form/fld_attr.c                    |    6 -
# form/fld_current.c                 |   12 +-
# form/fld_def.c                     |   26 ++--
# form/form.priv.h                   |    8 -
# form/frm_driver.c                  |   28 ++--
# form/frm_req_name.c                |    6 -
# form/fty_enum.c                    |    6 -
# form/fty_generic.c                 |   13 +-
# form/fty_int.c                     |    4 
# form/fty_num.c                     |    4 
# form/fty_regex.c                   |    8 -
# include/curses.h.in                |    8 -
# menu/m_driver.c                    |    8 -
# menu/m_global.c                    |   14 +-
# menu/m_item_new.c                  |   10 -
# menu/m_pattern.c                   |    6 -
# menu/m_req_name.c                  |    6 -
# menu/mf_common.h                   |    4 
# ncurses/base/MKkeyname.awk         |   30 ++---
# ncurses/base/MKlib_gen.sh          |    5 
# ncurses/base/MKunctrl.awk          |   10 -
# ncurses/base/define_key.c          |   10 -
# ncurses/base/key_defined.c         |   10 -
# ncurses/base/keybound.c            |    8 -
# ncurses/base/keyok.c               |    8 -
# ncurses/base/legacy_coding.c       |    6 -
# ncurses/base/lib_addch.c           |    6 -
# ncurses/base/lib_addstr.c          |   10 -
# ncurses/base/lib_beep.c            |    6 -
# ncurses/base/lib_bkgd.c            |    6 -
# ncurses/base/lib_color.c           |   38 +++---
# ncurses/base/lib_colorset.c        |    6 -
# ncurses/base/lib_delwin.c          |    6 -
# ncurses/base/lib_dft_fgbg.c        |    8 -
# ncurses/base/lib_echo.c            |    8 -
# ncurses/base/lib_erase.c           |    6 -
# ncurses/base/lib_freeall.c         |   14 +-
# ncurses/base/lib_getch.c           |    6 -
# ncurses/base/lib_initscr.c         |    6 -
# ncurses/base/lib_insch.c           |    6 -
# ncurses/base/lib_insnstr.c         |    8 -
# ncurses/base/lib_instr.c           |   12 +-
# ncurses/base/lib_mouse.c           |   28 ++--
# ncurses/base/lib_newterm.c         |   18 +--
# ncurses/base/lib_newwin.c          |   67 ++++++-----
# ncurses/base/lib_nl.c              |    8 -
# ncurses/base/lib_overlay.c         |   10 -
# ncurses/base/lib_pad.c             |   16 +-
# ncurses/base/lib_printw.c          |    6 -
# ncurses/base/lib_redrawln.c        |    6 -
# ncurses/base/lib_restart.c         |    6 -
# ncurses/base/lib_screen.c          |   56 ++++-----
# ncurses/base/lib_set_term.c        |   74 ++++++-------
# ncurses/base/lib_slk.c             |   20 +--
# ncurses/base/lib_slkatr_set.c      |    8 -
# ncurses/base/lib_slkatrof.c        |    6 -
# ncurses/base/lib_slkatron.c        |    6 -
# ncurses/base/lib_slkatrset.c       |    6 -
# ncurses/base/lib_slkattr.c         |    6 -
# ncurses/base/lib_slkclear.c        |    6 -
# ncurses/base/lib_slkcolor.c        |    8 -
# ncurses/base/lib_slklab.c          |    8 -
# ncurses/base/lib_slkrefr.c         |    8 -
# ncurses/base/lib_slkset.c          |   16 +-
# ncurses/base/lib_slktouch.c        |    6 -
# ncurses/base/lib_ungetch.c         |    6 -
# ncurses/base/lib_wattron.c         |    6 -
# ncurses/base/lib_winch.c           |    6 -
# ncurses/base/lib_window.c          |   14 +-
# ncurses/base/nc_panel.c            |    6 -
# ncurses/base/new_pair.c            |   12 +-
# ncurses/base/resizeterm.c          |   24 ++--
# ncurses/base/tries.c               |   20 +--
# ncurses/base/wresize.c             |   16 +-
# ncurses/curses.priv.h              |   50 ++++----
# ncurses/new_pair.h                 |    4 
# ncurses/report_offsets.c           |    8 -
# ncurses/tinfo/MKcaptab.awk         |    6 -
# ncurses/tinfo/MKcaptab.sh          |   22 +--
# ncurses/tinfo/MKcodes.awk          |    6 -
# ncurses/tinfo/MKfallback.sh        |    6 -
# ncurses/tinfo/MKnames.awk          |    6 -
# ncurses/tinfo/MKuserdefs.sh        |    8 -
# ncurses/tinfo/access.c             |   12 +-
# ncurses/tinfo/add_tries.c          |   18 +--
# ncurses/tinfo/alloc_entry.c        |   12 +-
# ncurses/tinfo/alloc_ttype.c        |   12 +-
# ncurses/tinfo/captoinfo.c          |   24 ++--
# ncurses/tinfo/comp_error.c         |   16 +-
# ncurses/tinfo/comp_expand.c        |   18 +--
# ncurses/tinfo/comp_hash.c          |   14 +-
# ncurses/tinfo/comp_parse.c         |   20 +--
# ncurses/tinfo/comp_scan.c          |   62 +++++-----
# ncurses/tinfo/db_iterator.c        |   54 ++++-----
# ncurses/tinfo/doalloc.c            |    6 -
# ncurses/tinfo/entries.c            |   24 ++--
# ncurses/tinfo/getenv_num.c         |    8 -
# ncurses/tinfo/home_terminfo.c      |    8 -
# ncurses/tinfo/init_keytry.c        |    6 -
# ncurses/tinfo/lib_acs.c            |   12 +-
# ncurses/tinfo/lib_baudrate.c       |    6 -
# ncurses/tinfo/lib_cur_term.c       |   14 +-
# ncurses/tinfo/lib_data.c           |   26 ++--
# ncurses/tinfo/lib_kernel.c         |   10 -
# ncurses/tinfo/lib_options.c        |   16 +-
# ncurses/tinfo/lib_print.c          |    6 -
# ncurses/tinfo/lib_raw.c            |   18 +--
# ncurses/tinfo/lib_setup.c          |   49 ++++----
# ncurses/tinfo/lib_termcap.c        |   44 +++----
# ncurses/tinfo/lib_termname.c       |    8 -
# ncurses/tinfo/lib_ti.c             |   10 -
# ncurses/tinfo/lib_tparm.c          |   32 ++---
# ncurses/tinfo/lib_tputs.c          |   22 +--
# ncurses/tinfo/lib_ttyflags.c       |   28 ++--
# ncurses/tinfo/make_hash.c          |   38 +++---
# ncurses/tinfo/make_keys.c          |   22 +--
# ncurses/tinfo/name_match.c         |   14 +-
# ncurses/tinfo/obsolete.c           |    8 -
# ncurses/tinfo/parse_entry.c        |   24 ++--
# ncurses/tinfo/read_entry.c         |   22 +--
# ncurses/tinfo/strings.c            |   14 +-
# ncurses/tinfo/trim_sgr0.c          |   12 +-
# ncurses/tinfo/write_entry.c        |   12 +-
# ncurses/trace/lib_trace.c          |   16 +-
# ncurses/trace/lib_traceatr.c       |   24 ++--
# ncurses/trace/lib_tracebits.c      |    6 -
# ncurses/trace/lib_tracechr.c       |    8 -
# ncurses/trace/lib_tracedmp.c       |    8 -
# ncurses/trace/lib_tracemse.c       |   10 -
# ncurses/trace/trace_buf.c          |   26 ++--
# ncurses/trace/trace_tries.c        |   10 -
# ncurses/trace/varargs.c            |   10 -
# ncurses/trace/visbuf.c             |   20 +--
# ncurses/tty/MKexpanded.sh          |   11 +
# ncurses/tty/hardscroll.c           |   12 +-
# ncurses/tty/hashmap.c              |    6 -
# ncurses/tty/lib_mvcur.c            |   24 ++--
# ncurses/tty/lib_tstp.c             |    8 -
# ncurses/tty/lib_twait.c            |    4 
# ncurses/tty/lib_vidattr.c          |   10 -
# ncurses/tty/tty_update.c           |   28 ++--
# ncurses/wcwidth.h                  |    4 
# ncurses/widechar/lib_add_wch.c     |    4 
# ncurses/widechar/lib_box_set.c     |    6 -
# ncurses/widechar/lib_cchar.c       |    4 
# ncurses/widechar/lib_get_wch.c     |    8 -
# ncurses/widechar/lib_hline_set.c   |    6 -
# ncurses/widechar/lib_in_wch.c      |    8 -
# ncurses/widechar/lib_in_wchnstr.c  |    6 -
# ncurses/widechar/lib_ins_wch.c     |    8 -
# ncurses/widechar/lib_inwstr.c      |    6 -
# ncurses/widechar/lib_pecho_wchar.c |    6 -
# ncurses/widechar/lib_slk_wset.c    |    8 -
# ncurses/widechar/lib_unget_wch.c   |   10 -
# ncurses/widechar/lib_vid_attr.c    |   26 ++--
# ncurses/widechar/lib_vline_set.c   |    6 -
# ncurses/widechar/lib_wacs.c        |    8 -
# ncurses/widechar/lib_wunctrl.c     |    8 -
# package/debian-mingw/changelog     |    4 
# package/debian-mingw64/changelog   |    4 
# package/debian/changelog           |    4 
# package/mingw-ncurses.nsi          |    4 
# package/mingw-ncurses.spec         |    2 
# package/ncurses.spec               |    2 
# package/ncursest.spec              |    2 
# panel/p_above.c                    |   16 +-
# panel/p_below.c                    |   18 +--
# panel/p_new.c                      |    6 -
# panel/panel.c                      |   18 +--
# panel/panel.priv.h                 |    6 -
# progs/dump_entry.c                 |   40 +++----
# progs/infocmp.c                    |   56 ++++-----
# progs/reset_cmd.c                  |   18 +--
# progs/tabs.c                       |   38 +++---
# progs/tic.c                        |  118 ++++++++++----------
# progs/toe.c                        |   50 ++++----
# progs/tput.c                       |   14 +-
# progs/tset.c                       |   54 ++++-----
# test/blue.c                        |    4 
# test/bs.c                          |   12 +-
# test/cardfile.c                    |   52 ++++-----
# test/chgat.c                       |   24 ++--
# test/clip_printw.c                 |   24 ++--
# test/color_content.c               |    4 
# test/color_name.h                  |    8 -
# test/combine.c                     |    4 
# test/demo_altkeys.c                |   12 +-
# test/demo_defkey.c                 |   30 ++---
# test/demo_forms.c                  |   36 +++---
# test/demo_keyok.c                  |    4 
# test/demo_menus.c                  |   58 +++++-----
# test/demo_new_pair.c               |    8 -
# test/demo_panels.c                 |   48 ++++----
# test/demo_termcap.c                |   64 +++++------
# test/demo_terminfo.c               |   66 +++++------
# test/ditto.c                       |   20 +--
# test/dots.c                        |    8 -
# test/dots_curses.c                 |    4 
# test/dots_mvcur.c                  |   10 -
# test/dots_termcap.c                |   16 +-
# test/dots_xcurses.c                |    4 
# test/dump_window.c                 |   18 +--
# test/dup_field.c                   |   12 +-
# test/echochar.c                    |   10 -
# test/edit_field.c                  |   14 +-
# test/filter.c                      |   12 +-
# test/foldkeys.c                    |   16 +-
# test/form_driver_w.c               |    4 
# test/gdc.c                         |    6 -
# test/inch_wide.c                   |   14 +-
# test/inchs.c                       |   16 +-
# test/ins_wide.c                    |    8 -
# test/insdelln.c                    |   22 +--
# test/inserts.c                     |    8 -
# test/key_names.c                   |    6 -
# test/keynames.c                    |    6 -
# test/linedata.h                    |   10 -
# test/list_keys.c                   |   12 +-
# test/move_field.c                  |   12 +-
# test/movewindow.c                  |   42 +++----
# test/ncurses.c                     |  199 +++++++++++++++++------------------
# test/padview.c                     |   18 +--
# test/pair_content.c                |    4 
# test/picsmap.c                     |  132 +++++++++++------------
# test/popup_msg.c                   |    8 -
# test/railroad.c                    |   30 ++---
# test/rain.c                        |    4 
# test/redraw.c                      |    4 
# test/savescreen.c                  |   22 +--
# test/sp_tinfo.c                    |   10 -
# test/tclock.c                      |    4 
# test/test_add_wchstr.c             |   18 +--
# test/test_addchstr.c               |   18 +--
# test/test_addstr.c                 |    8 -
# test/test_addwstr.c                |    8 -
# test/test_arrays.c                 |    4 
# test/test_get_wstr.c               |   14 +-
# test/test_getstr.c                 |   14 +-
# test/test_instr.c                  |   14 +-
# test/test_inwstr.c                 |   14 +-
# test/test_opaque.c                 |   12 +-
# test/test_setupterm.c              |   10 -
# test/test_sgr.c                    |   24 ++--
# test/test_tparm.c                  |   49 ++++----
# test/test_vid_puts.c               |    6 -
# test/test_vidputs.c                |    4 
# test/testcurs.c                    |   12 +-
# test/view.c                        |   26 ++--
# test/xmas.c                        |   78 ++++++-------
# 253 files changed, 2122 insertions(+), 2100 deletions(-)
# ------------------------------------------------------------------------------
Index: NEWS
Prereq:  1.4207 
--- ncurses-6.5-20241130+/NEWS	2024-11-30 19:41:55.000000000 +0000
+++ ncurses-6.5-20241207/NEWS	2024-12-07 23:51:39.000000000 +0000
@@ -26,7 +26,7 @@
 -- sale, use or other dealings in this Software without prior written        --
 -- authorization.                                                            --
 -------------------------------------------------------------------------------
--- $Id: NEWS,v 1.4207 2024/11/30 19:41:55 tom Exp $
+-- $Id: NEWS,v 1.4209 2024/12/07 23:51:39 tom Exp $
 -------------------------------------------------------------------------------
 
 This is a log of changes that ncurses has gone through since Zeyd started
@@ -46,6 +46,9 @@
 Changes through 1.9.9e did not credit all contributions;
 it is not possible to add this information.
 
+20241207
+	+ strict compiler-warning fixes for upcoming gcc15
+
 20241130
 	+ improve configure check for lint program.
 	+ adjust options in test-programs to allow for consistent use of -c/-l
Index: VERSION
--- ncurses-6.5-20241130+/VERSION	2024-11-30 10:55:07.000000000 +0000
+++ ncurses-6.5-20241207/VERSION	2024-12-07 11:51:44.000000000 +0000
@@ -1 +1 @@
-5:0:10	6.5	20241130
+5:0:10	6.5	20241207
Index: dist.mk
Prereq:  1.1643 
--- ncurses-6.5-20241130+/dist.mk	2024-11-30 10:55:07.000000000 +0000
+++ ncurses-6.5-20241207/dist.mk	2024-12-07 11:51:44.000000000 +0000
@@ -26,7 +26,7 @@
 # use or other dealings in this Software without prior written               #
 # authorization.                                                             #
 ##############################################################################
-# $Id: dist.mk,v 1.1643 2024/11/30 10:55:07 tom Exp $
+# $Id: dist.mk,v 1.1644 2024/12/07 11:51:44 tom Exp $
 # Makefile for creating ncurses distributions.
 #
 # This only needs to be used directly as a makefile by developers, but
@@ -38,7 +38,7 @@
 # These define the major/minor/patch versions of ncurses.
 NCURSES_MAJOR = 6
 NCURSES_MINOR = 5
-NCURSES_PATCH = 20241130
+NCURSES_PATCH = 20241207
 
 # We don't append the patch to the version, since this only applies to releases
 VERSION = $(NCURSES_MAJOR).$(NCURSES_MINOR)
Index: form/fld_arg.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/form/fld_arg.c	2020-12-11 22:05:24.000000000 +0000
+++ ncurses-6.5-20241207/form/fld_arg.c	2024-12-07 23:00:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018,2020 Thomas E. Dickey                                     *
+ * Copyright 2018-2020,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -33,7 +33,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: fld_arg.c,v 1.18 2020/12/11 22:05:24 tom Exp $")
+MODULE_ID("$Id: fld_arg.c,v 1.19 2024/12/07 23:00:37 tom Exp $")
 
 /*---------------------------------------------------------------------------
 |   Facility      :  libnform
@@ -75,7 +75,7 @@
      TR_FUNC_ARG(1, copy_arg),
      TR_FUNC_ARG(2, free_arg)));
 
-  if (typ != 0 && make_arg != (void *)0)
+  if (typ != NULL && make_arg != NULL)
     {
       SetStatus(typ, _HAS_ARGS);
       typ->makearg = make_arg;
Index: form/fld_attr.c
Prereq:  1.15 
--- ncurses-6.5-20241130+/form/fld_attr.c	2020-12-11 22:05:24.000000000 +0000
+++ ncurses-6.5-20241207/form/fld_attr.c	2024-12-07 23:01:42.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2010,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -33,7 +33,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: fld_attr.c,v 1.15 2020/12/11 22:05:24 tom Exp $")
+MODULE_ID("$Id: fld_attr.c,v 1.16 2024/12/07 23:01:42 tom Exp $")
 
 /*----------------------------------------------------------------------------
   Field-Attribute manipulation routines
@@ -47,7 +47,7 @@
    if ( attr==A_NORMAL || ((attr & A_ATTRIBUTES)==attr) )\
      {\
        Normalize_Field( field );\
-       if (field != 0) \
+       if (field != NULL) \
 	 { \
 	 if ((field -> name) != attr)\
 	   {\
Index: form/fld_current.c
Prereq:  1.16 
--- ncurses-6.5-20241130+/form/fld_current.c	2020-05-24 01:40:20.000000000 +0000
+++ ncurses-6.5-20241207/form/fld_current.c	2024-12-07 23:01:42.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2010,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -33,7 +33,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: fld_current.c,v 1.16 2020/05/24 01:40:20 anonymous.maarten Exp $")
+MODULE_ID("$Id: fld_current.c,v 1.17 2024/12/07 23:01:42 tom Exp $")
 
 /*---------------------------------------------------------------------------
 |   Facility      :  libnform
@@ -54,7 +54,7 @@
   int err = E_OK;
 
   T((T_CALLED("set_current_field(%p,%p)"), (void *)form, (void *)field));
-  if (form == 0 || field == 0)
+  if (form == NULL || field == NULL)
     {
       RETURN(E_BAD_ARGUMENT);
     }
@@ -117,11 +117,11 @@
 unfocus_current_field(FORM *const form)
 {
   T((T_CALLED("unfocus_current_field(%p)"), (const void *)form));
-  if (form == 0)
+  if (form == NULL)
     {
       RETURN(E_BAD_ARGUMENT);
     }
-  else if (form->current == 0)
+  else if (form->current == NULL)
     {
       RETURN(E_REQUEST_DENIED);
     }
@@ -158,7 +158,7 @@
 field_index(const FIELD *field)
 {
   T((T_CALLED("field_index(%p)"), (const void *)field));
-  returnCode((field != 0 && field->form != 0) ? (int)field->index : -1);
+  returnCode((field != NULL && field->form != NULL) ? (int)field->index : -1);
 }
 
 /* fld_current.c ends here */
Index: form/fld_def.c
Prereq:  1.45 
--- ncurses-6.5-20241130+/form/fld_def.c	2024-11-30 21:41:08.000000000 +0000
+++ ncurses-6.5-20241207/form/fld_def.c	2024-12-07 21:56:21.000000000 +0000
@@ -33,7 +33,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: fld_def.c,v 1.45 2024/11/30 21:41:08 tom Exp $")
+MODULE_ID("$Id: fld_def.c,v 1.46 2024/12/07 21:56:21 tom Exp $")
 
 /* this can't be readonly */
 static FIELD default_field =
@@ -87,14 +87,14 @@
 {
   TypeArgument *res = (TypeArgument *)0;
 
-  if (typ != 0 && (typ->status & _HAS_ARGS) != 0)
+  if (typ != NULL && (typ->status & _HAS_ARGS) != 0)
     {
       assert(err != 0 && ap != (va_list *)0);
       if ((typ->status & _LINKED_TYPE) != 0)
 	{
 	  TypeArgument *p = typeMalloc(TypeArgument, 1);
 
-	  if (p != 0)
+	  if (p != NULL)
 	    {
 	      p->left = _nc_Make_Argument(typ->left, ap, err);
 	      p->right = _nc_Make_Argument(typ->right, ap, err);
@@ -134,14 +134,14 @@
 {
   TypeArgument *res = (TypeArgument *)0;
 
-  if (typ != 0 && (typ->status & _HAS_ARGS) != 0)
+  if (typ != NULL && (typ->status & _HAS_ARGS) != 0)
     {
       assert(err != 0 && argp != 0);
       if ((typ->status & _LINKED_TYPE) != 0)
 	{
 	  TypeArgument *p = typeMalloc(TypeArgument, 1);
 
-	  if (p != 0)
+	  if (p != NULL)
 	    {
 	      p->left = _nc_Copy_Argument(typ, argp->left, err);
 	      p->right = _nc_Copy_Argument(typ, argp->right, err);
@@ -180,11 +180,11 @@
 FORM_EXPORT(void)
 _nc_Free_Argument(const FIELDTYPE *typ, TypeArgument *argp)
 {
-  if (typ != 0 && (typ->status & _HAS_ARGS) != 0)
+  if (typ != NULL && (typ->status & _HAS_ARGS) != 0)
     {
       if ((typ->status & _LINKED_TYPE) != 0)
 	{
-	  if (argp != 0)
+	  if (argp != NULL)
 	    {
 	      _nc_Free_Argument(typ->left, argp->left);
 	      _nc_Free_Argument(typ->right, argp->right);
@@ -229,7 +229,7 @@
     }
   else
     {
-      if (dst->type != 0)
+      if (dst->type != NULL)
 	{
 	  dst->type->ref++;
 	}
@@ -249,7 +249,7 @@
 _nc_Free_Type(FIELD *field)
 {
   assert(field != 0);
-  if (field->type != 0)
+  if (field->type != NULL)
     {
       field->type->ref--;
       _nc_Free_Argument(field->type, (TypeArgument *)(field->arg));
@@ -289,7 +289,7 @@
       nrow >= 0 &&
       nbuf >= 0 &&
       ((err = E_SYSTEM_ERROR) != 0) &&	/* trick: this resets the default error */
-      (New_Field = typeMalloc(FIELD, 1)) != 0)
+      (New_Field = typeMalloc(FIELD, 1)) != NULL)
     {
       T((T_CREATE("field %p"), (void *)New_Field));
       *New_Field = default_field;
@@ -360,13 +360,13 @@
     {
       RETURN(E_BAD_ARGUMENT);
     }
-  else if (field->form != 0)
+  else if (field->form != NULL)
     {
       RETURN(E_CONNECTED);
     }
   else if (field == field->link)
     {
-      if (field->buf != 0)
+      if (field->buf != NULL)
 	free(field->buf);
     }
   else
@@ -380,7 +380,7 @@
     }
   _nc_Free_Type(field);
 #if USE_WIDEC_SUPPORT
-  if (field->expanded != 0)
+  if (field->expanded != NULL)
     {
       int n;
 
Index: form/form.priv.h
Prereq:  0.49 
--- ncurses-6.5-20241130+/form/form.priv.h	2024-02-24 12:17:31.000000000 +0000
+++ ncurses-6.5-20241207/form/form.priv.h	2024-12-07 21:57:21.000000000 +0000
@@ -31,7 +31,7 @@
  *   Author:  Juergen Pfeifer, 1995,1997                                    *
  ****************************************************************************/
 
-/* $Id: form.priv.h,v 0.49 2024/02/24 12:17:31 tom Exp $ */
+/* $Id: form.priv.h,v 0.50 2024/12/07 21:57:21 tom Exp $ */
 
 #ifndef FORM_PRIV_H
 #define FORM_PRIV_H 1
@@ -93,11 +93,11 @@
 
 /* If form is NULL replace form argument by default-form */
 #define Normalize_Form(form) \
-  ((form) = (form != 0) ? (form) : _nc_Default_Form)
+  ((form) = (form != NULL) ? (form) : _nc_Default_Form)
 
 /* If field is NULL replace field argument by default-field */
 #define Normalize_Field(field) \
-  ((field) = (field != 0) ? (field) : _nc_Default_Field)
+  ((field) = (field != NULL) ? (field) : _nc_Default_Field)
 
 #if NCURSES_SP_FUNCS
 #define Get_Form_Screen(form) \
@@ -260,7 +260,7 @@
       int len; \
       int n; \
       wchar_t *list = _nc_Widen_String((char *)buffer, &len); \
-      if (list != 0) \
+      if (list != NULL) \
 	{ \
 	  result = TRUE; \
 	  for (n = 0; n < len; ++n) \
Index: form/frm_driver.c
Prereq:  1.136 
--- ncurses-6.5-20241130+/form/frm_driver.c	2024-07-27 18:49:18.000000000 +0000
+++ ncurses-6.5-20241207/form/frm_driver.c	2024-12-07 21:57:21.000000000 +0000
@@ -33,7 +33,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: frm_driver.c,v 1.136 2024/07/27 18:49:18 tom Exp $")
+MODULE_ID("$Id: frm_driver.c,v 1.137 2024/12/07 21:57:21 tom Exp $")
 
 /*----------------------------------------------------------------------------
   This is the core module of the form library. It contains the majority
@@ -734,7 +734,7 @@
 	    {
 	      WINDOW *new_window = newpad(field->drows, field->dcols);
 
-	      if (new_window != 0)
+	      if (new_window != NULL)
 		{
 		  assert(form != (FORM *)0);
 		  if (form->w)
@@ -802,7 +802,7 @@
 Field_encloses(FIELD *field, int ry, int rx)
 {
   T((T_CALLED("Field_encloses(%p)"), (void *)field));
-  if (field != 0
+  if (field != NULL
       && field->frow <= ry
       && (field->frow + field->rows) > ry
       && field->fcol <= rx
@@ -1251,7 +1251,7 @@
     return (E_SYSTEM_ERROR);
 
   for (linked_field = field->link;
-       (linked_field != field) && (linked_field != 0);
+       (linked_field != field) && (linked_field != NULL);
        linked_field = linked_field->link)
     {
       int syncres;
@@ -1458,7 +1458,7 @@
 	      werase(form->w);
 	      Perform_Justification(field, form->w);
 	      if (Field_Has_Option(field, O_DYNAMIC_JUSTIFY) &&
-		  (form->w->_parent == 0))
+		  (form->w->_parent == NULL))
 		{
 		  copywin(form->w,
 			  Get_Form_Window(form),
@@ -1480,7 +1480,7 @@
     }
   delwin(form->w);
   form->w = (WINDOW *)0;
-  form->current = 0;
+  form->current = NULL;
 }
 
 /*---------------------------------------------------------------------------
@@ -4758,7 +4758,7 @@
   int len;
 
 #if USE_WIDEC_SUPPORT
-  FIELD_CELL *widevalue = 0;
+  FIELD_CELL *widevalue = NULL;
 #endif
 
   T((T_CALLED("set_field_buffer(%p,%d,%s)"), (void *)field, buffer, _nc_visbuf(value)));
@@ -4807,7 +4807,7 @@
   wclear(field->working);
   (void)mvwaddstr(field->working, 0, 0, value);
 
-  if ((widevalue = typeCalloc(FIELD_CELL, len + 1)) == 0)
+  if ((widevalue = typeCalloc(FIELD_CELL, len + 1)) == NULL)
     {
       RETURN(E_SYSTEM_ERROR);
     }
@@ -4869,7 +4869,7 @@
 FORM_EXPORT(char *)
 field_buffer(const FIELD *field, int buffer)
 {
-  char *result = 0;
+  char *result = NULL;
 
   T((T_CALLED("field_buffer(%p,%d)"), (const void *)field, buffer));
 
@@ -4890,14 +4890,14 @@
 	      size_t next;
 
 	      init_mb(state);
-	      next = _nc_wcrtomb(0, data[n].chars[0], &state);
+	      next = _nc_wcrtomb(NULL, data[n].chars[0], &state);
 	      if (next > 0)
 		need += next;
 	    }
 	}
 
       /* allocate a place to store the expanded string */
-      if (field->expanded[buffer] != 0)
+      if (field->expanded[buffer] != NULL)
 	free(field->expanded[buffer]);
       field->expanded[buffer] = typeMalloc(char, need + 1);
 
@@ -4909,7 +4909,7 @@
        * contain embedded wide-character extensions).  Change the null-padding
        * to blanks as needed.
        */
-      if ((result = field->expanded[buffer]) != 0)
+      if ((result = field->expanded[buffer]) != NULL)
 	{
 	  wclear(field->working);
 	  wmove(field->working, 0, 0);
@@ -4937,7 +4937,7 @@
 FORM_EXPORT(wchar_t *)
 _nc_Widen_String(char *source, int *lengthp)
 {
-  wchar_t *result = 0;
+  wchar_t *result = NULL;
   wchar_t wch = 0;
   size_t given = strlen(source);
   size_t tries;
@@ -4999,7 +4999,7 @@
 	  result = typeCalloc(wchar_t, need);
 
 	  *lengthp = (int)need;
-	  if (result == 0)
+	  if (result == NULL)
 	    break;
 	}
     }
Index: form/frm_req_name.c
Prereq:  1.23 
--- ncurses-6.5-20241130+/form/frm_req_name.c	2021-06-17 21:11:08.000000000 +0000
+++ ncurses-6.5-20241207/form/frm_req_name.c	2024-12-07 23:00:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2015 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -38,7 +38,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: frm_req_name.c,v 1.23 2021/06/17 21:11:08 tom Exp $")
+MODULE_ID("$Id: frm_req_name.c,v 1.24 2024/12/07 23:00:37 tom Exp $")
 
 #define DATA(s) { s }
 
@@ -153,7 +153,7 @@
 
   T((T_CALLED("form_request_by_name(%s)"), _nc_visbuf(str)));
 
-  if (str != 0 && (i = strlen(str)) != 0)
+  if (str != NULL && (i = strlen(str)) != 0)
     {
       char buf[16];		/* longest name is 10 chars */
 
Index: form/fty_enum.c
Prereq:  1.34 
--- ncurses-6.5-20241130+/form/fty_enum.c	2024-07-27 18:50:22.000000000 +0000
+++ ncurses-6.5-20241207/form/fty_enum.c	2024-12-07 21:58:32.000000000 +0000
@@ -35,7 +35,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: fty_enum.c,v 1.34 2024/07/27 18:50:22 tom Exp $")
+MODULE_ID("$Id: fty_enum.c,v 1.35 2024/12/07 21:58:32 tom Exp $")
 
 typedef struct
   {
@@ -104,7 +104,7 @@
 	      argp->kwds = typeMalloc(char *, cnt + 1);
 
 	      kp = kwds;
-	      if ((kptarget = argp->kwds) != 0)
+	      if ((kptarget = argp->kwds) != NULL)
 		{
 		  while (kp && (*kp))
 		    {
@@ -168,7 +168,7 @@
 	      char **kp = ap->kwds;
 	      result->kwds = typeMalloc(char *, 1 + ap->count);
 
-	      if ((kptarget = result->kwds) != 0)
+	      if ((kptarget = result->kwds) != NULL)
 		{
 		  while (kp && (*kp))
 		    {
Index: form/fty_generic.c
Prereq:  1.16 
--- ncurses-6.5-20241130+/form/fty_generic.c	2024-07-27 18:51:24.000000000 +0000
+++ ncurses-6.5-20241207/form/fty_generic.c	2024-12-07 23:12:11.000000000 +0000
@@ -35,7 +35,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: fty_generic.c,v 1.16 2024/07/27 18:51:24 tom Exp $")
+MODULE_ID("$Id: fty_generic.c,v 1.17 2024/12/07 23:12:11 tom Exp $")
 
 /*
  * This is not a full implementation of a field type, but adds some
@@ -170,7 +170,10 @@
 {
   TypeArgument *res = (TypeArgument *)0;
 
-  if (typ != 0 && (typ->status & _HAS_ARGS) != 0 && err != 0 && argiterator != 0)
+  if (typ != NULL
+      && (typ->status & _HAS_ARGS) != 0
+      && err != NULL
+      && argiterator != NULL)
     {
       if (typ->status & _LINKED_TYPE)
 	{
@@ -189,14 +192,14 @@
       else
 	{
 	  assert(typ->genericarg != (void *)0);
-	  if (typ->genericarg == 0)
+	  if (typ->genericarg == NULL)
 	    *err += 1;
 	  else
 	    {
 	      void *argp;
 	      int valid = argiterator(&argp);
 
-	      if (valid == 0 || argp == 0 ||
+	      if (valid == 0 || argp == NULL ||
 		  !(res = (TypeArgument *)typ->genericarg(argp)))
 		{
 		  *err += 1;
@@ -282,7 +285,7 @@
   int code = E_SYSTEM_ERROR;
   WINDOW *res = (WINDOW *)0;
 
-  if (form != 0 && pRow != 0 && pCol != 0)
+  if (form != NULL && pRow != NULL && pCol != NULL)
     {
       *pRow = form->currow;
       *pCol = form->curcol;
Index: form/fty_int.c
Prereq:  1.34 
--- ncurses-6.5-20241130+/form/fty_int.c	2024-07-27 18:35:02.000000000 +0000
+++ ncurses-6.5-20241207/form/fty_int.c	2024-12-07 21:58:32.000000000 +0000
@@ -35,7 +35,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: fty_int.c,v 1.34 2024/07/27 18:35:02 tom Exp $")
+MODULE_ID("$Id: fty_int.c,v 1.35 2024/12/07 21:58:32 tom Exp $")
 
 #if USE_WIDEC_SUPPORT
 #define isDigit(c) (iswdigit((wint_t)(c)) || isdigit(UChar(c)))
@@ -184,7 +184,7 @@
 	  int len;
 	  wchar_t *list = _nc_Widen_String((char *)bp, &len);
 
-	  if (list != 0)
+	  if (list != NULL)
 	    {
 	      bool blank = FALSE;
 	      int n;
Index: form/fty_num.c
Prereq:  1.38 
--- ncurses-6.5-20241130+/form/fty_num.c	2024-07-27 18:33:58.000000000 +0000
+++ ncurses-6.5-20241207/form/fty_num.c	2024-12-07 21:58:32.000000000 +0000
@@ -35,7 +35,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: fty_num.c,v 1.38 2024/07/27 18:33:58 tom Exp $")
+MODULE_ID("$Id: fty_num.c,v 1.39 2024/12/07 21:58:32 tom Exp $")
 
 #if HAVE_LOCALE_H
 #include <locale.h>
@@ -203,7 +203,7 @@
 	  int len;
 	  wchar_t *list = _nc_Widen_String((char *)bp, &len);
 
-	  if (list != 0)
+	  if (list != NULL)
 	    {
 	      bool blank = FALSE;
 	      int state = 0;
Index: form/fty_regex.c
Prereq:  1.33 
--- ncurses-6.5-20241130+/form/fty_regex.c	2021-08-14 15:01:52.000000000 +0000
+++ ncurses-6.5-20241207/form/fty_regex.c	2024-12-07 23:02:27.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2020,2021 Thomas E. Dickey                                *
+ * Copyright 2018-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2015 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -35,7 +35,7 @@
 
 #include "form.priv.h"
 
-MODULE_ID("$Id: fty_regex.c,v 1.33 2021/08/14 15:01:52 tom Exp $")
+MODULE_ID("$Id: fty_regex.c,v 1.34 2024/12/07 23:02:27 tom Exp $")
 
 #if HAVE_REGEX_H_FUNCS || HAVE_LIB_PCRE2	/* We prefer POSIX regex */
 
@@ -157,12 +157,12 @@
       if (preg)
 	{
 	  T((T_CREATE("RegExp_Arg %p"), (void *)preg));
-	  if (((preg->pRegExp = typeMalloc(regex_t, 1)) != 0)
+	  if (((preg->pRegExp = typeMalloc(regex_t, 1)) != NULL)
 	      && !regcomp(preg->pRegExp, rx,
 			  (REG_EXTENDED | REG_NOSUB | REG_NEWLINE)))
 	    {
 	      T((T_CREATE("regex_t %p"), (void *)preg->pRegExp));
-	      if ((preg->refCount = typeMalloc(unsigned long, 1)) != 0)
+	      if ((preg->refCount = typeMalloc(unsigned long, 1)) != NULL)
 		 *(preg->refCount) = 1;
 	    }
 	  else
Index: include/curses.h.in
Prereq:  1.282 
--- ncurses-6.5-20241130+/include/curses.h.in	2024-01-19 11:50:07.000000000 +0000
+++ ncurses-6.5-20241207/include/curses.h.in	2024-12-07 17:14:44.000000000 +0000
@@ -33,7 +33,7 @@
  *     and: Thomas E. Dickey                        1996-on                 *
  ****************************************************************************/
 
-/* $Id: curses.h.in,v 1.282 2024/01/19 11:50:07 tom Exp $ */
+/* $Id: curses.h.in,v 1.284 2024/12/07 17:14:44 tom Exp $ */
 
 #ifndef __NCURSES_H
 #define __NCURSES_H
@@ -125,10 +125,10 @@
  * doing so makes it incompatible with other implementations of X/Open Curses.
  */
 #undef  NCURSES_CONST
-#define NCURSES_CONST @NCURSES_CONST@
+#define NCURSES_CONST @NCURSES_CONST@	/* for old compilers */
 
 #undef NCURSES_INLINE
-#define NCURSES_INLINE @NCURSES_INLINE@
+#define NCURSES_INLINE @NCURSES_INLINE@	/* for old compilers */
 
 /*
  * The standard type used for color values, and for color-pairs.  The latter
@@ -833,7 +833,7 @@
 extern NCURSES_EXPORT(int) vwprintw (WINDOW *, const char *, va_list) GCC_DEPRECATED(use vw_printw)	/* implemented */
 		GCC_PRINTFLIKE(2,0);
 extern NCURSES_EXPORT(int) vw_printw (WINDOW *, const char *, va_list)	/* implemented */
-		GCC_PRINTFLIKE(2,0);	
+		GCC_PRINTFLIKE(2,0);
 extern NCURSES_EXPORT(int) vwscanw (WINDOW *, const char *, va_list) GCC_DEPRECATED(use vw_scanw)	/* implemented */
 		GCC_SCANFLIKE(2,0);
 extern NCURSES_EXPORT(int) vw_scanw (WINDOW *, const char *, va_list)	/* implemented */
Index: menu/m_driver.c
Prereq:  1.38 
--- ncurses-6.5-20241130+/menu/m_driver.c	2024-07-27 18:14:20.000000000 +0000
+++ ncurses-6.5-20241207/menu/m_driver.c	2024-12-07 22:01:57.000000000 +0000
@@ -38,7 +38,7 @@
 
 #include "menu.priv.h"
 
-MODULE_ID("$Id: m_driver.c,v 1.38 2024/07/27 18:14:20 tom Exp $")
+MODULE_ID("$Id: m_driver.c,v 1.39 2024/12/07 22:01:57 tom Exp $")
 
 /* Macros */
 
@@ -307,7 +307,7 @@
 	  else
 	    {
 	      my_top_row += rdiff;
-	      while (rdiff-- > 0 && item != 0 && item->down != 0)
+	      while (rdiff-- > 0 && item != NULL && item->down != NULL)
 		item = item->down;
 	    }
 	  break;
@@ -320,7 +320,7 @@
 	  else
 	    {
 	      my_top_row -= rdiff;
-	      while (rdiff-- > 0 && item != 0 && item->up != 0)
+	      while (rdiff-- > 0 && item != NULL && item->up != NULL)
 		item = item->up;
 	    }
 	  break;
@@ -548,7 +548,7 @@
 	result = E_UNKNOWN_COMMAND;
     }
 
-  if (item == 0)
+  if (item == NULL)
     {
       result = E_BAD_STATE;
     }
Index: menu/m_global.c
Prereq:  1.34 
--- ncurses-6.5-20241130+/menu/m_global.c	2023-09-16 16:39:26.000000000 +0000
+++ ncurses-6.5-20241207/menu/m_global.c	2024-12-07 23:02:27.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020-2021,2023 Thomas E. Dickey                                *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2014 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -38,7 +38,7 @@
 
 #include "menu.priv.h"
 
-MODULE_ID("$Id: m_global.c,v 1.34 2023/09/16 16:39:26 tom Exp $")
+MODULE_ID("$Id: m_global.c,v 1.35 2024/12/07 23:02:27 tom Exp $")
 
 static char mark[] = "-";
 /* *INDENT-OFF* */
@@ -256,13 +256,13 @@
   int result = item->length;
 
   T((T_CALLED("_nc_menu_text_width(%p)"), (const void *)item));
-  if (result != 0 && item->str != 0)
+  if (result != 0 && item->str != NULL)
     {
-      int count = (int)mbstowcs(0, item->str, 0);
-      wchar_t *temp = 0;
+      int count = (int)mbstowcs(NULL, item->str, 0);
+      wchar_t *temp = NULL;
 
       if (count > 0
-	  && (temp = typeMalloc(wchar_t, 2 + count)) != 0)
+	  && (temp = typeMalloc(wchar_t, 2 + count)) != NULL)
 	{
 	  int n;
 
@@ -296,7 +296,7 @@
 
   assert(menu && menu->items);
 
-  if (menu->items != 0)
+  if (menu->items != NULL)
     {
       ITEM **items;
 
Index: menu/m_item_new.c
Prereq:  1.39 
--- ncurses-6.5-20241130+/menu/m_item_new.c	2024-11-23 19:16:50.000000000 +0000
+++ ncurses-6.5-20241207/menu/m_item_new.c	2024-12-07 22:01:57.000000000 +0000
@@ -45,7 +45,7 @@
 #endif
 #endif
 
-MODULE_ID("$Id: m_item_new.c,v 1.39 2024/11/23 19:16:50 tom Exp $")
+MODULE_ID("$Id: m_item_new.c,v 1.40 2024/12/07 22:01:57 tom Exp $")
 
 /*---------------------------------------------------------------------------
 |   Facility      :  libnmenu
@@ -63,13 +63,13 @@
   bool result = TRUE;
 
 #if USE_WIDEC_SUPPORT
-  int count = (int)mbstowcs(0, s, 0);
-  wchar_t *temp = 0;
+  int count = (int)mbstowcs(NULL, s, 0);
+  wchar_t *temp = NULL;
 
   assert(s);
 
   if (count > 0
-      && (temp = typeCalloc(wchar_t, (2 + (unsigned)count))) != 0)
+      && (temp = typeCalloc(wchar_t, (2 + (unsigned)count))) != NULL)
     {
       int n;
 
@@ -231,7 +231,7 @@
 	  else
 	    {
 	      menu->mark = old_mark;
-	      menu->marklen = (short)((old_mark != 0) ? strlen(old_mark) : 0);
+	      menu->marklen = (short)((old_mark != NULL) ? strlen(old_mark) : 0);
 	      RETURN(E_SYSTEM_ERROR);
 	    }
 	}
Index: menu/m_pattern.c
Prereq:  1.20 
--- ncurses-6.5-20241130+/menu/m_pattern.c	2021-06-17 21:20:30.000000000 +0000
+++ ncurses-6.5-20241207/menu/m_pattern.c	2024-12-07 23:00:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2006,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -38,7 +38,7 @@
 
 #include "menu.priv.h"
 
-MODULE_ID("$Id: m_pattern.c,v 1.20 2021/06/17 21:20:30 tom Exp $")
+MODULE_ID("$Id: m_pattern.c,v 1.21 2024/12/07 23:00:37 tom Exp $")
 
 /*---------------------------------------------------------------------------
 |   Facility      :  libnmenu
@@ -57,7 +57,7 @@
   static char empty[] = "";
 
   T((T_CALLED("menu_pattern(%p)"), (const void *)menu));
-  returnPtr(menu ? (menu->pattern ? menu->pattern : empty) : 0);
+  returnPtr(menu ? (menu->pattern ? menu->pattern : empty) : NULL);
 }
 
 /*---------------------------------------------------------------------------
Index: menu/m_req_name.c
Prereq:  1.27 
--- ncurses-6.5-20241130+/menu/m_req_name.c	2021-06-17 21:11:08.000000000 +0000
+++ ncurses-6.5-20241207/menu/m_req_name.c	2024-12-07 23:00:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2015 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -38,7 +38,7 @@
 
 #include "menu.priv.h"
 
-MODULE_ID("$Id: m_req_name.c,v 1.27 2021/06/17 21:11:08 tom Exp $")
+MODULE_ID("$Id: m_req_name.c,v 1.28 2024/12/07 23:00:37 tom Exp $")
 
 #define DATA(s) { s }
 
@@ -106,7 +106,7 @@
 
   T((T_CALLED("menu_request_by_name(%s)"), _nc_visbuf(str)));
 
-  if (str != 0 && (i = strlen(str)) != 0)
+  if (str != NULL && (i = strlen(str)) != 0)
     {
       char buf[16];
 
Index: menu/mf_common.h
Prereq:  0.26 
--- ncurses-6.5-20241130+/menu/mf_common.h	2024-11-30 21:41:20.000000000 +0000
+++ ncurses-6.5-20241207/menu/mf_common.h	2024-12-07 22:01:18.000000000 +0000
@@ -31,7 +31,7 @@
  *   Author:  Juergen Pfeifer, 1995,1997                                    *
  ****************************************************************************/
 
-/* $Id: mf_common.h,v 0.26 2024/11/30 21:41:20 tom Exp $ */
+/* $Id: mf_common.h,v 0.27 2024/12/07 22:01:18 tom Exp $ */
 
 /* Common internal header for menu and form library */
 
@@ -88,7 +88,7 @@
 
 /* Call object hook */
 #define Call_Hook( object, handler ) \
-   if ( (object) != 0 && ((object)->handler) != (void *) 0 )\
+   if ( (object) != NULL && ((object)->handler) != (void *) 0 )\
    {\
 	SetStatus(object, _IN_DRIVER);\
 	(object)->handler(object);\
Index: ncurses/base/MKkeyname.awk
Prereq:  1.51 
--- ncurses-6.5-20241130+/ncurses/base/MKkeyname.awk	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/MKkeyname.awk	2024-12-07 21:09:39.000000000 +0000
@@ -1,6 +1,6 @@
-# $Id: MKkeyname.awk,v 1.51 2020/02/02 23:34:34 tom Exp $
+# $Id: MKkeyname.awk,v 1.53 2024/12/07 21:09:39 tom Exp $
 ##############################################################################
-# Copyright 2020 Thomas E. Dickey                                            #
+# Copyright 2020,2024 Thomas E. Dickey                                       #
 # Copyright 1998-2016,2017 Free Software Foundation, Inc.                    #
 #                                                                            #
 # Permission is hereby granted, free of charge, to any person obtaining a    #
@@ -59,7 +59,7 @@
 	if (bigstrings) {
 		printf "\t{ -1, 0 }};\n"
 		print ""
-		print "static const char key_names[] = "names";"
+		print "static const char key_names[] ="names";"
 	} else {
 		printf "\t{ 0, 0 }};\n"
 	}
@@ -72,7 +72,7 @@
 	print "safe_keyname (SCREEN *sp, int c)"
 	print "{"
 	print "	char name[20];"
-	print "	NCURSES_CONST char *result = 0;"
+	print "	NCURSES_CONST char *result = NULL;"
 	print ""
 	print "	if (c == -1) {"
 	print "		result = \"-1\";"
@@ -86,7 +86,7 @@
 		print "			}"
 		print "		}"
 	} else {
-		print "		for (i = 0; _nc_key_names[i].name != 0; i++) {"
+		print "		for (i = 0; _nc_key_names[i].name != NULL; i++) {"
 		print "			if (_nc_key_names[i].code == c) {"
 		print "				result = (NCURSES_CONST char *)_nc_key_names[i].name;"
 		print "				break;"
@@ -94,12 +94,12 @@
 		print "		}"
 	}
 	print ""
-	print "		if (result == 0 && (c >= 0 && c < SIZEOF_TABLE)) {"
-	print "			if (MyTable == 0)"
+	print "		if (result == NULL && (c >= 0 && c < SIZEOF_TABLE)) {"
+	print "			if (MyTable == NULL)"
 	print "				MyTable = typeCalloc(char *, SIZEOF_TABLE);"
 	print ""
-	print "			if (MyTable != 0) {"
-	print "				int m_prefix = (sp == 0 || sp->_use_meta);"
+	print "			if (MyTable != NULL) {"
+	print "				int m_prefix = (sp == NULL || sp->_use_meta);"
 	print ""
 	print "				/* if sense of meta() changed, discard cached data */"
 	print "				if (MyInit != (m_prefix + 1)) {"
@@ -112,7 +112,7 @@
 	print "				}"
 	print ""
 	print "				/* create and cache result as needed */"
-	print "				if (MyTable[c] == 0) {"
+	print "				if (MyTable[c] == NULL) {"
 	print "					int cc = c;"
 	print "					char *p = name;"
 	print "#define P_LIMIT (sizeof(name) - (size_t) (p - name))"
@@ -132,22 +132,22 @@
 	print "				result = MyTable[c];"
 	print "			}"
 	print "#if NCURSES_EXT_FUNCS && NCURSES_XNAMES"
-	print "		} else if (result == 0 && HasTerminal(sp)) {"
+	print "		} else if (result == NULL && HasTerminal(sp)) {"
 	print "			int j, k;"
 	print "			char * bound;"
 	print "			TERMTYPE2 *tp = &TerminalType(TerminalOf(sp));"
 	print "			unsigned save_trace = _nc_tracing;"
 	print ""
 	print "			_nc_tracing = 0;	/* prevent recursion via keybound() */"
-	print "			for (j = 0; (bound = NCURSES_SP_NAME(keybound)(NCURSES_SP_ARGx c, j)) != 0; ++j) {"
+	print "			for (j = 0; (bound = NCURSES_SP_NAME(keybound)(NCURSES_SP_ARGx c, j)) != NULL; ++j) {"
 	print "				for(k = STRCOUNT; k < (int) NUM_STRINGS(tp);  k++) {"
-	print "					if (tp->Strings[k] != 0 && !strcmp(bound, tp->Strings[k])) {"
+	print "					if (tp->Strings[k] != NULL && !strcmp(bound, tp->Strings[k])) {"
 	print "						result = ExtStrname(tp, k, strnames);"
 	print "						break;"
 	print "					}"
 	print "				}"
 	print "				free(bound);"
-	print "				if (result != 0)"
+	print "				if (result != NULL)"
 	print "					break;"
 	print "			}"
 	print "			_nc_tracing = save_trace;"
@@ -166,7 +166,7 @@
 	print "#if NO_LEAKS"
 	print "void _nc_keyname_leaks(void)"
 	print "{"
-	print "	if (MyTable != 0) {"
+	print "	if (MyTable != NULL) {"
 	print "		int j;"
 	print "		for (j = 0; j < SIZEOF_TABLE; ++j) {"
 	print "			FreeIfNeeded(MyTable[j]);"
Index: ncurses/base/MKlib_gen.sh
Prereq:  1.74 
--- ncurses-6.5-20241130+/ncurses/base/MKlib_gen.sh	2024-09-22 20:41:58.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/MKlib_gen.sh	2024-12-07 21:50:24.000000000 +0000
@@ -2,7 +2,7 @@
 #
 # MKlib_gen.sh -- generate sources from curses.h macro definitions
 #
-# ($Id: MKlib_gen.sh,v 1.74 2024/09/22 20:41:58 tom Exp $)
+# ($Id: MKlib_gen.sh,v 1.75 2024/12/07 21:50:24 tom Exp $)
 #
 ##############################################################################
 # Copyright 2018-2022,2024 Thomas E. Dickey                                  #
@@ -188,6 +188,9 @@
 cat >$ED4 <<EOF
 	s/^\(.*\) \(.*\) (\(.*\))\$/NCURSES_EXPORT(\1) \2 (\3)/
 	/attr_[sg]et.* z)/s,z),z GCC_UNUSED),
+	s/\(((\)0\([ ]*!=[ ]*(const void\)/\1NULL\2/g
+	/returnCode(wborder_set/s,0,NULL,g
+	/returnWin/s,0,NULL,
 EOF
 else
 cat >$ED4 <<EOF
Index: ncurses/base/MKunctrl.awk
Prereq:  1.30 
--- ncurses-6.5-20241130+/ncurses/base/MKunctrl.awk	2024-02-03 21:09:14.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/MKunctrl.awk	2024-12-07 21:06:39.000000000 +0000
@@ -1,4 +1,4 @@
-# $Id: MKunctrl.awk,v 1.30 2024/02/03 21:09:14 tom Exp $
+# $Id: MKunctrl.awk,v 1.31 2024/12/07 21:06:39 tom Exp $
 ##############################################################################
 # Copyright 2020,2024 Thomas E. Dickey                                       #
 # Copyright 1998-2012,2017 Free Software Foundation, Inc.                    #
@@ -135,7 +135,7 @@
 
 		print ""
 		if (bigstrings) {
-			print "static const char unctrl_blob[] = "blob";"
+			print "static const char unctrl_blob[] ="blob";"
 			print ""
 			stringname = "unctrl_blob + unctrl"
 		} else {
@@ -147,7 +147,7 @@
 		print  "\t(void) sp;"
 		print  "\tif (check >= 0 && check < (int)SIZEOF(unctrl_table)) {"
 		print  "#if NCURSES_EXT_FUNCS"
-		print  "\t\tif ((sp != 0)"
+		print  "\t\tif ((sp != NULL)"
 		print  "\t\t && (sp->_legacy_coding > 1)"
 		print  "\t\t && (check >= 128)"
 		print  "\t\t && (check < 160))"
@@ -156,7 +156,7 @@
 		print  "\t\tif ((check >= 160)"
 		print  "\t\t && (check < 256)"
 		print  "\t\t && !_nc_unicode_locale()"
-		print  "\t\t && ((sp != 0)"
+		print  "\t\t && ((sp != NULL)"
 		print  "\t\t  && ((sp->_legacy_coding > 0)"
 		print  "\t\t   || (sp->_legacy_coding == 0"
 		print  "\t\t       && isprint(check)))))"
@@ -165,7 +165,7 @@
 		print  "#endif /* NCURSES_EXT_FUNCS */"
 		printf "\t\t\tresult = %s_table[check];\n", stringname;
 		print  "\t} else {"
-		print  "\t\tresult = 0;"
+		print  "\t\tresult = NULL;"
 		print  "\t}"
 		print  "\treturn (NCURSES_CONST char *)result;"
 		print  "}"
Index: ncurses/base/define_key.c
Prereq:  1.22 
--- ncurses-6.5-20241130+/ncurses/base/define_key.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/define_key.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2009,2014 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -34,7 +34,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: define_key.c,v 1.22 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: define_key.c,v 1.23 2024/12/07 21:24:18 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(define_key) (NCURSES_SP_DCLx const char *str, int keycode)
@@ -42,7 +42,7 @@
     int code = ERR;
 
     T((T_CALLED("define_key(%p, %s,%d)"), (void *) SP_PARM, _nc_visbuf(str), keycode));
-    if (SP_PARM == 0 || !HasTInfoTerminal(SP_PARM)) {
+    if (SP_PARM == NULL || !HasTInfoTerminal(SP_PARM)) {
 	code = ERR;
     } else if (keycode > 0) {
 	unsigned ukey = (unsigned) keycode;
@@ -53,13 +53,13 @@
 #define CallHasKey(keycode) NCURSES_SP_NAME(has_key)(NCURSES_SP_ARGx keycode)
 #endif
 
-	if (str != 0) {
+	if (str != NULL) {
 	    NCURSES_SP_NAME(define_key) (NCURSES_SP_ARGx str, 0);
 	} else if (CallHasKey(keycode)) {
 	    while (_nc_remove_key(&(SP_PARM->_keytry), ukey))
 		code = OK;
 	}
-	if (str != 0) {
+	if (str != NULL) {
 	    if (NCURSES_SP_NAME(key_defined) (NCURSES_SP_ARGx str) == 0) {
 		if (_nc_add_to_try(&(SP_PARM->_keytry), str, ukey) == OK) {
 		    code = OK;
Index: ncurses/base/key_defined.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/ncurses/base/key_defined.c	2023-06-24 15:36:32.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/key_defined.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 2003-2006,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -34,7 +34,7 @@
 #include <curses.priv.h>
 #include <tic.h>
 
-MODULE_ID("$Id: key_defined.c,v 1.11 2023/06/24 15:36:32 tom Exp $")
+MODULE_ID("$Id: key_defined.c,v 1.12 2024/12/07 21:24:18 tom Exp $")
 
 static int
 find_definition(TRIES * tree, const char *str)
@@ -43,9 +43,9 @@
     int result = OK;
 
     if (VALID_STRING(str) && *str != '\0') {
-	for (ptr = tree; ptr != 0; ptr = ptr->sibling) {
+	for (ptr = tree; ptr != NULL; ptr = ptr->sibling) {
 	    if (UChar(*str) == UChar(ptr->ch)) {
-		if (str[1] == '\0' && ptr->child != 0) {
+		if (str[1] == '\0' && ptr->child != NULL) {
 		    result = ERR;
 		} else if ((result = find_definition(ptr->child, str + 1))
 			   == OK) {
@@ -72,7 +72,7 @@
     int code = ERR;
 
     T((T_CALLED("key_defined(%p, %s)"), (void *) SP_PARM, _nc_visbuf(str)));
-    if (SP_PARM != 0 && str != 0) {
+    if (SP_PARM != NULL && str != NULL) {
 	code = find_definition(SP_PARM->_keytry, str);
     }
 
Index: ncurses/base/keybound.c
Prereq:  1.12 
--- ncurses-6.5-20241130+/ncurses/base/keybound.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/keybound.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1999-2009,2011 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -34,7 +34,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: keybound.c,v 1.12 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: keybound.c,v 1.13 2024/12/07 21:24:18 tom Exp $")
 
 /*
  * Returns the count'th string definition which is associated with the
@@ -43,10 +43,10 @@
 NCURSES_EXPORT(char *)
 NCURSES_SP_NAME(keybound) (NCURSES_SP_DCLx int code, int count)
 {
-    char *result = 0;
+    char *result = NULL;
 
     T((T_CALLED("keybound(%p, %d,%d)"), (void *) SP_PARM, code, count));
-    if (SP_PARM != 0 && code >= 0) {
+    if (SP_PARM != NULL && code >= 0) {
 	result = _nc_expand_try(SP_PARM->_keytry,
 				(unsigned) code,
 				&count,
Index: ncurses/base/keyok.c
Prereq:  1.17 
--- ncurses-6.5-20241130+/ncurses/base/keyok.c	2021-06-17 21:26:02.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/keyok.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019-2020,2021 Thomas E. Dickey                                *
+ * Copyright 2019-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2014 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -34,7 +34,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: keyok.c,v 1.17 2021/06/17 21:26:02 tom Exp $")
+MODULE_ID("$Id: keyok.c,v 1.18 2024/12/07 21:24:18 tom Exp $")
 
 /*
  * Enable (or disable) ncurses' interpretation of a keycode by adding (or
@@ -63,7 +63,7 @@
 
 	    if (flag) {
 		while ((s = _nc_expand_try(SP_PARM->_key_ok,
-					   ch, &count, (size_t) 0)) != 0) {
+					   ch, &count, (size_t) 0)) != NULL) {
 		    if (_nc_remove_key(&(SP_PARM->_key_ok), ch)) {
 			code = _nc_add_to_try(&(SP_PARM->_keytry), s, ch);
 			free(s);
@@ -76,7 +76,7 @@
 		}
 	    } else {
 		while ((s = _nc_expand_try(SP_PARM->_keytry,
-					   ch, &count, (size_t) 0)) != 0) {
+					   ch, &count, (size_t) 0)) != NULL) {
 		    if (_nc_remove_key(&(SP_PARM->_keytry), ch)) {
 			code = _nc_add_to_try(&(SP_PARM->_key_ok), s, ch);
 			free(s);
Index: ncurses/base/legacy_coding.c
Prereq:  1.6 
--- ncurses-6.5-20241130+/ncurses/base/legacy_coding.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/legacy_coding.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 2005,2009 Free Software Foundation, Inc.                       *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -34,7 +34,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: legacy_coding.c,v 1.6 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: legacy_coding.c,v 1.7 2024/12/07 20:00:48 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(use_legacy_coding) (NCURSES_SP_DCLx int level)
@@ -42,7 +42,7 @@
     int result = ERR;
 
     T((T_CALLED("use_legacy_coding(%p,%d)"), (void *) SP_PARM, level));
-    if (level >= 0 && level <= 2 && SP_PARM != 0) {
+    if (level >= 0 && level <= 2 && SP_PARM != NULL) {
 	result = SP_PARM->_legacy_coding;
 	SP_PARM->_legacy_coding = level;
     }
Index: ncurses/base/lib_addch.c
Prereq:  1.143 
--- ncurses-6.5-20241130+/ncurses/base/lib_addch.c	2024-11-30 21:18:07.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_addch.c	2024-12-07 17:18:07.000000000 +0000
@@ -37,7 +37,7 @@
 #include <curses.priv.h>
 #include <ctype.h>
 
-MODULE_ID("$Id: lib_addch.c,v 1.143 2024/11/30 21:18:07 tom Exp $")
+MODULE_ID("$Id: lib_addch.c,v 1.144 2024/12/07 17:18:07 tom Exp $")
 
 static const NCURSES_CH_T blankchar = NewChar(BLANK_TEXT);
 
@@ -451,14 +451,14 @@
     if ((AttrOf(ch) & A_ALTCHARSET)
 	|| (
 #if USE_WIDEC_SUPPORT
-	       (sp != 0 && sp->_legacy_coding) &&
+	       (sp != NULL && sp->_legacy_coding) &&
 #endif
 	       s[1] == 0
 	)
 	|| (
 	       (isprint(UChar(t)) && !iscntrl(UChar(t)))
 #if USE_WIDEC_SUPPORT
-	       || ((sp == 0 || !sp->_legacy_coding) &&
+	       || ((sp == NULL || !sp->_legacy_coding) &&
 		   (WINDOW_EXT(win, addch_used)
 		    || !_nc_is_charable(CharOf(ch))))
 #endif
Index: ncurses/base/lib_addstr.c
Prereq:  1.62 
--- ncurses-6.5-20241130+/ncurses/base/lib_addstr.c	2023-11-21 21:47:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_addstr.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2019-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -45,7 +45,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_addstr.c,v 1.62 2023/11/21 21:47:23 tom Exp $")
+MODULE_ID("$Id: lib_addstr.c,v 1.63 2024/12/07 20:00:48 tom Exp $")
 
 NCURSES_EXPORT(int)
 waddnstr(WINDOW *win, const char *astr, int n)
@@ -55,7 +55,7 @@
 
     T((T_CALLED("waddnstr(%p,%s,%d)"), (void *) win, _nc_visbufn(astr, n), n));
 
-    if (win && (str != 0) && (n != 0)) {
+    if (win && (str != NULL) && (n != 0)) {
 	bool explicit = (n > 0);
 
 	TR(TRACE_VIRTPUT | TRACE_ATTRS,
@@ -123,7 +123,7 @@
 _nc_wchstrlen(const cchar_t *s)
 {
     int result = 0;
-    if (s != 0) {
+    if (s != NULL) {
 	while (CharOf(s[result]) != L'\0') {
 	    result++;
 	}
@@ -230,7 +230,7 @@
 
     T((T_CALLED("waddnwstr(%p,%s,%d)"), (void *) win, _nc_viswbufn(str, n), n));
 
-    if (win && (str != 0) && (n != 0)) {
+    if (win && (str != NULL) && (n != 0)) {
 	bool explicit = (n > 0);
 
 	TR(TRACE_VIRTPUT | TRACE_ATTRS,
Index: ncurses/base/lib_beep.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/ncurses/base/lib_beep.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_beep.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2013,2014 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -47,7 +47,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_beep.c,v 1.18 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_beep.c,v 1.19 2024/12/07 20:00:48 tom Exp $")
 
 /*
  *	beep()
@@ -69,7 +69,7 @@
 	res = CallDriver_1(SP_PARM, td_doBeepOrFlash, TRUE);
 #else
     /* FIXME: should make sure that we are not in altchar mode */
-    if (cur_term == 0) {
+    if (cur_term == NULL) {
 	res = ERR;
     } else if (bell) {
 	res = NCURSES_PUTP2_FLUSH("bell", bell);
Index: ncurses/base/lib_bkgd.c
Prereq:  1.63 
--- ncurses-6.5-20241130+/ncurses/base/lib_bkgd.c	2021-05-08 14:58:12.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_bkgd.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2020,2021 Thomas E. Dickey                                *
+ * Copyright 2018-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2014,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -37,7 +37,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_bkgd.c,v 1.63 2021/05/08 14:58:12 tom Exp $")
+MODULE_ID("$Id: lib_bkgd.c,v 1.64 2024/12/07 20:00:48 tom Exp $")
 
 static const NCURSES_CH_T blank = NewChar(BLANK_TEXT);
 
@@ -136,7 +136,7 @@
 #define TraceChar(c) _tracechar(CharOf(c))
 #endif
 
-    if (SP == 0) {
+    if (SP == NULL) {
 	;
     } else if (win) {
 	NCURSES_CH_T new_bkgd = CHDEREF(ch);
Index: ncurses/base/lib_color.c
Prereq:  1.152 
--- ncurses-6.5-20241130+/ncurses/base/lib_color.c	2024-11-23 18:27:25.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_color.c	2024-12-07 17:28:13.000000000 +0000
@@ -49,7 +49,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_color.c,v 1.152 2024/11/23 18:27:25 tom Exp $")
+MODULE_ID("$Id: lib_color.c,v 1.153 2024/12/07 17:28:13 tom Exp $")
 
 #ifdef USE_TERM_DRIVER
 #define CanChange      InfoOf(SP_PARM).canchange
@@ -146,13 +146,13 @@
 static int
 default_fg(NCURSES_SP_DCL0)
 {
-    return (SP_PARM != 0) ? SP_PARM->_default_fg : COLOR_WHITE;
+    return (SP_PARM != NULL) ? SP_PARM->_default_fg : COLOR_WHITE;
 }
 
 static int
 default_bg(NCURSES_SP_DCL0)
 {
-    return SP_PARM != 0 ? SP_PARM->_default_bg : COLOR_BLACK;
+    return SP_PARM != NULL ? SP_PARM->_default_bg : COLOR_BLACK;
 }
 #else
 #define default_fg(sp) COLOR_WHITE
@@ -273,7 +273,7 @@
 	    result->bits.red = UChar(n);
 	    result->bits.green = UChar(n);
 	    result->bits.blue = UChar(n);
-	} else if ((s = tigetstr(name)) != 0 && VALID_STRING(s)) {
+	} else if ((s = tigetstr(name)) != NULL && VALID_STRING(s)) {
 	    int red = n;
 	    int green = n;
 	    int blue = width - (2 * n);
@@ -312,7 +312,7 @@
     bool result = FALSE;
 
     (void) SP_PARM;
-    if (orig_pair != 0) {
+    if (orig_pair != NULL) {
 	(void) NCURSES_PUTP2("orig_pair", orig_pair);
 	result = TRUE;
     }
@@ -339,7 +339,7 @@
 #ifdef USE_TERM_DRIVER
     result = CallDriver(SP_PARM, td_rescolors);
 #else
-    if (orig_colors != 0) {
+    if (orig_colors != NULL) {
 	NCURSES_PUTP2("orig_colors", orig_colors);
 	result = TRUE;
     }
@@ -362,7 +362,7 @@
 
     T((T_CALLED("start_color(%p)"), (void *) SP_PARM));
 
-    if (SP_PARM == 0) {
+    if (SP_PARM == NULL) {
 	result = ERR;
     } else if (SP_PARM->_coloron) {
 	result = OK;
@@ -406,12 +406,12 @@
 #endif
 
 	    ReservePairs(SP_PARM, 16);
-	    if (SP_PARM->_color_pairs != 0) {
+	    if (SP_PARM->_color_pairs != NULL) {
 		if (init_direct_colors(NCURSES_SP_ARG)) {
 		    result = OK;
 		} else {
 		    TYPE_CALLOC(color_t, maxcolors, SP_PARM->_color_table);
-		    if (SP_PARM->_color_table != 0) {
+		    if (SP_PARM->_color_table != NULL) {
 			MakeColorPair(SP_PARM->_color_pairs[0],
 				      default_fg(NCURSES_SP_ARG),
 				      default_bg(NCURSES_SP_ARG));
@@ -425,7 +425,7 @@
 		       COLORS, COLOR_PAIRS));
 
 		    SP_PARM->_coloron = 1;
-		} else if (SP_PARM->_color_pairs != 0) {
+		} else if (SP_PARM->_color_pairs != NULL) {
 		    FreeAndNull(SP_PARM->_color_pairs);
 		}
 	    }
@@ -526,13 +526,13 @@
     if (have > sp->_pair_limit)
 	have = sp->_pair_limit;
 
-    if (sp->_color_pairs == 0) {
+    if (sp->_color_pairs == NULL) {
 	TYPE_CALLOC(colorpair_t, have, sp->_color_pairs);
     } else if (have > sp->_pair_alloc) {
 #if NCURSES_EXT_COLORS && NCURSES_EXT_FUNCS
 	colorpair_t *next;
 
-	if ((next = typeCalloc(colorpair_t, have)) == 0)
+	if ((next = typeCalloc(colorpair_t, have)) == NULL)
 	    _nc_err_abort(MSG_NO_MEMORY);
 	memcpy(next, sp->_color_pairs, (size_t) sp->_pair_alloc * sizeof(*next));
 	_nc_copy_pairs(sp, next, sp->_color_pairs, sp->_pair_alloc);
@@ -546,7 +546,7 @@
 	}
 #endif
     }
-    if (sp->_color_pairs != 0) {
+    if (sp->_color_pairs != NULL) {
 	sp->_pair_alloc = have;
     }
 }
@@ -713,7 +713,7 @@
        color,
        r, g, b));
 
-    if (sp == 0 || sp->_direct_color.value)
+    if (sp == NULL || sp->_direct_color.value)
 	returnCode(result);
 
     maxcolors = MaxColors;
@@ -837,7 +837,7 @@
        (void *) g,
        (void *) b));
 
-    if (sp != 0) {
+    if (sp != NULL) {
 	int maxcolors = MaxColors;
 
 	if (color >= 0 && OkColorHi(color) && sp->_coloron) {
@@ -1008,14 +1008,14 @@
 				    TIPARM_1(set_color_pair, pair),
 				    1, outc);
 	    return;
-	} else if (SP_PARM != 0) {
+	} else if (SP_PARM != NULL) {
 	    if (_nc_pair_content(SP_PARM, pair, &fg, &bg) == ERR)
 		return;
 	}
     }
 
     if (old_pair >= 0
-	&& SP_PARM != 0
+	&& SP_PARM != NULL
 	&& _nc_pair_content(SP_PARM, old_pair, &old_fg, &old_bg) != ERR) {
 	if ((isDefaultColor(fg) && !isDefaultColor(old_fg))
 	    || (isDefaultColor(bg) && !isDefaultColor(old_bg))) {
@@ -1115,11 +1115,11 @@
 NCURSES_EXPORT(void)
 NCURSES_SP_NAME(reset_color_pairs) (NCURSES_SP_DCL0)
 {
-    if (SP_PARM != 0) {
+    if (SP_PARM != NULL) {
 	if (SP_PARM->_color_pairs) {
 	    _nc_free_ordered_pairs(SP_PARM);
 	    free(SP_PARM->_color_pairs);
-	    SP_PARM->_color_pairs = 0;
+	    SP_PARM->_color_pairs = NULL;
 	    SP_PARM->_pair_alloc = 0;
 	    ReservePairs(SP_PARM, 16);
 	    clearok(CurScreen(SP_PARM), TRUE);
Index: ncurses/base/lib_colorset.c
Prereq:  1.16 
--- ncurses-6.5-20241130+/ncurses/base/lib_colorset.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_colorset.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -42,7 +42,7 @@
 #include <curses.priv.h>
 #include <ctype.h>
 
-MODULE_ID("$Id: lib_colorset.c,v 1.16 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_colorset.c,v 1.17 2024/12/07 20:00:48 tom Exp $")
 
 NCURSES_EXPORT(int)
 wcolor_set(WINDOW *win, NCURSES_PAIRS_T pair_arg, void *opts)
@@ -53,7 +53,7 @@
     T((T_CALLED("wcolor_set(%p,%d)"), (void *) win, color_pair));
     set_extended_pair(opts, color_pair);
     if (win
-	&& (SP != 0)
+	&& (SP != NULL)
 	&& (color_pair >= 0)
 	&& (color_pair < SP->_pair_limit)) {
 	TR(TRACE_ATTRS, ("... current %ld", (long) GET_WINDOW_PAIR(win)));
Index: ncurses/base/lib_delwin.c
Prereq:  1.28 
--- ncurses-6.5-20241130+/ncurses/base/lib_delwin.c	2024-07-27 18:57:35.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_delwin.c	2024-12-07 17:28:13.000000000 +0000
@@ -43,7 +43,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_delwin.c,v 1.28 2024/07/27 18:57:35 tom Exp $")
+MODULE_ID("$Id: lib_delwin.c,v 1.29 2024/12/07 17:28:13 tom Exp $")
 
 static bool
 cannot_delete(const WINDOW *win)
@@ -80,7 +80,7 @@
     T((T_CALLED("delwin(%p)"), (void *) win));
 
     if (_nc_try_global(curses) == 0) {
-	if (win == 0
+	if (win == NULL
 	    || cannot_delete(win)) {
 	    result = ERR;
 	} else if (IS_PAD(win)) {
@@ -92,7 +92,7 @@
 #endif
 	    if (IS_SUBWIN(win)) {
 		touchwin(win->_parent);
-	    } else if (CurScreen(SP_PARM) != 0) {
+	    } else if (CurScreen(SP_PARM) != NULL) {
 		touchwin(CurScreen(SP_PARM));
 	    }
 	    result = _nc_freewin(win);
Index: ncurses/base/lib_dft_fgbg.c
Prereq:  1.31 
--- ncurses-6.5-20241130+/ncurses/base/lib_dft_fgbg.c	2021-04-03 22:27:18.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_dft_fgbg.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -38,7 +38,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_dft_fgbg.c,v 1.31 2021/04/03 22:27:18 tom Exp $")
+MODULE_ID("$Id: lib_dft_fgbg.c,v 1.32 2024/12/07 20:00:48 tom Exp $")
 
 /*
  * Modify the behavior of color-pair 0 so that the library doesn't assume that
@@ -69,7 +69,7 @@
     int code = ERR;
 
     T((T_CALLED("assume_default_colors(%p,%d,%d)"), (void *) SP_PARM, fg, bg));
-    if (SP_PARM != 0) {
+    if (SP_PARM != NULL) {
 #ifdef USE_TERM_DRIVER
 	code = CallDriver_2(SP_PARM, td_defaultcolors, fg, bg);
 #else
@@ -79,7 +79,7 @@
 	    SP_PARM->_has_sgr_39_49 = (tigetflag("AX") == TRUE);
 	    SP_PARM->_default_fg = isDefaultColor(fg) ? COLOR_DEFAULT : fg;
 	    SP_PARM->_default_bg = isDefaultColor(bg) ? COLOR_DEFAULT : bg;
-	    if (SP_PARM->_color_pairs != 0) {
+	    if (SP_PARM->_color_pairs != NULL) {
 		bool save = SP_PARM->_default_color;
 		SP_PARM->_assumed_color = TRUE;
 		SP_PARM->_default_color = TRUE;
Index: ncurses/base/lib_echo.c
Prereq:  1.10 
--- ncurses-6.5-20241130+/ncurses/base/lib_echo.c	2023-04-29 18:57:12.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_echo.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2000,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -45,13 +45,13 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_echo.c,v 1.10 2023/04/29 18:57:12 tom Exp $")
+MODULE_ID("$Id: lib_echo.c,v 1.11 2024/12/07 20:00:48 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(echo) (NCURSES_SP_DCL0)
 {
     T((T_CALLED("echo(%p)"), (void *) SP_PARM));
-    if (0 == SP_PARM)
+    if (NULL == SP_PARM)
 	returnCode(ERR);
     IsEcho(SP_PARM) = TRUE;
     returnCode(OK);
@@ -69,7 +69,7 @@
 NCURSES_SP_NAME(noecho) (NCURSES_SP_DCL0)
 {
     T((T_CALLED("noecho(%p)"), (void *) SP_PARM));
-    if (0 == SP_PARM)
+    if (NULL == SP_PARM)
 	returnCode(ERR);
     IsEcho(SP_PARM) = FALSE;
     returnCode(OK);
Index: ncurses/base/lib_erase.c
Prereq:  1.20 
--- ncurses-6.5-20241130+/ncurses/base/lib_erase.c	2022-09-03 21:40:27.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_erase.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2022 Thomas E. Dickey                                     *
+ * Copyright 2020-2022,2024 Thomas E. Dickey                                *
  * Copyright 1998-2009,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -42,7 +42,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_erase.c,v 1.20 2022/09/03 21:40:27 tom Exp $")
+MODULE_ID("$Id: lib_erase.c,v 1.21 2024/12/07 20:00:48 tom Exp $")
 
 NCURSES_EXPORT(int)
 werase(WINDOW *win)
@@ -71,7 +71,7 @@
 	     */
 	    if_WIDEC({
 		if (isWidecExt(start[0])) {
-		    int x = (win->_parent != 0) ? (win->_begx) : 0;
+		    int x = (win->_parent != NULL) ? (win->_begx) : 0;
 		    while (x-- > 0) {
 			if (isWidecBase(start[-1])) {
 			    --start;
Index: ncurses/base/lib_freeall.c
Prereq:  1.77 
--- ncurses-6.5-20241130+/ncurses/base/lib_freeall.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_freeall.c	2024-12-07 18:00:11.000000000 +0000
@@ -40,7 +40,7 @@
 extern int malloc_errfd;	/* FIXME */
 #endif
 
-MODULE_ID("$Id: lib_freeall.c,v 1.77 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: lib_freeall.c,v 1.78 2024/12/07 18:00:11 tom Exp $")
 
 /*
  * Free all ncurses data.  This is used for testing only (there's no practical
@@ -54,11 +54,11 @@
     T((T_CALLED("_nc_freeall()")));
 #if NO_LEAKS
     _nc_globals.leak_checking = TRUE;
-    if (SP_PARM != 0) {
-	if (SP_PARM->_oldnum_list != 0) {
+    if (SP_PARM != NULL) {
+	if (SP_PARM->_oldnum_list != NULL) {
 	    FreeAndNull(SP_PARM->_oldnum_list);
 	}
-	if (SP_PARM->_panelHook.destroy != 0) {
+	if (SP_PARM->_panelHook.destroy != NULL) {
 	    SP_PARM->_panelHook.destroy(SP_PARM->_panelHook.stdscr_pseudo_panel);
 	}
 #if NCURSES_EXT_COLORS
@@ -66,10 +66,10 @@
 #endif
     }
 #endif
-    if (SP_PARM != 0) {
+    if (SP_PARM != NULL) {
 	_nc_lock_global(curses);
 
-	while (WindowList(SP_PARM) != 0) {
+	while (WindowList(SP_PARM) != NULL) {
 	    WINDOWLIST *p, *q;
 	    bool deleted = FALSE;
 
@@ -119,7 +119,7 @@
 	_nc_unlock_global(curses);
     }
 
-    (void) _nc_printf_string(0, empty_va);
+    (void) _nc_printf_string(NULL, empty_va);
 #ifdef TRACE
     (void) _nc_trace_buf(-1, (size_t) 0);
 #endif
Index: ncurses/base/lib_getch.c
Prereq:  1.147 
--- ncurses-6.5-20241130+/ncurses/base/lib_getch.c	2024-08-31 15:54:49.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_getch.c	2024-12-07 17:40:33.000000000 +0000
@@ -44,7 +44,7 @@
 #define NEED_KEY_EVENT
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_getch.c,v 1.147 2024/08/31 15:54:49 tom Exp $")
+MODULE_ID("$Id: lib_getch.c,v 1.148 2024/12/07 17:40:33 tom Exp $")
 
 #include <fifo_defs.h>
 
@@ -414,7 +414,7 @@
     SCREEN *sp = _nc_screen_of(win);
     int rc;
 
-    if (sp != 0) {
+    if (sp != NULL) {
 #ifdef USE_PTHREADS
 	if (_nc_use_pthreads && sp != CURRENT_SCREEN) {
 	    SCREEN *save_SP;
@@ -457,7 +457,7 @@
     *result = 0;
 
     sp = _nc_screen_of(win);
-    if (win == 0 || sp == 0) {
+    if (win == NULL || sp == NULL) {
 	returnCode(ERR);
     }
 
Index: ncurses/base/lib_initscr.c
Prereq:  1.48 
--- ncurses-6.5-20241130+/ncurses/base/lib_initscr.c	2020-09-07 14:26:48.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_initscr.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019,2020 Thomas E. Dickey                                     *
+ * Copyright 2019-2020,2024 Thomas E. Dickey                                *
  * Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -46,7 +46,7 @@
 #include <sys/termio.h>		/* needed for ISC */
 #endif
 
-MODULE_ID("$Id: lib_initscr.c,v 1.48 2020/09/07 14:26:48 tom Exp $")
+MODULE_ID("$Id: lib_initscr.c,v 1.49 2024/12/07 20:00:48 tom Exp $")
 
 NCURSES_EXPORT(WINDOW *)
 initscr(void)
@@ -90,7 +90,7 @@
 	    }
 	}
 #endif
-	if (newterm(name, stdout, stdin) == 0) {
+	if (newterm(name, stdout, stdin) == NULL) {
 	    fprintf(stderr, "Error opening terminal: %s.\n", name);
 	    ExitProgram(EXIT_FAILURE);
 	}
Index: ncurses/base/lib_insch.c
Prereq:  1.38 
--- ncurses-6.5-20241130+/ncurses/base/lib_insch.c	2024-07-27 19:23:21.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_insch.c	2024-12-07 17:40:33.000000000 +0000
@@ -44,7 +44,7 @@
 #include <curses.priv.h>
 #include <ctype.h>
 
-MODULE_ID("$Id: lib_insch.c,v 1.38 2024/07/27 19:23:21 tom Exp $")
+MODULE_ID("$Id: lib_insch.c,v 1.39 2024/12/07 17:40:33 tom Exp $")
 
 /*
  * Insert the given character, updating the current location to simplify
@@ -85,7 +85,7 @@
 #endif
 	       (isprint(ch8) ||
 		(ChAttrOf(ch) & A_ALTCHARSET) ||
-		(sp != 0 && sp->_legacy_coding && !iscntrl(ch8)))) {
+		(sp != NULL && sp->_legacy_coding && !iscntrl(ch8)))) {
 	    if (win->_curx <= win->_maxx) {
 		struct ldat *line = &(win->_line[win->_cury]);
 		NCURSES_CH_T *end = &(line->text[win->_curx]);
@@ -151,7 +151,7 @@
 
     T((T_CALLED("winsch(%p, %s)"), (void *) win, _tracechtype(c)));
 
-    if (win != 0) {
+    if (win != NULL) {
 	NCURSES_SIZE_T oy = win->_cury;
 	NCURSES_SIZE_T ox = win->_curx;
 
Index: ncurses/base/lib_insnstr.c
Prereq:  1.10 
--- ncurses-6.5-20241130+/ncurses/base/lib_insnstr.c	2023-11-21 21:58:03.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_insnstr.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2018-2023,2024 Thomas E. Dickey                                *
  * Copyright 2004-2009,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -41,7 +41,7 @@
 #include <curses.priv.h>
 #include <ctype.h>
 
-MODULE_ID("$Id: lib_insnstr.c,v 1.10 2023/11/21 21:58:03 tom Exp $")
+MODULE_ID("$Id: lib_insnstr.c,v 1.11 2024/12/07 20:00:48 tom Exp $")
 
 NCURSES_EXPORT(int)
 winsnstr(WINDOW *win, const char *s, int n)
@@ -51,7 +51,7 @@
 
     T((T_CALLED("winsnstr(%p,%s,%d)"), (void *) win, _nc_visbufn(s, n), n));
 
-    if (win != 0 && str != 0 && n != 0) {
+    if (win != NULL && str != NULL && n != 0) {
 	SCREEN *sp = _nc_screen_of(win);
 #if USE_WIDEC_SUPPORT
 	/*
@@ -64,7 +64,7 @@
 	if (sp->_screen_unicode) {
 	    size_t nn = (n > 0) ? (size_t) n : strlen(s);
 	    wchar_t *buffer = typeMalloc(wchar_t, nn + 1);
-	    if (buffer != 0) {
+	    if (buffer != NULL) {
 		mbstate_t state;
 		size_t n3;
 		init_mb(state);
Index: ncurses/base/lib_instr.c
Prereq:  1.27 
--- ncurses-6.5-20241130+/ncurses/base/lib_instr.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_instr.c	2024-12-07 17:53:39.000000000 +0000
@@ -42,7 +42,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_instr.c,v 1.27 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: lib_instr.c,v 1.28 2024/12/07 17:53:39 tom Exp $")
 
 NCURSES_EXPORT(int)
 winnstr(WINDOW *win, char *str, int n)
@@ -72,17 +72,17 @@
 		wchar_t *wch;
 		int n2;
 
-		n2 = getcchar(cell, 0, 0, 0, 0);
+		n2 = getcchar(cell, NULL, NULL, NULL, NULL);
 		if (n2 > 0
-		    && (wch = typeCalloc(wchar_t, (unsigned) n2 + 1)) != 0) {
+		    && (wch = typeCalloc(wchar_t, (unsigned) n2 + 1)) != NULL) {
 		    bool done = FALSE;
 
-		    if (getcchar(cell, wch, &attrs, &pair, 0) == OK) {
+		    if (getcchar(cell, wch, &attrs, &pair, NULL) == OK) {
 			mbstate_t state;
 			size_t n3;
 
 			init_mb(state);
-			n3 = wcstombs(0, wch, (size_t) 0);
+			n3 = wcstombs(NULL, wch, (size_t) 0);
 			if (!isEILSEQ(n3) && (n3 != 0) && (n3 <= MB_LEN_MAX)) {
 			    size_t need = n3 + 10 + (size_t) i;
 			    int have = (int) n3 + i;
@@ -90,7 +90,7 @@
 			    /* check for loop-done as well as overflow */
 			    if (have > n || (int) need <= 0) {
 				done = TRUE;
-			    } else if ((tmp = typeCalloc(char, need)) == 0) {
+			    } else if ((tmp = typeCalloc(char, need)) == NULL) {
 				done = TRUE;
 			    } else {
 				size_t i3;
Index: ncurses/base/lib_mouse.c
Prereq:  1.202 
--- ncurses-6.5-20241130+/ncurses/base/lib_mouse.c	2024-11-23 19:06:20.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_mouse.c	2024-12-07 17:40:33.000000000 +0000
@@ -85,7 +85,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_mouse.c,v 1.202 2024/11/23 19:06:20 tom Exp $")
+MODULE_ID("$Id: lib_mouse.c,v 1.203 2024/12/07 17:40:33 tom Exp $")
 
 #include <tic.h>
 
@@ -391,7 +391,7 @@
     sp->_mouse_xtermcap = tigetstr("XM");
     if (VALID_STRING(sp->_mouse_xtermcap)) {
 	char *code = strstr(sp->_mouse_xtermcap, "[?");
-	if (code != 0) {
+	if (code != NULL) {
 	    code += 2;
 	    while ((*code >= '0') && (*code <= '9')) {
 		char *next = code;
@@ -761,7 +761,7 @@
     /* we know how to recognize mouse events under "xterm" */
     if (NonEmpty(key_mouse)) {
 	init_xterm_mouse(sp);
-    } else if (strstr(SP_TERMTYPE term_names, "xterm") != 0) {
+    } else if (strstr(SP_TERMTYPE term_names, "xterm") != NULL) {
 	if (_nc_add_to_try(&(sp->_keytry), xterm_kmous, KEY_MOUSE) == OK)
 	    init_xterm_mouse(sp);
     }
@@ -778,7 +778,7 @@
 
     T((T_CALLED("_nc_mouse_init(%p)"), (void *) sp));
 
-    if (sp != 0) {
+    if (sp != NULL) {
 	if (!sp->_mouse_initialized) {
 	    int i;
 
@@ -1834,10 +1834,10 @@
 
     T((T_CALLED("getmouse(%p,%p)"), (void *) SP_PARM, (void *) aevent));
 
-    if ((aevent != 0) &&
-	(SP_PARM != 0) &&
+    if ((aevent != NULL) &&
+	(SP_PARM != NULL) &&
 	(SP_PARM->_mouse_type != M_NONE) &&
-	(eventp = SP_PARM->_mouse_eventp) != 0) {
+	(eventp = SP_PARM->_mouse_eventp) != NULL) {
 	/* compute the current-event pointer */
 	MEVENT *prev = PREV(eventp);
 
@@ -1890,9 +1890,9 @@
 
     T((T_CALLED("ungetmouse(%p,%p)"), (void *) SP_PARM, (void *) aevent));
 
-    if (aevent != 0 &&
-	SP_PARM != 0 &&
-	(eventp = SP_PARM->_mouse_eventp) != 0) {
+    if (aevent != NULL &&
+	SP_PARM != NULL &&
+	(eventp = SP_PARM->_mouse_eventp) != NULL) {
 
 	/* stick the given event in the next-free slot */
 	*eventp = *aevent;
@@ -1926,7 +1926,7 @@
        (unsigned long) newmask,
        (void *) oldmask));
 
-    if (SP_PARM != 0) {
+    if (SP_PARM != NULL) {
 	if (oldmask)
 	    *oldmask = SP_PARM->_mouse_mask;
 
@@ -1988,7 +1988,7 @@
 
     T((T_CALLED("wenclose(%p,%d,%d)"), (const void *) win, y, x));
 
-    if (win != 0) {
+    if (win != NULL) {
 	y -= win->_yoffset;
 	if (IS_PAD(win)) {
 	    if (win->_pad._pad_y >= 0 &&
@@ -2020,7 +2020,7 @@
 
     T((T_CALLED("mouseinterval(%p,%d)"), (void *) SP_PARM, maxclick));
 
-    if (SP_PARM != 0) {
+    if (SP_PARM != NULL) {
 	oldval = SP_PARM->_maxclick;
 	if (maxclick >= 0)
 	    SP_PARM->_maxclick = maxclick;
@@ -2044,7 +2044,7 @@
 NCURSES_EXPORT(bool)
 _nc_has_mouse(const SCREEN *sp)
 {
-    return (((0 == sp) || (sp->_mouse_type == M_NONE)) ? FALSE : TRUE);
+    return (((NULL == sp) || (sp->_mouse_type == M_NONE)) ? FALSE : TRUE);
 }
 
 NCURSES_EXPORT(bool)
Index: ncurses/base/lib_newterm.c
Prereq:  1.106 
--- ncurses-6.5-20241130+/ncurses/base/lib_newterm.c	2024-11-23 18:33:35.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_newterm.c	2024-12-07 17:41:36.000000000 +0000
@@ -49,7 +49,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: lib_newterm.c,v 1.106 2024/11/23 18:33:35 tom Exp $")
+MODULE_ID("$Id: lib_newterm.c,v 1.107 2024/12/07 17:41:36 tom Exp $")
 
 #ifdef USE_TERM_DRIVER
 #define NumLabels      InfoOf(SP_PARM).numlabels
@@ -175,12 +175,12 @@
 			  FILE *ifp)
 {
     int errret;
-    SCREEN *result = 0;
+    SCREEN *result = NULL;
     SCREEN *current;
     TERMINAL *its_term;
     FILE *_ofp = ofp ? ofp : stdout;
     FILE *_ifp = ifp ? ifp : stdin;
-    TERMINAL *new_term = 0;
+    TERMINAL *new_term = NULL;
 
     START_TRACE();
     T((T_CALLED("newterm(%p, \"%s\", %p,%p)"),
@@ -191,7 +191,7 @@
 
 #if NCURSES_SP_FUNCS
     assert(SP_PARM != 0);
-    if (SP_PARM == 0)
+    if (SP_PARM == NULL)
 	returnSP(SP_PARM);
 #endif
 
@@ -199,7 +199,7 @@
     _nc_lock_global(curses);
 
     current = CURRENT_SCREEN;
-    its_term = (current ? current->_term : 0);
+    its_term = (current ? current->_term : NULL);
 
 #if defined(EXP_WIN32_DRIVER)
     _setmode(fileno(_ifp), _O_BINARY);
@@ -214,7 +214,7 @@
 	int slk_format;
 	bool filter_mode;
 
-	_nc_set_screen(0);
+	_nc_set_screen(NULL);
 #ifdef USE_TERM_DRIVER
 	assert(new_term != 0);
 #endif
@@ -241,7 +241,7 @@
 						 filter_mode,
 						 slk_format) == ERR) {
 	    _nc_set_screen(current);
-	    result = 0;
+	    result = NULL;
 	} else {
 	    int value;
 	    int cols;
@@ -318,7 +318,7 @@
 
 	    NCURSES_SP_NAME(baudrate) (NCURSES_SP_ARG);		/* sets a field in the screen structure */
 
-	    SP_PARM->_keytry = 0;
+	    SP_PARM->_keytry = NULL;
 
 	    /* compute movement costs so we can do better move optimization */
 #ifdef USE_TERM_DRIVER
@@ -333,7 +333,7 @@
 	     * properly if we remove rmso or rmul.  Curses applications
 	     * shouldn't be looking at this detail.
 	     */
-#define SGR0_TEST(mode) (mode != 0) && (exit_attribute_mode == 0 || strcmp(mode, exit_attribute_mode))
+#define SGR0_TEST(mode) (mode != NULL) && (exit_attribute_mode == NULL || strcmp(mode, exit_attribute_mode))
 	    SP_PARM->_use_rmso = SGR0_TEST(exit_standout_mode);
 	    SP_PARM->_use_rmul = SGR0_TEST(exit_underline_mode);
 #if USE_ITALIC
Index: ncurses/base/lib_newwin.c
Prereq:  1.77 
--- ncurses-6.5-20241130+/ncurses/base/lib_newwin.c	2024-09-28 15:55:56.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_newwin.c	2024-12-07 20:19:18.000000000 +0000
@@ -44,7 +44,7 @@
 #include <curses.priv.h>
 #include <stddef.h>
 
-MODULE_ID("$Id: lib_newwin.c,v 1.77 2024/09/28 15:55:56 tom Exp $")
+MODULE_ID("$Id: lib_newwin.c,v 1.78 2024/12/07 20:19:18 tom Exp $")
 
 #define window_is(name) ((sp)->_##name == win)
 
@@ -53,9 +53,9 @@
 		sp->_##name = 0
 #else
 #define remove_window(name) \
-		sp->_##name = 0; \
+		sp->_##name = NULL; \
 		if (win == name) \
-		    name = 0
+		    name = NULL
 #endif
 
 static void
@@ -64,7 +64,7 @@
     SCREEN *sp;
 
 #ifdef USE_SP_WINDOWLIST
-    if ((sp = _nc_screen_of(win)) != 0) {
+    if ((sp = _nc_screen_of(win)) != NULL) {
 	if (window_is(curscr)) {
 	    remove_window(curscr);
 	} else if (window_is(stdscr)) {
@@ -99,17 +99,17 @@
 
     T((T_CALLED("_nc_freewin(%p)"), (void *) win));
 
-    if (win != 0) {
+    if (win != NULL) {
 
 	if (_nc_nonsp_try_global(curses) == 0) {
 	    WINDOWLIST *p, *q;
 
-	    q = 0;
+	    q = NULL;
 	    for (each_window(sp, p)) {
 
 		if (&(p->win) == win) {
 		    remove_window_from_screen(win);
-		    if (q == 0)
+		    if (q == NULL)
 			WindowList(sp) = p->next;
 		    else
 			q->next = p->next;
@@ -150,8 +150,8 @@
 	|| begx < 0
 	|| num_lines < 0
 	|| num_columns < 0
-	|| SP_PARM == 0)
-	returnWin(0);
+	|| SP_PARM == NULL)
+	returnWin(NULL);
 
     if (num_lines == 0)
 	num_lines = SP_PARM->_lines_avail - begy;
@@ -160,14 +160,14 @@
 
     win = NCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_ARGx
 					num_lines, num_columns, begy, begx, 0);
-    if (win == 0)
-	returnWin(0);
+    if (win == NULL)
+	returnWin(NULL);
 
     for (i = 0; i < num_lines; i++) {
 	win->_line[i].text = typeCalloc(NCURSES_CH_T, (unsigned) num_columns);
-	if (win->_line[i].text == 0) {
+	if (win->_line[i].text == NULL) {
 	    (void) _nc_freewin(win);
-	    returnWin(0);
+	    returnWin(NULL);
 	}
 	for (ptr = win->_line[i].text;
 	     ptr < win->_line[i].text + num_columns;
@@ -207,11 +207,14 @@
     /*
      * make sure window fits inside the original one
      */
-    if (begy < 0 || begx < 0 || orig == 0 || num_lines < 0 || num_columns < 0)
-	returnWin(0);
-    if (begy + num_lines > orig->_maxy + 1
+    if (begy < 0
+	|| begx < 0
+	|| orig == NULL
+	|| num_lines < 0
+	|| num_columns < 0
+	|| begy + num_lines > orig->_maxy + 1
 	|| begx + num_columns > orig->_maxx + 1)
-	returnWin(0);
+	returnWin(NULL);
 
     if (num_lines == 0)
 	num_lines = orig->_maxy + 1 - begy;
@@ -225,8 +228,8 @@
     win = NCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_ARGx num_lines, num_columns,
 					orig->_begy + begy,
 					orig->_begx + begx, flags);
-    if (win == 0)
-	returnWin(0);
+    if (win == NULL)
+	returnWin(NULL);
 
     win->_pary = begy;
     win->_parx = begx;
@@ -244,10 +247,10 @@
 NCURSES_EXPORT(WINDOW *)
 subwin(WINDOW *w, int l, int c, int y, int x)
 {
-    WINDOW *result = 0;
+    WINDOW *result = NULL;
 
     T((T_CALLED("subwin(%p, %d, %d, %d, %d)"), (void *) w, l, c, y, x));
-    if (w != 0) {
+    if (w != NULL) {
 	T(("parent has begy = %ld, begx = %ld", (long) w->_begy, (long) w->_begx));
 
 	result = derwin(w, l, c, y - w->_begy, x - w->_begx);
@@ -271,20 +274,20 @@
     T((T_CALLED("_nc_makenew(%p,%d,%d,%d,%d)"),
        (void *) SP_PARM, num_lines, num_columns, begy, begx));
 
-    if (SP_PARM == 0)
-	returnWin(0);
+    if (SP_PARM == NULL)
+	returnWin(NULL);
 
     if (!OK_DIMENSION(num_lines) || !OK_DIMENSION(num_columns))
-	returnWin(0);
+	returnWin(NULL);
 
-    if ((wp = typeCalloc(WINDOWLIST, 1)) == 0)
-	returnWin(0);
+    if ((wp = typeCalloc(WINDOWLIST, 1)) == NULL)
+	returnWin(NULL);
 
     win = &(wp->win);
 
-    if ((win->_line = typeCalloc(struct ldat, ((unsigned) num_lines))) == 0) {
+    if ((win->_line = typeCalloc(struct ldat, ((unsigned) num_lines))) == NULL) {
 	free(wp);
-	returnWin(0);
+	returnWin(NULL);
     }
 
     _nc_nonsp_lock_global(curses);
@@ -315,7 +318,7 @@
     win->_sync = 0;
     win->_parx = -1;
     win->_pary = -1;
-    win->_parent = 0;
+    win->_parent = NULL;
 
     win->_regtop = 0;
     win->_regbottom = (NCURSES_SIZE_T) (num_lines - 1);
@@ -382,18 +385,18 @@
 NCURSES_EXPORT(WINDOW *)
 _nc_curscr_of(SCREEN *sp)
 {
-    return (sp == 0) ? NULL : CurScreen(sp);
+    return (sp == NULL) ? NULL : CurScreen(sp);
 }
 
 NCURSES_EXPORT(WINDOW *)
 _nc_newscr_of(SCREEN *sp)
 {
-    return (sp == 0) ? NULL : NewScreen(sp);
+    return (sp == NULL) ? NULL : NewScreen(sp);
 }
 
 NCURSES_EXPORT(WINDOW *)
 _nc_stdscr_of(SCREEN *sp)
 {
-    return (sp == 0) ? NULL : StdScreen(sp);
+    return (sp == NULL) ? NULL : StdScreen(sp);
 }
 #endif
Index: ncurses/base/lib_nl.c
Prereq:  1.14 
--- ncurses-6.5-20241130+/ncurses/base/lib_nl.c	2023-04-29 18:51:49.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_nl.c	2024-12-07 20:00:48.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2000,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -45,7 +45,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_nl.c,v 1.14 2023/04/29 18:51:49 tom Exp $")
+MODULE_ID("$Id: lib_nl.c,v 1.15 2024/12/07 20:00:48 tom Exp $")
 
 #ifdef __EMX__
 #include <io.h>
@@ -55,7 +55,7 @@
 NCURSES_SP_NAME(nl) (NCURSES_SP_DCL0)
 {
     T((T_CALLED("nl(%p)"), (void *) SP_PARM));
-    if (0 == SP_PARM)
+    if (NULL == SP_PARM)
 	returnCode(ERR);
     IsNl(SP_PARM) = TRUE;
 #ifdef __EMX__
@@ -77,7 +77,7 @@
 NCURSES_SP_NAME(nonl) (NCURSES_SP_DCL0)
 {
     T((T_CALLED("nonl(%p)"), (void *) SP_PARM));
-    if (0 == SP_PARM)
+    if (NULL == SP_PARM)
 	returnCode(ERR);
     IsNl(SP_PARM) = FALSE;
 #ifdef __EMX__
Index: ncurses/base/lib_overlay.c
Prereq:  1.34 
--- ncurses-6.5-20241130+/ncurses/base/lib_overlay.c	2023-09-16 16:39:07.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_overlay.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2013,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -41,7 +41,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_overlay.c,v 1.34 2023/09/16 16:39:07 tom Exp $")
+MODULE_ID("$Id: lib_overlay.c,v 1.35 2024/12/07 20:03:37 tom Exp $")
 
 static int
 overlap(const WINDOW *const src, WINDOW *const dst, int const flag)
@@ -50,7 +50,7 @@
 
     T((T_CALLED("overlap(%p,%p,%d)"), (const void *) src, (void *) dst, flag));
 
-    if (src != 0 && dst != 0) {
+    if (src != NULL && dst != NULL) {
 	int sx1, sy1, sx2, sy2;
 	int dx1, dy1, dx2, dy2;
 
@@ -146,8 +146,8 @@
        dminrow, dmincol,
        dmaxrow, dmaxcol, over));
 
-    if (src != 0
-	&& dst != 0
+    if (src != NULL
+	&& dst != NULL
 	&& dmaxrow >= dminrow
 	&& dmaxcol >= dmincol) {
 	attr_t bk;
Index: ncurses/base/lib_pad.c
Prereq:  1.51 
--- ncurses-6.5-20241130+/ncurses/base/lib_pad.c	2024-09-28 15:40:42.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_pad.c	2024-12-07 17:44:59.000000000 +0000
@@ -43,7 +43,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_pad.c,v 1.51 2024/09/28 15:40:42 tom Exp $")
+MODULE_ID("$Id: lib_pad.c,v 1.52 2024/12/07 17:44:59 tom Exp $")
 
 NCURSES_EXPORT(WINDOW *)
 NCURSES_SP_NAME(newpad) (NCURSES_SP_DCLx int l, int c)
@@ -55,17 +55,17 @@
     T((T_CALLED("newpad(%p,%d, %d)"), (void *) SP_PARM, l, c));
 
     if (l <= 0 || c <= 0)
-	returnWin(0);
+	returnWin(NULL);
 
     win = NCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_ARGx l, c, 0, 0, _ISPAD);
     if (win == NULL)
-	returnWin(0);
+	returnWin(NULL);
 
     for (i = 0; i < l; i++) {
 	if_USE_SCROLL_HINTS(win->_line[i].oldindex = _NEWINDEX);
-	if ((win->_line[i].text = typeCalloc(NCURSES_CH_T, ((size_t) c))) == 0) {
+	if ((win->_line[i].text = typeCalloc(NCURSES_CH_T, ((size_t) c))) == NULL) {
 	    (void) _nc_freewin(win);
-	    returnWin(0);
+	    returnWin(NULL);
 	}
 	for (ptr = win->_line[i].text; ptr < win->_line[i].text + c; ptr++)
 	    SetChar(*ptr, BLANK_TEXT, BLANK_ATTR);
@@ -92,7 +92,7 @@
     if (orig) {
 	if (!IS_PAD(orig)
 	    || ((win = derwin(orig, l, c, begy, begx)) == NULL))
-	    returnWin(0);
+	    returnWin(NULL);
     }
     returnWin(win);
 }
@@ -143,7 +143,7 @@
     T((T_CALLED("pnoutrefresh(%p, %d, %d, %d, %d, %d, %d)"),
        (void *) win, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol));
 
-    if (win == 0)
+    if (win == NULL)
 	returnCode(ERR);
 
     if (!IS_PAD(win))
@@ -331,7 +331,7 @@
 {
     T((T_CALLED("pechochar(%p, %s)"), (void *) pad, _tracechtype(ch)));
 
-    if (pad == 0)
+    if (pad == NULL)
 	returnCode(ERR);
 
     if (!IS_PAD(pad))
Index: ncurses/base/lib_printw.c
Prereq:  1.29 
--- ncurses-6.5-20241130+/ncurses/base/lib_printw.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_printw.c	2024-12-07 17:44:59.000000000 +0000
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_printw.c,v 1.29 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: lib_printw.c,v 1.30 2024/12/07 17:44:59 tom Exp $")
 
 NCURSES_EXPORT(int)
 printw(const char *fmt, ...)
@@ -142,7 +142,7 @@
     T((T_CALLED("vwprintw(%p,%s,va_list)"), (void *) win, _nc_visbuf(fmt)));
 
     buf = NCURSES_SP_NAME(_nc_printf_string) (NCURSES_SP_ARGx fmt, argp);
-    if (buf != 0) {
+    if (buf != NULL) {
 	code = waddstr(win, buf);
     }
     returnCode(code);
@@ -160,7 +160,7 @@
     T((T_CALLED("vw_printw(%p,%s,va_list)"), (void *) win, _nc_visbuf(fmt)));
 
     buf = NCURSES_SP_NAME(_nc_printf_string) (NCURSES_SP_ARGx fmt, argp);
-    if (buf != 0) {
+    if (buf != NULL) {
 	code = waddstr(win, buf);
     }
     returnCode(code);
Index: ncurses/base/lib_redrawln.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/ncurses/base/lib_redrawln.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_redrawln.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2009,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_redrawln.c,v 1.18 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_redrawln.c,v 1.19 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 wredrawln(WINDOW *win, int beg, int num)
@@ -52,7 +52,7 @@
 
     T((T_CALLED("wredrawln(%p,%d,%d)"), (void *) win, beg, num));
 
-    if (win == 0)
+    if (win == NULL)
 	returnCode(ERR);
 
     sp = _nc_screen_of(win);
Index: ncurses/base/lib_restart.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/ncurses/base/lib_restart.c	2023-04-29 19:01:25.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_restart.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2015 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -42,7 +42,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_restart.c,v 1.18 2023/04/29 19:01:25 tom Exp $")
+MODULE_ID("$Id: lib_restart.c,v 1.19 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(restartterm) (NCURSES_SP_DCLx
@@ -64,7 +64,7 @@
 
     if (TINFO_SETUP_TERM(&new_term, termp, filenum, errret, FALSE) != OK) {
 	result = ERR;
-    } else if (SP_PARM != 0) {
+    } else if (SP_PARM != NULL) {
 	TTY_FLAGS save_flags = SP_PARM->_tty_flags;
 
 #ifdef USE_TERM_DRIVER
Index: ncurses/base/lib_screen.c
Prereq:  1.109 
--- ncurses-6.5-20241130+/ncurses/base/lib_screen.c	2024-10-05 20:47:44.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_screen.c	2024-12-07 17:46:49.000000000 +0000
@@ -42,7 +42,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_screen.c,v 1.109 2024/10/05 20:47:44 tom Exp $")
+MODULE_ID("$Id: lib_screen.c,v 1.110 2024/12/07 17:46:49 tom Exp $")
 
 #define MAX_SIZE 0x3fff		/* 16k is big enough for a window or pad */
 
@@ -172,7 +172,7 @@
     char *result = malloc(limit);
     char *buffer;
 
-    if (result != 0) {
+    if (result != NULL) {
 	int ch = 0;
 	size_t used = 0;
 
@@ -182,9 +182,9 @@
 	    if (used + 2 >= limit) {
 		limit += 1024;
 		buffer = realloc(result, limit);
-		if (buffer == 0) {
+		if (buffer == NULL) {
 		    free(result);
-		    result = 0;
+		    result = NULL;
 		    break;
 		}
 		result = buffer;
@@ -201,7 +201,7 @@
 	    TR(TRACE_IEVENT, ("READ:%s", result));
 	} else if (used == 0) {
 	    free(result);
-	    result = 0;
+	    result = NULL;
 	}
     }
     return result;
@@ -306,7 +306,7 @@
 	    *target = 0;
 	    while (limit-- > 0) {
 		const char *find = strchr(digits, *source++);
-		int ch = (find != 0) ? (int) (find - digits) : -1;
+		int ch = (find != NULL) ? (int) (find - digits) : -1;
 		*target *= base;
 		if (ch >= 0 && ch < base) {
 		    *target += ch;
@@ -387,14 +387,14 @@
 	char *value;
 	char *txt = read_txt(fp);
 
-	if (txt == 0)
+	if (txt == NULL)
 	    break;
 	if (!strcmp(txt, "rows:")) {
 	    free(txt);
 	    code = OK;
 	    break;
 	}
-	if ((value = strchr(txt, '=')) == 0) {
+	if ((value = strchr(txt, '=')) == NULL) {
 	    free(txt);
 	    continue;
 	}
@@ -506,8 +506,8 @@
 
     T((T_CALLED("getwin(%p)"), (void *) filep));
 
-    if (filep == 0) {
-	returnWin(0);
+    if (filep == NULL) {
+	returnWin(NULL);
     }
 
     /*
@@ -515,7 +515,7 @@
      * screen-dump, or new-format.
      */
     if (read_block(&tmp, (size_t) 4, filep) < 0) {
-	returnWin(0);
+	returnWin(NULL);
     }
     /*
      * If this is a new-format file, and we do not support it, give up.
@@ -524,9 +524,9 @@
 #if NCURSES_EXT_PUTWIN
 	if (read_win(&tmp, filep) < 0)
 #endif
-	    returnWin(0);
+	    returnWin(NULL);
     } else if (read_block(((char *) &tmp) + 4, sizeof(WINDOW) - 4, filep) < 0) {
-	returnWin(0);
+	returnWin(NULL);
     } else {
 	old_format = TRUE;
     }
@@ -538,7 +538,7 @@
 	tmp._maxy > MAX_SIZE ||
 	tmp._maxx == 0 ||
 	tmp._maxx > MAX_SIZE) {
-	returnWin(0);
+	returnWin(NULL);
     }
 
     if (IS_PAD(&tmp)) {
@@ -556,7 +556,7 @@
      * fields, because the window hierarchy within which they
      * made sense is probably gone.
      */
-    if (nwin != 0) {
+    if (nwin != NULL) {
 	int n;
 	size_t linesize = sizeof(NCURSES_CH_T) * (size_t) (tmp._maxx + 1);
 
@@ -594,13 +594,13 @@
 	    for (n = 0; n <= nwin->_maxy; n++) {
 		if (read_block(nwin->_line[n].text, linesize, filep) < 0) {
 		    delwin(nwin);
-		    returnWin(0);
+		    returnWin(NULL);
 		}
 	    }
 	}
 #if NCURSES_EXT_PUTWIN
 	else {
-	    char *txt = 0;
+	    char *txt = NULL;
 	    bool success = TRUE;
 	    NCURSES_CH_T prior = blank;
 
@@ -609,7 +609,7 @@
 		long row;
 		char *next;
 
-		if ((txt = read_txt(filep)) == 0) {
+		if ((txt = read_txt(filep)) == NULL) {
 		    T(("...failed to read string for row %d", n + 1));
 		    success = FALSE;
 		    break;
@@ -628,13 +628,13 @@
 		    break;
 		}
 		free(txt);
-		txt = 0;
+		txt = NULL;
 	    }
 
 	    if (!success) {
 		free(txt);
 		delwin(nwin);
-		returnWin(0);
+		returnWin(NULL);
 	    }
 	}
 #endif
@@ -798,7 +798,7 @@
     T((T_CALLED("putwin(%p,%p)"), (void *) win, (void *) filep));
 
 #if NCURSES_EXT_PUTWIN
-    if (win != 0) {
+    if (win != NULL) {
 	const char *version = curses_version();
 	char buffer[1024];
 	NCURSES_CH_T last_cell;
@@ -966,14 +966,14 @@
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(scr_restore) (NCURSES_SP_DCLx const char *file)
 {
-    FILE *fp = 0;
+    FILE *fp = NULL;
     int code = ERR;
 
     T((T_CALLED("scr_restore(%p,%s)"), (void *) SP_PARM, _nc_visbuf(file)));
 
     if (SP_PARM != NULL
 	&& _nc_access(file, R_OK) >= 0
-	&& (fp = safe_fopen(file, BIN_R)) != 0) {
+	&& (fp = safe_fopen(file, BIN_R)) != NULL) {
 	WINDOW *my_newscr = replace_window(NewScreen(SP_PARM), fp);
 	(void) fclose(fp);
 	if (my_newscr != NULL) {
@@ -1000,12 +1000,12 @@
 scr_dump(const char *file)
 {
     int result;
-    FILE *fp = 0;
+    FILE *fp = NULL;
 
     T((T_CALLED("scr_dump(%s)"), _nc_visbuf(file)));
 
     if (_nc_access(file, W_OK) < 0
-	|| (fp = safe_fopen(file, BIN_W)) == 0) {
+	|| (fp = safe_fopen(file, BIN_W)) == NULL) {
 	result = ERR;
     } else {
 	(void) putwin(newscr, fp);
@@ -1029,10 +1029,10 @@
 	!(exit_ca_mode && non_rev_rmcup)
 #endif
 	) {
-	FILE *fp = 0;
+	FILE *fp = NULL;
 
 	if (_nc_access(file, R_OK) >= 0
-	    && (fp = safe_fopen(file, BIN_R)) != 0) {
+	    && (fp = safe_fopen(file, BIN_R)) != NULL) {
 	    WINDOW *my_curscr = replace_window(CurScreen(SP_PARM), fp);
 	    (void) fclose(fp);
 	    if (my_curscr != NULL) {
@@ -1070,7 +1070,7 @@
 #if !USE_REENTRANT
 	newscr = NewScreen(SP_PARM);
 #endif
-	if (NewScreen(SP_PARM) != 0) {
+	if (NewScreen(SP_PARM) != NULL) {
 	    code = OK;
 	}
     }
Index: ncurses/base/lib_set_term.c
Prereq:  1.189 
--- ncurses-6.5-20241130+/ncurses/base/lib_set_term.c	2024-11-23 18:33:50.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_set_term.c	2024-12-07 17:58:16.000000000 +0000
@@ -57,7 +57,7 @@
 #undef CUR
 #define CUR SP_TERMTYPE
 
-MODULE_ID("$Id: lib_set_term.c,v 1.189 2024/11/23 18:33:50 tom Exp $")
+MODULE_ID("$Id: lib_set_term.c,v 1.190 2024/12/07 17:58:16 tom Exp $")
 
 #ifdef USE_TERM_DRIVER
 #define MaxColors      InfoOf(sp).maxcolors
@@ -81,7 +81,7 @@
     _nc_set_screen(screenp);
     newSP = screenp;
 
-    if (newSP != 0) {
+    if (newSP != NULL) {
 	TINFO_SET_CURTERM(newSP, newSP->_term);
 #if !USE_REENTRANT
 	curscr = CurScreen(newSP);
@@ -91,11 +91,11 @@
 	COLOR_PAIRS = newSP->_pair_count;
 #endif
     } else {
-	TINFO_SET_CURTERM(oldSP, 0);
+	TINFO_SET_CURTERM(oldSP, NULL);
 #if !USE_REENTRANT
-	curscr = 0;
-	newscr = 0;
-	stdscr = 0;
+	curscr = NULL;
+	newscr = NULL;
+	stdscr = NULL;
 	COLORS = 0;
 	COLOR_PAIRS = 0;
 #endif
@@ -110,7 +110,7 @@
 static void
 _nc_free_keytry(TRIES * kt)
 {
-    if (kt != 0) {
+    if (kt != NULL) {
 	_nc_free_keytry(kt->child);
 	_nc_free_keytry(kt->sibling);
 	free(kt);
@@ -120,7 +120,7 @@
 static bool
 delink_screen(SCREEN *sp)
 {
-    SCREEN *last = 0;
+    SCREEN *last = NULL;
     SCREEN *temp;
     bool result = FALSE;
 
@@ -174,9 +174,9 @@
 	    }
 	}
 
-	if (sp->_slk != 0) {
+	if (sp->_slk != NULL) {
 
-	    if (sp->_slk->ent != 0) {
+	    if (sp->_slk->ent != NULL) {
 		int i;
 
 		for (i = 0; i < sp->_slk->labcnt; ++i) {
@@ -186,14 +186,14 @@
 		free(sp->_slk->ent);
 	    }
 	    free(sp->_slk);
-	    sp->_slk = 0;
+	    sp->_slk = NULL;
 	}
 
 	_nc_free_keytry(sp->_keytry);
-	sp->_keytry = 0;
+	sp->_keytry = NULL;
 
 	_nc_free_keytry(sp->_key_ok);
-	sp->_key_ok = 0;
+	sp->_key_ok = NULL;
 
 	FreeIfNeeded(sp->_current_attr);
 
@@ -232,17 +232,17 @@
 	 */
 	if (is_current) {
 #if !USE_REENTRANT
-	    curscr = 0;
-	    newscr = 0;
-	    stdscr = 0;
+	    curscr = NULL;
+	    newscr = NULL;
+	    stdscr = NULL;
 	    COLORS = 0;
 	    COLOR_PAIRS = 0;
 #endif
-	    _nc_set_screen(0);
+	    _nc_set_screen(NULL);
 #if USE_WIDEC_SUPPORT
-	    if (SP == 0) {
+	    if (SP == NULL) {
 		FreeIfNeeded(_nc_wacs);
-		_nc_wacs = 0;
+		_nc_wacs = NULL;
 	    }
 #endif
 	} else {
@@ -303,7 +303,7 @@
 }
 #endif
 
-#define ReturnScreenError() do { _nc_set_screen(0); \
+#define ReturnScreenError() do { _nc_set_screen(NULL); \
                             returnCode(ERR); } while (0)
 
 /* OS-independent screen initializations */
@@ -357,7 +357,7 @@
     sp->_next_screen = _nc_screen_chain;
     _nc_screen_chain = sp;
 
-    if ((sp->_current_attr = typeCalloc(NCURSES_CH_T, 1)) == 0) {
+    if ((sp->_current_attr = typeCalloc(NCURSES_CH_T, 1)) == NULL) {
 	ReturnScreenError();
     }
 #else
@@ -437,7 +437,7 @@
 	_setmode(fileno(output), _O_BINARY);
 #endif
     sp->out_limit = (size_t) ((2 + slines) * (6 + scolumns));
-    if ((sp->out_buffer = malloc(sp->out_limit)) == 0)
+    if ((sp->out_buffer = malloc(sp->out_limit)) == NULL)
 	sp->out_limit = 0;
     sp->out_inuse = 0;
 
@@ -479,7 +479,7 @@
      * Allow those assumed/default color assumptions to be overridden at
      * runtime:
      */
-    if ((env = getenv("NCURSES_ASSUMED_COLORS")) != 0) {
+    if ((env = getenv("NCURSES_ASSUMED_COLORS")) != NULL) {
 	int fg, bg;
 	char sep1, sep2;
 	int count = sscanf(env, "%d%c%d%c", &fg, &sep1, &bg, &sep2);
@@ -555,7 +555,7 @@
      * in the environment, reset the support-flag.
      */
     if (magic_cookie_glitch >= 0) {
-	if (getenv("NCURSES_NO_MAGIC_COOKIE") != 0) {
+	if (getenv("NCURSES_NO_MAGIC_COOKIE") != NULL) {
 	    support_cookies = FALSE;
 	}
     }
@@ -633,10 +633,10 @@
     NCURSES_SP_NAME(_nc_init_acs) (NCURSES_SP_ARG);
 #if USE_WIDEC_SUPPORT
     sp->_screen_unicode = _nc_unicode_locale();
-    if (_nc_wacs == 0) {
+    if (_nc_wacs == NULL) {
 	_nc_init_wacs();
     }
-    if (_nc_wacs == 0) {
+    if (_nc_wacs == NULL) {
 	ReturnScreenError();
     }
 
@@ -644,7 +644,7 @@
 			   && _nc_locale_breaks_acs(sp->_term));
 #endif
     env = _nc_get_locale();
-    sp->_legacy_coding = ((env == 0)
+    sp->_legacy_coding = ((env == NULL)
 			  || !strcmp(env, "C")
 			  || !strcmp(env, "POSIX"));
     T(("legacy-coding %d", sp->_legacy_coding));
@@ -652,19 +652,19 @@
     sp->_nc_sp_idcok = TRUE;
     sp->_nc_sp_idlok = FALSE;
 
-    sp->oldhash = 0;
-    sp->newhash = 0;
+    sp->oldhash = NULL;
+    sp->newhash = NULL;
 
     T(("creating newscr"));
     NewScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,
 					     0, 0);
-    if (NewScreen(sp) == 0) {
+    if (NewScreen(sp) == NULL) {
 	ReturnScreenError();
     }
     T(("creating curscr"));
     CurScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,
 					     0, 0);
-    if (CurScreen(sp) == 0) {
+    if (CurScreen(sp) == NULL) {
 	ReturnScreenError();
     }
 #if !USE_REENTRANT
@@ -684,7 +684,7 @@
      * unless we use the term-driver.
      */
 #ifndef USE_TERM_DRIVER
-    if (cur_term != 0 &&
+    if (cur_term != NULL &&
 	!memcmp(&cur_term->Ottyb, &null_TTY, sizeof(TTY)))
 #endif
     {
@@ -750,7 +750,7 @@
     assert((sp->_lines_avail + sp->_topstolen + bottom_stolen) == slines);
     if ((StdScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx
 						  sp->_lines_avail,
-						  scolumns, 0, 0)) == 0) {
+						  scolumns, 0, 0)) == NULL) {
 	ReturnScreenError();
     }
     SET_LINES(sp->_lines_avail);
@@ -769,7 +769,7 @@
 		bool filtered,
 		int slk_format)
 {
-    SCREEN *sp = 0;
+    SCREEN *sp = NULL;
     int rc = NCURSES_SP_NAME(_nc_setupscreen) (&sp,
 					       slines,
 					       scolumns,
@@ -777,7 +777,7 @@
 					       filtered,
 					       slk_format);
     if (rc != OK)
-	_nc_set_screen(0);
+	_nc_set_screen(NULL);
     return rc;
 }
 #endif
@@ -800,13 +800,13 @@
        TR_FUNC_ARG(0, init)));
 
 #if NCURSES_SP_FUNCS
-    if (SP_PARM != 0 && SP_PARM->_prescreen)
+    if (SP_PARM != NULL && SP_PARM->_prescreen)
 #endif
     {
 	if (line == 0) {
 	    code = OK;
 	} else {
-	    if (safe_ripoff_sp == 0) {
+	    if (safe_ripoff_sp == NULL) {
 		safe_ripoff_sp = safe_ripoff_stack;
 	    }
 	    if (safe_ripoff_sp < safe_ripoff_stack + N_RIPS) {
Index: ncurses/base/lib_slk.c
Prereq:  1.50 
--- ncurses-6.5-20241130+/ncurses/base/lib_slk.c	2022-08-20 18:29:22.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slk.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2022 Thomas E. Dickey                                     *
+ * Copyright 2020-2022,2024 Thomas E. Dickey                                *
  * Copyright 1998-2010,2011 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -48,7 +48,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_slk.c,v 1.50 2022/08/20 18:29:22 tom Exp $")
+MODULE_ID("$Id: lib_slk.c,v 1.51 2024/12/07 20:03:37 tom Exp $")
 
 #ifdef USE_TERM_DRIVER
 #define NumLabels    InfoOf(SP_PARM).numlabels
@@ -68,7 +68,7 @@
 static int
 slk_failed(NCURSES_SP_DCL0)
 {
-    if ((0 != SP_PARM) && SP_PARM->_slk) {
+    if ((NULL != SP_PARM) && SP_PARM->_slk) {
 	FreeIfNeeded(SP_PARM->_slk->ent);
 	free(SP_PARM->_slk);
 	SP_PARM->_slk = (SLK *) 0;
@@ -148,7 +148,7 @@
     assert(stwin);
 
     sp = _nc_screen_of(stwin);
-    if (0 == sp)
+    if (NULL == sp)
 	returnCode(ERR);
 
     assert(TerminalOf(SP_PARM));
@@ -157,7 +157,7 @@
 
     if (SP_PARM->_slk) {	/* we did this already, so simply return */
 	returnCode(OK);
-    } else if ((SP_PARM->_slk = typeCalloc(SLK, 1)) == 0)
+    } else if ((SP_PARM->_slk = typeCalloc(SLK, 1)) == NULL)
 	returnCode(ERR);
 
     if (!SP_PARM->slk_format)
@@ -196,13 +196,13 @@
     for (i = 0; i < SP_PARM->_slk->labcnt; i++) {
 	size_t used = max_length + 1;
 
-	SP_PARM->_slk->ent[i].ent_text = (char *) _nc_doalloc(0, used);
-	if (SP_PARM->_slk->ent[i].ent_text == 0)
+	SP_PARM->_slk->ent[i].ent_text = (char *) _nc_doalloc(NULL, used);
+	if (SP_PARM->_slk->ent[i].ent_text == NULL)
 	    returnCode(slk_failed(NCURSES_SP_ARG));
 	memset(SP_PARM->_slk->ent[i].ent_text, 0, used);
 
-	SP_PARM->_slk->ent[i].form_text = (char *) _nc_doalloc(0, used);
-	if (SP_PARM->_slk->ent[i].form_text == 0)
+	SP_PARM->_slk->ent[i].form_text = (char *) _nc_doalloc(NULL, used);
+	if (SP_PARM->_slk->ent[i].form_text == NULL)
 	    returnCode(slk_failed(NCURSES_SP_ARG));
 
 	if (used > 1) {
@@ -235,7 +235,7 @@
 {
     T((T_CALLED("slk_restore(%p)"), (void *) SP_PARM));
 
-    if (0 == SP_PARM)
+    if (NULL == SP_PARM)
 	returnCode(ERR);
     if (SP_PARM->_slk == NULL)
 	returnCode(ERR);
Index: ncurses/base/lib_slkatr_set.c
Prereq:  1.17 
--- ncurses-6.5-20241130+/ncurses/base/lib_slkatr_set.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slkatr_set.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -39,7 +39,7 @@
  */
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_slkatr_set.c,v 1.17 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slkatr_set.c,v 1.18 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(slk_attr_set) (NCURSES_SP_DCLx
@@ -56,8 +56,8 @@
        color_pair));
 
     set_extended_pair(opts, color_pair);
-    if (SP_PARM != 0
-	&& SP_PARM->_slk != 0
+    if (SP_PARM != NULL
+	&& SP_PARM->_slk != NULL
 	&& color_pair >= 0
 	&& color_pair < SP_PARM->_pair_limit) {
 	TR(TRACE_ATTRS, ("... current %s", _tracech_t(CHREF(SP_PARM->_slk->attr))));
Index: ncurses/base/lib_slkatrof.c
Prereq:  1.12 
--- ncurses-6.5-20241130+/ncurses/base/lib_slkatrof.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slkatrof.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2005,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -39,14 +39,14 @@
  */
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_slkatrof.c,v 1.12 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slkatrof.c,v 1.13 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(slk_attroff) (NCURSES_SP_DCLx const chtype attr)
 {
     T((T_CALLED("slk_attroff(%p,%s)"), (void *) SP_PARM, _traceattr(attr)));
 
-    if (SP_PARM != 0 && SP_PARM->_slk != 0) {
+    if (SP_PARM != NULL && SP_PARM->_slk != NULL) {
 	TR(TRACE_ATTRS, ("... current %s", _tracech_t(CHREF(SP_PARM->_slk->attr))));
 	RemAttr(SP_PARM->_slk->attr, attr);
 	if ((attr & A_COLOR) != 0) {
Index: ncurses/base/lib_slkatron.c
Prereq:  1.13 
--- ncurses-6.5-20241130+/ncurses/base/lib_slkatron.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slkatron.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2009,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -39,14 +39,14 @@
  */
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_slkatron.c,v 1.13 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slkatron.c,v 1.14 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(slk_attron) (NCURSES_SP_DCLx const chtype attr)
 {
     T((T_CALLED("slk_attron(%p,%s)"), (void *) SP_PARM, _traceattr(attr)));
 
-    if (SP_PARM != 0 && SP_PARM->_slk != 0) {
+    if (SP_PARM != NULL && SP_PARM->_slk != NULL) {
 	TR(TRACE_ATTRS, ("... current %s", _tracech_t(CHREF(SP_PARM->_slk->attr))));
 	AddAttr(SP_PARM->_slk->attr, attr);
 	if ((attr & A_COLOR) != 0) {
Index: ncurses/base/lib_slkatrset.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/ncurses/base/lib_slkatrset.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slkatrset.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2005,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -39,14 +39,14 @@
  */
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_slkatrset.c,v 1.11 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slkatrset.c,v 1.12 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(slk_attrset) (NCURSES_SP_DCLx const chtype attr)
 {
     T((T_CALLED("slk_attrset(%p,%s)"), (void *) SP_PARM, _traceattr(attr)));
 
-    if (SP_PARM != 0 && SP_PARM->_slk != 0) {
+    if (SP_PARM != NULL && SP_PARM->_slk != NULL) {
 	SetAttr(SP_PARM->_slk->attr, attr);
 	returnCode(OK);
     } else
Index: ncurses/base/lib_slkattr.c
Prereq:  1.12 
--- ncurses-6.5-20241130+/ncurses/base/lib_slkattr.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slkattr.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2009,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -39,14 +39,14 @@
  */
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_slkattr.c,v 1.12 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slkattr.c,v 1.13 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(attr_t)
 NCURSES_SP_NAME(slk_attr) (NCURSES_SP_DCL0)
 {
     T((T_CALLED("slk_attr(%p)"), (void *) SP_PARM));
 
-    if (SP_PARM != 0 && SP_PARM->_slk != 0) {
+    if (SP_PARM != NULL && SP_PARM->_slk != NULL) {
 	attr_t result = AttrOf(SP_PARM->_slk->attr) & ALL_BUT_COLOR;
 	int pair = GetPair(SP_PARM->_slk->attr);
 
Index: ncurses/base/lib_slkclear.c
Prereq:  1.15 
--- ncurses-6.5-20241130+/ncurses/base/lib_slkclear.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slkclear.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2007,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -41,7 +41,7 @@
  */
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_slkclear.c,v 1.15 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slkclear.c,v 1.16 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(slk_clear) (NCURSES_SP_DCL0)
@@ -50,7 +50,7 @@
 
     T((T_CALLED("slk_clear(%p)"), (void *) SP_PARM));
 
-    if (SP_PARM != 0 && SP_PARM->_slk != 0) {
+    if (SP_PARM != NULL && SP_PARM->_slk != NULL) {
 	SP_PARM->_slk->hidden = TRUE;
 	/* For simulated SLK's it looks much more natural to
 	   inherit those attributes from the standard screen */
Index: ncurses/base/lib_slkcolor.c
Prereq:  1.20 
--- ncurses-6.5-20241130+/ncurses/base/lib_slkcolor.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slkcolor.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018,2020 Thomas E. Dickey                                     *
+ * Copyright 2018-2020,2024 Thomas E. Dickey                                *
  * Copyright 1998-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -39,7 +39,7 @@
  */
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_slkcolor.c,v 1.20 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slkcolor.c,v 1.21 2024/12/07 20:03:37 tom Exp $")
 
 static int
 _nc_slk_color(SCREEN *sp, int pair_arg)
@@ -48,8 +48,8 @@
 
     T((T_CALLED("slk_color(%p,%d)"), (void *) sp, pair_arg));
 
-    if (sp != 0
-	&& sp->_slk != 0
+    if (sp != NULL
+	&& sp->_slk != NULL
 	&& pair_arg >= 0
 	&& pair_arg < sp->_pair_limit) {
 	TR(TRACE_ATTRS, ("... current is %s", _tracech_t(CHREF(sp->_slk->attr))));
Index: ncurses/base/lib_slklab.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/ncurses/base/lib_slklab.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slklab.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2003,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -41,15 +41,15 @@
  */
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_slklab.c,v 1.11 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slklab.c,v 1.12 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(char *)
 NCURSES_SP_NAME(slk_label) (NCURSES_SP_DCLx int n)
 {
     T((T_CALLED("slk_label(%p,%d)"), (void *) SP_PARM, n));
 
-    if (SP_PARM == 0 || SP_PARM->_slk == 0 || n < 1 || n > SP_PARM->_slk->labcnt)
-	returnPtr(0);
+    if (SP_PARM == NULL || SP_PARM->_slk == NULL || n < 1 || n > SP_PARM->_slk->labcnt)
+	returnPtr(NULL);
     returnPtr(SP_PARM->_slk->ent[n - 1].ent_text);
 }
 
Index: ncurses/base/lib_slkrefr.c
Prereq:  1.33 
--- ncurses-6.5-20241130+/ncurses/base/lib_slkrefr.c	2024-07-27 19:23:59.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slkrefr.c	2024-12-07 17:58:16.000000000 +0000
@@ -44,7 +44,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_slkrefr.c,v 1.33 2024/07/27 19:23:59 tom Exp $")
+MODULE_ID("$Id: lib_slkrefr.c,v 1.34 2024/12/07 17:58:16 tom Exp $")
 
 #ifdef USE_TERM_DRIVER
 #define NumLabels    InfoOf(SP_PARM).numlabels
@@ -83,7 +83,7 @@
     SLK *slk;
     int numlab;
 
-    if (sp == 0)
+    if (sp == NULL)
 	return;
 
     slk = sp->_slk;
@@ -145,7 +145,7 @@
 {
     T((T_CALLED("slk_noutrefresh(%p)"), (void *) SP_PARM));
 
-    if (SP_PARM == 0 || SP_PARM->_slk == 0)
+    if (SP_PARM == NULL || SP_PARM->_slk == NULL)
 	returnCode(ERR);
     if (SP_PARM->_slk->hidden)
 	returnCode(OK);
@@ -170,7 +170,7 @@
 {
     T((T_CALLED("slk_refresh(%p)"), (void *) SP_PARM));
 
-    if (SP_PARM == 0 || SP_PARM->_slk == 0)
+    if (SP_PARM == NULL || SP_PARM->_slk == NULL)
 	returnCode(ERR);
     if (SP_PARM->_slk->hidden)
 	returnCode(OK);
Index: ncurses/base/lib_slkset.c
Prereq:  1.26 
--- ncurses-6.5-20241130+/ncurses/base/lib_slkset.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slkset.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019,2020 Thomas E. Dickey                                     *
+ * Copyright 2019-2020,2024 Thomas E. Dickey                                *
  * Copyright 1998-2011,2012 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -45,7 +45,7 @@
 #endif
 #endif
 
-MODULE_ID("$Id: lib_slkset.c,v 1.26 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slkset.c,v 1.27 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(slk_set) (NCURSES_SP_DCLx int i, const char *astr, int format)
@@ -60,14 +60,14 @@
 
     T((T_CALLED("slk_set(%p, %d, \"%s\", %d)"), (void *) SP_PARM, i, str, format));
 
-    if (SP_PARM == 0
-	|| (slk = SP_PARM->_slk) == 0
+    if (SP_PARM == NULL
+	|| (slk = SP_PARM->_slk) == NULL
 	|| i < 1
 	|| i > slk->labcnt
 	|| format < 0
 	|| format > 2)
 	returnCode(ERR);
-    if (str == 0)
+    if (str == NULL)
 	str = "";
     --i;			/* Adjust numbering of labels */
 
@@ -84,7 +84,7 @@
 	size_t need;
 
 	init_mb(state);
-	need = mbrtowc(0, p, strlen(p), &state);
+	need = mbrtowc(NULL, p, strlen(p), &state);
 	if (need == (size_t) -1)
 	    break;
 	mbrtowc(&wc, p, need, &state);
@@ -107,14 +107,14 @@
 #endif
 
     FreeIfNeeded(slk->ent[i].ent_text);
-    if ((slk->ent[i].ent_text = strdup(str)) == 0)
+    if ((slk->ent[i].ent_text = strdup(str)) == NULL)
 	returnCode(ERR);
     slk->ent[i].ent_text[numchrs] = '\0';
 
     if ((slk->ent[i].form_text = (char *) _nc_doalloc(slk->ent[i].form_text,
 						      (size_t) (limit +
 								numchrs + 1))
-	) == 0)
+	) == NULL)
 	returnCode(ERR);
 
     switch (format) {
Index: ncurses/base/lib_slktouch.c
Prereq:  1.9 
--- ncurses-6.5-20241130+/ncurses/base/lib_slktouch.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_slktouch.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2000,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -39,14 +39,14 @@
  */
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_slktouch.c,v 1.9 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slktouch.c,v 1.10 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(slk_touch) (NCURSES_SP_DCL0)
 {
     T((T_CALLED("slk_touch(%p)"), (void *) SP_PARM));
 
-    if (SP_PARM == 0 || SP_PARM->_slk == 0)
+    if (SP_PARM == NULL || SP_PARM->_slk == NULL)
 	returnCode(ERR);
     SP_PARM->_slk->dirty = TRUE;
 
Index: ncurses/base/lib_ungetch.c
Prereq:  1.17 
--- ncurses-6.5-20241130+/ncurses/base/lib_ungetch.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_ungetch.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2011,2012 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -43,7 +43,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_ungetch.c,v 1.17 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_ungetch.c,v 1.18 2024/12/07 20:03:37 tom Exp $")
 
 #include <fifo_defs.h>
 
@@ -65,7 +65,7 @@
 
     T((T_CALLED("ungetch(%p,%s)"), (void *) sp, _nc_tracechar(sp, ch)));
 
-    if (sp != 0 && tail >= 0) {
+    if (sp != NULL && tail >= 0) {
 	if (head < 0) {
 	    head = 0;
 	    t_inc();
Index: ncurses/base/lib_wattron.c
Prereq:  1.13 
--- ncurses-6.5-20241130+/ncurses/base/lib_wattron.c	2022-04-15 22:34:38.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_wattron.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2022 Thomas E. Dickey                                     *
+ * Copyright 2020-2022,2024 Thomas E. Dickey                                *
  * Copyright 1998-2009,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -43,13 +43,13 @@
 #include <curses.priv.h>
 #include <ctype.h>
 
-MODULE_ID("$Id: lib_wattron.c,v 1.13 2022/04/15 22:34:38 tom Exp $")
+MODULE_ID("$Id: lib_wattron.c,v 1.14 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(int)
 wattr_on(WINDOW *win, attr_t at, void *opts GCC_UNUSED)
 {
     T((T_CALLED("wattr_on(%p,%s)"), (void *) win, _traceattr(at)));
-    if (win != 0) {
+    if (win != NULL) {
 	T(("... current %s (%d)",
 	   _traceattr(WINDOW_ATTRS(win)),
 	   GET_WINDOW_PAIR(win)));
Index: ncurses/base/lib_winch.c
Prereq:  1.9 
--- ncurses-6.5-20241130+/ncurses/base/lib_winch.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_winch.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2009,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,13 +40,13 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_winch.c,v 1.9 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_winch.c,v 1.10 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(chtype)
 winch(WINDOW *win)
 {
     T((T_CALLED("winch(%p)"), (void *) win));
-    if (win != 0) {
+    if (win != NULL) {
 	returnChtype((chtype) CharOf(win->_line[win->_cury].text[win->_curx])
 		     | AttrOf(win->_line[win->_cury].text[win->_curx]));
     } else {
Index: ncurses/base/lib_window.c
Prereq:  1.32 
--- ncurses-6.5-20241130+/ncurses/base/lib_window.c	2021-10-23 23:06:24.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/lib_window.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2010,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_window.c,v 1.32 2021/10/23 23:06:24 tom Exp $")
+MODULE_ID("$Id: lib_window.c,v 1.33 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(void)
 _nc_synchook(WINDOW *win)
@@ -61,8 +61,8 @@
 
     T((T_CALLED("mvderwin(%p,%d,%d)"), (void *) win, y, x));
 
-    if (win != 0
-	&& (orig = win->_parent) != 0
+    if (win != NULL
+	&& (orig = win->_parent) != NULL
 	&& (x >= 0 && y >= 0)
 	&& (x + getmaxx(win) <= getmaxx(orig))
 	&& (y + getmaxy(win) <= getmaxy(orig))) {
@@ -178,11 +178,11 @@
 dupwin(WINDOW *win)
 /* make an exact duplicate of the given window */
 {
-    WINDOW *nwin = 0;
+    WINDOW *nwin = NULL;
 
     T((T_CALLED("dupwin(%p)"), (void *) win));
 
-    if (win != 0) {
+    if (win != NULL) {
 #if NCURSES_SP_FUNCS
 	SCREEN *sp = _nc_screen_of(win);
 #endif
@@ -199,7 +199,7 @@
 					    win->_begx);
 	}
 
-	if (nwin != 0) {
+	if (nwin != NULL) {
 	    int i;
 	    size_t linesize;
 
Index: ncurses/base/nc_panel.c
Prereq:  1.6 
--- ncurses-6.5-20241130+/ncurses/base/nc_panel.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/nc_panel.c	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2000,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -33,7 +33,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: nc_panel.c,v 1.6 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: nc_panel.c,v 1.7 2024/12/07 20:03:37 tom Exp $")
 
 NCURSES_EXPORT(struct panelhook *)
 NCURSES_SP_NAME(_nc_panelhook) (NCURSES_SP_DCL0)
@@ -42,7 +42,7 @@
 	    ? &(SP_PARM->_panelHook)
 	    : (CURRENT_SCREEN
 	       ? &(CURRENT_SCREEN->_panelHook)
-	       : 0));
+	       : NULL));
 }
 
 #if NCURSES_SP_FUNCS
Index: ncurses/base/new_pair.c
Prereq:  1.25 
--- ncurses-6.5-20241130+/ncurses/base/new_pair.c	2024-10-05 20:51:29.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/new_pair.c	2024-12-07 18:05:04.000000000 +0000
@@ -61,7 +61,7 @@
 
 #endif
 
-MODULE_ID("$Id: new_pair.c,v 1.25 2024/10/05 20:51:29 tom Exp $")
+MODULE_ID("$Id: new_pair.c,v 1.26 2024/12/07 18:05:04 tom Exp $")
 
 #if NCURSES_EXT_COLORS
 
@@ -148,9 +148,9 @@
 
     find.fg = fg;
     find.bg = bg;
-    if (sp != 0) {
+    if (sp != NULL) {
 	void *pp;
-	if ((pp = tfind(&find, &sp->_ordered_pairs, compare_data)) != 0) {
+	if ((pp = tfind(&find, &sp->_ordered_pairs, compare_data)) != NULL) {
 	    const colorpair_t *temp = *(colorpair_t **) pp;
 	    result = (int) (temp - sp->_color_pairs);
 	}
@@ -253,7 +253,7 @@
     int n;
     for (n = 0; n < length; ++n) {
 	const void *find = tfind(source + n, &sp->_ordered_pairs, compare_data);
-	if (find != 0) {
+	if (find != NULL) {
 	    tdelete(source + n, &sp->_ordered_pairs, compare_data);
 	    tsearch(target + n, &sp->_ordered_pairs, compare_data);
 	}
@@ -266,7 +266,7 @@
     int pair;
 
     T((T_CALLED("alloc_pair(%d,%d)"), fg, bg));
-    if (SP_PARM == 0) {
+    if (SP_PARM == NULL) {
 	pair = -1;
     } else if ((pair = _nc_find_color_pair(SP_PARM, fg, bg)) < 0) {
 	/*
@@ -291,7 +291,7 @@
 	    if (!found && (SP_PARM->_pair_alloc < SP_PARM->_pair_limit)) {
 		pair = SP_PARM->_pair_alloc;
 		ReservePairs(SP_PARM, pair);
-		if (SP_PARM->_color_pairs == 0) {
+		if (SP_PARM->_color_pairs == NULL) {
 		    pair = -1;
 		} else {
 		    found = TRUE;
Index: ncurses/base/resizeterm.c
Prereq:  1.57 
--- ncurses-6.5-20241130+/ncurses/base/resizeterm.c	2024-11-23 18:35:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/resizeterm.c	2024-12-07 18:05:04.000000000 +0000
@@ -46,7 +46,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: resizeterm.c,v 1.57 2024/11/23 18:35:34 tom Exp $")
+MODULE_ID("$Id: resizeterm.c,v 1.58 2024/12/07 18:05:04 tom Exp $")
 
 /*
  * If we're trying to be reentrant, do not want any local statics.
@@ -123,10 +123,10 @@
 static ripoff_t *
 ripped_window(WINDOW *win)
 {
-    ripoff_t *result = 0;
+    ripoff_t *result = NULL;
     ripoff_t *rop;
 
-    if (win != 0) {
+    if (win != NULL) {
 #ifdef USE_SP_RIPOFF
 	SCREEN *sp = _nc_screen_of(win);
 #endif
@@ -149,7 +149,7 @@
 {
     int result = 0;
 
-    if (win != 0) {
+    if (win != NULL) {
 	ripoff_t *rop;
 
 #ifdef USE_SP_RIPOFF
@@ -175,7 +175,7 @@
 {
     int depth = 0;
 
-    if (cmp != 0) {
+    if (cmp != NULL) {
 #ifdef USE_SP_WINDOWLIST
 	SCREEN *sp = _nc_screen_of(cmp);
 #endif
@@ -200,9 +200,9 @@
 {
     int depth = 0;
 
-    if (cmp != 0) {
+    if (cmp != NULL) {
 	WINDOW *tst;
-	while ((tst = cmp->_parent) != 0) {
+	while ((tst = cmp->_parent) != NULL) {
 	    ++depth;
 	    cmp = tst;
 	}
@@ -224,13 +224,13 @@
 
     T((T_CALLED("adjust_window(%p,%d,%d)%s depth %d/%d currently %ldx%ld at %ld,%ld"),
        (void *) win, ToLines, ToCols,
-       (rop != 0) ? " (rip)" : "",
+       (rop != NULL) ? " (rip)" : "",
        parent_depth(win),
        child_depth(win),
        (long) getmaxy(win), (long) getmaxx(win),
        (long) getbegy(win) + win->_yoffset, (long) getbegx(win)));
 
-    if (rop != 0 && rop->line < 0) {
+    if (rop != NULL && rop->line < 0) {
 	/*
 	 * If it is a ripped-off window at the bottom of the screen, simply
 	 * move it to the same relative position.
@@ -484,8 +484,8 @@
 	if (NCURSES_SP_NAME(is_term_resized) (NCURSES_SP_ARGx ToLines, ToCols)) {
 #if USE_SIGWINCH
 	    ripoff_t *rop;
-	    bool slk_visible = (SP_PARM != 0
-				&& SP_PARM->_slk != 0
+	    bool slk_visible = (SP_PARM != NULL
+				&& SP_PARM->_slk != NULL
 				&& !(SP_PARM->_slk->hidden));
 
 	    if (slk_visible) {
@@ -506,7 +506,7 @@
 	     */
 	    for (each_ripoff(rop)) {
 		if (rop->win != StdScreen(SP_PARM)
-		    && rop->win != 0
+		    && rop->win != NULL
 		    && rop->line < 0) {
 
 		    if (rop->hook != _nc_slk_initialize) {
Index: ncurses/base/tries.c
Prereq:  1.32 
--- ncurses-6.5-20241130+/ncurses/base/tries.c	2023-06-24 15:36:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/tries.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2009,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -41,7 +41,7 @@
 #include <curses.priv.h>
 #include <tic.h>
 
-MODULE_ID("$Id: tries.c,v 1.32 2023/06/24 15:36:23 tom Exp $")
+MODULE_ID("$Id: tries.c,v 1.33 2024/12/07 21:24:18 tom Exp $")
 
 /*
  * Expand a keycode into the string that it corresponds to, returning null if
@@ -51,12 +51,12 @@
 _nc_expand_try(TRIES * tree, unsigned code, int *count, size_t len)
 {
     TRIES *ptr = tree;
-    char *result = 0;
+    char *result = NULL;
 
     if (code != 0) {
-	while (ptr != 0) {
+	while (ptr != NULL) {
 	    if ((result = _nc_expand_try(ptr->child, code, count, len + 1))
-		!= 0) {
+		!= NULL) {
 		break;
 	    }
 	    if (ptr->value == code) {
@@ -69,8 +69,8 @@
 	    ptr = ptr->sibling;
 	}
     }
-    if (result != 0) {
-	if (ptr != 0 && (result[len] = (char) ptr->ch) == 0)
+    if (result != NULL) {
+	if (ptr != NULL && (result[len] = (char) ptr->ch) == 0)
 	    *((unsigned char *) (result + len)) = 128;
 #ifdef TRACE
 	if (len == 0 && USE_TRACEF(TRACE_MAXIMUM)) {
@@ -96,7 +96,7 @@
     if (code == 0)
 	returnCode(FALSE);
 
-    while (*tree != 0) {
+    while (*tree != NULL) {
 	if (_nc_remove_key(&(*tree)->child, code)) {
 	    returnCode(TRUE);
 	}
@@ -128,11 +128,11 @@
     if (!VALID_STRING(string) || *string == 0)
 	returnCode(FALSE);
 
-    while (*tree != 0) {
+    while (*tree != NULL) {
 	if (UChar((*tree)->ch) == UChar(*string)) {
 	    if (string[1] != 0)
 		returnCode(_nc_remove_string(&(*tree)->child, string + 1));
-	    if ((*tree)->child == 0) {
+	    if ((*tree)->child == NULL) {
 		TRIES *to_free = *tree;
 		*tree = (*tree)->sibling;
 		free(to_free);
Index: ncurses/base/wresize.c
Prereq:  1.44 
--- ncurses-6.5-20241130+/ncurses/base/wresize.c	2024-09-28 15:56:07.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/base/wresize.c	2024-12-07 18:08:56.000000000 +0000
@@ -34,7 +34,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: wresize.c,v 1.44 2024/09/28 15:56:07 tom Exp $")
+MODULE_ID("$Id: wresize.c,v 1.45 2024/12/07 18:08:56 tom Exp $")
 
 static int
 cleanup_lines(struct ldat *data, int length)
@@ -109,7 +109,7 @@
 {
     int col, row, size_x, size_y;
     struct ldat *pline;
-    struct ldat *new_lines = 0;
+    struct ldat *new_lines = NULL;
 
 #ifdef TRACE
     T((T_CALLED("wresize(%p,%d,%d)"), (void *) win, ToLines, ToCols));
@@ -149,7 +149,7 @@
 	}
 	pline = win->_parent->_line;
     } else {
-	pline = 0;
+	pline = NULL;
     }
 
     /*
@@ -158,7 +158,7 @@
      * (at least temporarily) the array pointing to the individual lines.
      */
     new_lines = typeCalloc(struct ldat, (unsigned) (ToLines + 1));
-    if (new_lines == 0)
+    if (new_lines == NULL)
 	returnCode(ERR);
 
     /*
@@ -175,7 +175,7 @@
 	    if (row <= size_y) {
 		if (ToCols != size_x) {
 		    s = typeMalloc(NCURSES_CH_T, (unsigned) ToCols + 1);
-		    if (s == 0)
+		    if (s == NULL)
 			returnCode(cleanup_lines(new_lines, row));
 		    for (col = 0; col <= ToCols; ++col) {
 			bool valid = (col <= size_x);
@@ -195,15 +195,15 @@
 		}
 	    } else {
 		s = typeMalloc(NCURSES_CH_T, (unsigned) ToCols + 1);
-		if (s == 0)
+		if (s == NULL)
 		    returnCode(cleanup_lines(new_lines, row));
 		for (col = 0; col <= ToCols; ++col)
 		    s[col] = win->_nc_bkgd;
 	    }
-	} else if (pline != 0 && pline[win->_pary + row].text != 0) {
+	} else if (pline != NULL && pline[win->_pary + row].text != NULL) {
 	    s = &pline[win->_pary + row].text[win->_parx];
 	} else {
-	    s = 0;
+	    s = NULL;
 	}
 
 	if_USE_SCROLL_HINTS(new_lines[row].oldindex = row);
Index: ncurses/curses.priv.h
Prereq:  1.696 
--- ncurses-6.5-20241130+/ncurses/curses.priv.h	2024-11-30 21:32:44.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/curses.priv.h	2024-12-07 18:27:10.000000000 +0000
@@ -35,7 +35,7 @@
  ****************************************************************************/
 
 /*
- * $Id: curses.priv.h,v 1.696 2024/11/30 21:32:44 tom Exp $
+ * $Id: curses.priv.h,v 1.697 2024/12/07 18:27:10 tom Exp $
  *
  *	curses.priv.h
  *
@@ -445,8 +445,8 @@
 #include <term.priv.h>
 #include <nc_termios.h>
 
-#define IsPreScreen(sp)      (((sp) != 0) && sp->_prescreen)
-#define HasTerminal(sp)      (((sp) != 0) && (0 != ((sp)->_term)))
+#define IsPreScreen(sp)      (((sp) != NULL) && sp->_prescreen)
+#define HasTerminal(sp)      (((sp) != NULL) && (NULL != ((sp)->_term)))
 #define IsValidScreen(sp)    (HasTerminal(sp) && !IsPreScreen(sp))
 
 #if USE_REENTRANT
@@ -1291,7 +1291,7 @@
 #define WINDOW_EXT(w,m) (((WINDOWLIST *)((void *)((char *)(w) - offsetof(WINDOWLIST, win))))->m)
 
 #ifdef USE_SP_WINDOWLIST
-#define SP_INIT_WINDOWLIST(sp)	WindowList(sp) = 0
+#define SP_INIT_WINDOWLIST(sp)	WindowList(sp) = NULL
 #else
 #define SP_INIT_WINDOWLIST(sp)	/* nothing */
 #endif
@@ -1308,7 +1308,7 @@
     sp->_cursor            = -1;                \
     SP_INIT_WINDOWLIST(sp);                     \
     sp->_outch             = NCURSES_OUTC_FUNC; \
-    sp->jump               = 0                  \
+    sp->jump               = NULL               \
 
 /* usually in <limits.h> */
 #ifndef UCHAR_MAX
@@ -1546,7 +1546,7 @@
 #define CHANGED     -1
 
 #define LEGALYX(w, y, x) \
-	      ((w) != 0 && \
+	      ((w) != NULL && \
 		((x) >= 0 && (x) <= (w)->_maxx && \
 		 (y) >= 0 && (y) <= (w)->_maxy))
 
@@ -1579,12 +1579,12 @@
 #include <nc_alloc.h>
 #include <nc_access.h>
 
-#define FreeIfNeeded(p)  if ((p) != 0) free(p)
+#define FreeIfNeeded(p)  if ((p) != NULL) free(p)
 
 /* FreeAndNull() is not a comma-separated expression because some compilers
  * do not accept a mixture of void with values.
  */
-#define FreeAndNull(p)   do { free(p); p = 0; } while (0)
+#define FreeAndNull(p)   do { free(p); p = NULL; } while (0)
 
 #ifdef EXP_OOM_TESTING
 extern NCURSES_EXPORT(void *)	_nc_oom_malloc(size_t size);
@@ -1606,21 +1606,21 @@
 #define TYPE_MALLOC(type, size, name) \
 	do { \
 	    name = typeMalloc(type, size); \
-	    if (name == 0) \
+	    if (name == NULL) \
 		_nc_err_abort(MSG_NO_MEMORY); \
 	} while (0)
 
 #define TYPE_CALLOC(type, size, name) \
 	do { \
 	    name = typeCalloc(type, size); \
-	    if (name == 0) \
+	    if (name == NULL) \
 		_nc_err_abort(MSG_NO_MEMORY); \
 	} while (0)
 
 #define TYPE_REALLOC(type, size, name) \
 	do { \
 	    name = typeRealloc(type, size, name); \
-	    if (name == 0) \
+	    if (name == NULL) \
 		_nc_err_abort(MSG_NO_MEMORY); \
 	} while (0)
 
@@ -1652,8 +1652,8 @@
 /*
  * Standardize/simplify common loops
  */
-#define each_screen(p) p = _nc_screen_chain; p != 0; p = (p)->_next_screen
-#define each_window(sp,p) p = WindowList(sp); p != 0; p = (p)->next
+#define each_screen(p) p = _nc_screen_chain; p != NULL; p = (p)->_next_screen
+#define each_window(sp,p) p = WindowList(sp); p != NULL; p = (p)->next
 #define each_ripoff(p) p = safe_ripoff_stack; (p - safe_ripoff_stack) < N_RIPS; ++p
 
 /*
@@ -1665,8 +1665,8 @@
 #define T_CREATE(fmt) "create :" fmt
 #define T_RETURN(fmt) "return }" fmt
 
-#define NonNull(s)              ((s) != 0 ? s : "<null>")
-#define NonEmpty(s)             ((s) != 0 && *(s) != '\0')
+#define NonNull(s)              ((s) != NULL ? s : "<null>")
+#define NonEmpty(s)             ((s) != NULL && *(s) != '\0')
 
 #ifdef TRACE
 
@@ -1858,18 +1858,18 @@
    TR(TRACE_ATTRS, ("new attribute is %s", _traceattr((S))));}
 
 #define DelCharCost(sp,count) \
-		((parm_dch != 0) \
+		((parm_dch != NULL) \
 		? sp->_dch_cost \
-		: ((delete_character != 0) \
+		: ((delete_character != NULL) \
 			? (sp->_dch1_cost * count) \
 			: INFINITY))
 
 #define InsCharCost(sp,count) \
-		((parm_ich != 0) \
+		((parm_ich != NULL) \
 		? sp->_ich_cost \
 		: ((enter_insert_mode && exit_insert_mode) \
 		  ? sp->_smir_cost + sp->_rmir_cost + (sp->_ip_cost * count) \
-		  : ((insert_character != 0) \
+		  : ((insert_character != NULL) \
 		    ? ((sp->_ich1_cost + sp->_ip_cost) * count) \
 		    : INFINITY)))
 
@@ -1956,7 +1956,7 @@
 #endif
 
 #define save_ttytype(termp) \
-	if (TerminalType(termp).term_names != 0) { \
+	if (TerminalType(termp).term_names != NULL) { \
 	    _nc_STRNCPY(ttytype, \
 	    		TerminalType(termp).term_names, \
 			NAMESIZE - 1); \
@@ -2034,7 +2034,7 @@
 extern NCURSES_EXPORT(void) _nc_change_pair(SCREEN *, int);
 
 #define ReservePairs(sp,want) \
-	    if ((sp->_color_pairs == 0) || (want >= sp->_pair_alloc)) \
+	    if ((sp->_color_pairs == NULL) || (want >= sp->_pair_alloc)) \
 		_nc_reserve_pairs(sp, want)
 
 /* lib_getch.c */
@@ -2077,7 +2077,7 @@
 extern NCURSES_EXPORT(void)   _nc_forget_prescr(void);
 #else
 #define _nc_find_prescr()     _nc_prescreen.allocated
-#define _nc_forget_prescr()   _nc_prescreen.allocated = 0
+#define _nc_forget_prescr()   _nc_prescreen.allocated = NULL
 #endif
 
 /* lib_set_term.c */
@@ -2311,7 +2311,7 @@
 
 #define USE_SETBUF_0 0
 
-#define NC_OUTPUT(sp) ((sp != 0 && sp->_ofp != 0) ? sp->_ofp : stdout)
+#define NC_OUTPUT(sp) ((sp != NULL && sp->_ofp != NULL) ? sp->_ofp : stdout)
 
 /*
  * On systems with a broken linker, define 'SP' as a function to force the
@@ -2385,7 +2385,7 @@
 #define SetSafeOutcWrapper(outc)	    \
     SCREEN* sp = CURRENT_SCREEN;            \
     struct screen outc_wrapper;		    \
-    if (sp==0) {                            \
+    if (sp == NULL) {                       \
 	sp = &outc_wrapper;                 \
 	memset(sp,0,sizeof(struct screen)); \
 	sp->_outch = _nc_outc_wrapper;      \
@@ -2579,7 +2579,7 @@
 #  endif
 #else
 #  define IsTermInfo(sp)       TRUE
-#  define HasTInfoTerminal(sp) (0 != TerminalOf(sp))
+#  define HasTInfoTerminal(sp) (NULL != TerminalOf(sp))
 #  if defined(EXP_WIN32_DRIVER)
 #    define IsTermInfoOnConsole(sp) _nc_console_test(TerminalOf(sp)->Filedes)
 #  else
Index: ncurses/new_pair.h
Prereq:  1.15 
--- ncurses-6.5-20241130+/ncurses/new_pair.h	2024-10-05 20:57:47.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/new_pair.h	2024-12-07 17:27:35.000000000 +0000
@@ -34,7 +34,7 @@
 /*
  * Common type definitions and macros for new_pair.c, lib_color.c
  *
- * $Id: new_pair.h,v 1.15 2024/10/05 20:57:47 tom Exp $
+ * $Id: new_pair.h,v 1.16 2024/12/07 17:27:35 tom Exp $
  */
 
 #ifndef NEW_PAIR_H
@@ -111,7 +111,7 @@
  * that the index is within the limits of the table which we allocated.
  */
 #define ValidPair(sp,pair) \
-    ((sp != 0) && (pair >= 0) && (pair < sp->_pair_limit) && sp->_coloron)
+    ((sp != NULL) && (pair >= 0) && (pair < sp->_pair_limit) && sp->_coloron)
 
 #if NCURSES_EXT_FUNCS && NCURSES_EXT_COLORS
 extern NCURSES_EXPORT(void)     _nc_copy_pairs(SCREEN*, colorpair_t*, colorpair_t*, int);
Index: ncurses/report_offsets.c
Prereq:  1.29 
--- ncurses-6.5-20241130+/ncurses/report_offsets.c	2024-05-25 23:00:26.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/report_offsets.c	2024-12-07 21:18:23.000000000 +0000
@@ -34,10 +34,10 @@
 #define NEW_PAIR_INTERNAL 1
 #include <curses.priv.h>
 
-MODULE_ID("$Id: report_offsets.c,v 1.29 2024/05/25 23:00:26 tom Exp $")
+MODULE_ID("$Id: report_offsets.c,v 1.30 2024/12/07 21:18:23 tom Exp $")
 
 #define show_size(type) \
-	flag = 0; \
+	flag = NULL; \
 	last = 0; \
 	printf("%5lu   " #type "\n", (unsigned long)sizeof(type))
 #define show_name(name) \
@@ -48,7 +48,7 @@
 		printf("?? incorrect order for " #type "." #member "\n"); \
 	printf("%5lu %c " #type "." #member "\n", next, flag ? *flag : ' '); \
 	last = next; \
-	flag = 0
+	flag = NULL
 
 #if NCURSES_WIDECHAR && NCURSES_EXT_COLORS
 #define show_COLORS(type,member) { flag = "c"; show_offset(type,member); }
@@ -104,7 +104,7 @@
 int
 main(void)
 {
-    const char *flag = 0;
+    const char *flag = NULL;
     unsigned long last, next;
 
     printf("Size/offsets of data structures:\n");
Index: ncurses/tinfo/MKcaptab.awk
Prereq:  1.21 
--- ncurses-6.5-20241130+/ncurses/tinfo/MKcaptab.awk	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/MKcaptab.awk	2024-12-07 20:52:55.000000000 +0000
@@ -1,5 +1,5 @@
 ##############################################################################
-# Copyright 2020 Thomas E. Dickey                                            #
+# Copyright 2020,2024 Thomas E. Dickey                                       #
 # Copyright 1998-2006,2007 Free Software Foundation, Inc.                    #
 #                                                                            #
 # Permission is hereby granted, free of charge, to any person obtaining a    #
@@ -26,7 +26,7 @@
 # use or other dealings in this Software without prior written               #
 # authorization.                                                             #
 ##############################################################################
-# $Id: MKcaptab.awk,v 1.21 2020/02/02 23:34:34 tom Exp $
+# $Id: MKcaptab.awk,v 1.22 2024/12/07 20:52:55 tom Exp $
 function add_string(text) {
     if (text != "IGNORE") {
 	offsets[num_strings] = offset;
@@ -53,7 +53,7 @@
 		printf "/* generated by MKcaptab.awk %s(%d) */\n", tablename, bigstrings;
 		print ""
 		if (bigstrings) {
-		    printf "static struct alias *_nc_%s_table = 0;\n", tablename;
+		    printf "static struct alias *_nc_%s_table = NULL;\n", tablename;
 		    print "";
 		    printf "static const char %s_text[] = \"\\\n", tablename;
 		} else {
Index: ncurses/tinfo/MKcaptab.sh
Prereq:  1.20 
--- ncurses-6.5-20241130+/ncurses/tinfo/MKcaptab.sh	2023-04-22 15:12:57.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/MKcaptab.sh	2024-12-07 21:30:44.000000000 +0000
@@ -1,6 +1,6 @@
 #!/bin/sh
 ##############################################################################
-# Copyright 2019-2020,2023 Thomas E. Dickey                                  #
+# Copyright 2019-2023,2024 Thomas E. Dickey                                  #
 # Copyright 2007-2010,2011 Free Software Foundation, Inc.                    #
 #                                                                            #
 # Permission is hereby granted, free of charge, to any person obtaining a    #
@@ -27,13 +27,13 @@
 # use or other dealings in this Software without prior written               #
 # authorization.                                                             #
 ##############################################################################
-# $Id: MKcaptab.sh,v 1.20 2023/04/22 15:12:57 tom Exp $
+# $Id: MKcaptab.sh,v 1.22 2024/12/07 21:30:44 tom Exp $
 
 if test $# != 0
 then
 	AWK="$1"; shift 1
 else
-	AWK=awk
+	AWK="awk"
 fi
 
 if test $# != 0
@@ -71,12 +71,12 @@
 /* *INDENT-OFF* */
 EOF
 
-cat "$@" |./make_hash 1 info $OPT1
-cat "$@" |./make_hash 3 cap  $OPT1
+cat "$@" |./make_hash 1 info "$OPT1"
+cat "$@" |./make_hash 3 cap  "$OPT1"
 
-cat "$@" |$AWK -f $OPT2 bigstrings=$OPT1 tablename=capalias
+cat "$@" |$AWK -f "$OPT2" bigstrings="$OPT1" tablename=capalias
 
-cat "$@" |$AWK -f $OPT2 bigstrings=$OPT1 tablename=infoalias
+cat "$@" |$AWK -f "$OPT2" bigstrings="$OPT1" tablename=infoalias
 
 cat <<EOF
 /* *INDENT-ON* */
@@ -93,9 +93,9 @@
 		const name_table_data * source,
 		const char *strings)
 {
-    if (*actual == 0) {
+    if (*actual == NULL) {
 	*actual = typeCalloc(struct name_table_entry, CAPTABSIZE);
-	if (*actual != 0) {
+	if (*actual != NULL) {
 	    unsigned n;
 	    unsigned len = 0;
 	    for (n = 0; n < CAPTABSIZE; ++n) {
@@ -121,9 +121,9 @@
 		const char *strings,
 		size_t tablesize)
 {
-    if (*actual == 0) {
+    if (*actual == NULL) {
 	*actual = typeCalloc(struct alias, tablesize + 1);
-	if (*actual != 0) {
+	if (*actual != NULL) {
 	    size_t n;
 	    for (n = 0; n < tablesize; ++n) {
 		add_alias(from);
Index: ncurses/tinfo/MKcodes.awk
Prereq:  1.11 
--- ncurses-6.5-20241130+/ncurses/tinfo/MKcodes.awk	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/MKcodes.awk	2024-12-07 20:03:37.000000000 +0000
@@ -1,5 +1,5 @@
 ##############################################################################
-# Copyright 2019,2020 Thomas E. Dickey                                       #
+# Copyright 2019-2020,2024 Thomas E. Dickey                                  #
 # Copyright 2007-2009,2010 Free Software Foundation, Inc.                    #
 #                                                                            #
 # Permission is hereby granted, free of charge, to any person obtaining a    #
@@ -26,7 +26,7 @@
 # use or other dealings in this Software without prior written               #
 # authorization.                                                             #
 ##############################################################################
-# $Id: MKcodes.awk,v 1.11 2020/02/02 23:34:34 tom Exp $
+# $Id: MKcodes.awk,v 1.12 2024/12/07 20:03:37 tom Exp $
 function large_item(value) {
 	result = sprintf("%d,", offset);
 	offset = offset + length(value) + 1;
@@ -105,7 +105,7 @@
 		print  "#if BROKEN_LINKER || USE_REENTRANT"
 		print  ""
 		if (bigstrings) {
-			printf "static const char _nc_code_blob[] = \n"
+			printf "static const char _nc_code_blob[] =\n"
 			printf "%s;\n", bigstr;
 			print_offsets("boolcodes", large_boolcodes);
 			print_offsets("numcodes", large_numcodes);
Index: ncurses/tinfo/MKfallback.sh
Prereq:  1.26 
--- ncurses-6.5-20241130+/ncurses/tinfo/MKfallback.sh	2023-04-22 15:12:57.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/MKfallback.sh	2024-12-07 20:57:05.000000000 +0000
@@ -27,7 +27,7 @@
 # use or other dealings in this Software without prior written               #
 # authorization.                                                             #
 ##############################################################################
-# $Id: MKfallback.sh,v 1.26 2023/04/22 15:12:57 tom Exp $
+# $Id: MKfallback.sh,v 1.27 2024/12/07 20:57:05 tom Exp $
 #
 # MKfallback.sh -- create fallback table for entry reads
 #
@@ -150,8 +150,8 @@
 _nc_fallback (const char *name)
 {
     const TERMTYPE2 *tp = _nc_fallback2(name);
-    const TERMTYPE *result = 0;
-    if (tp != 0) {
+    const TERMTYPE *result = NULL;
+    if (tp != NULL) {
 	static TERMTYPE temp;
 	_nc_export_termtype2(&temp, tp);
 	result = &temp;
Index: ncurses/tinfo/MKnames.awk
Prereq:  1.24 
--- ncurses-6.5-20241130+/ncurses/tinfo/MKnames.awk	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/MKnames.awk	2024-12-07 20:04:23.000000000 +0000
@@ -1,5 +1,5 @@
 ##############################################################################
-# Copyright 2019,2020 Thomas E. Dickey                                       #
+# Copyright 2019-2020,2024 Thomas E. Dickey                                  #
 # Copyright 1998-2008,2009 Free Software Foundation, Inc.                    #
 #                                                                            #
 # Permission is hereby granted, free of charge, to any person obtaining a    #
@@ -26,7 +26,7 @@
 # use or other dealings in this Software without prior written               #
 # authorization.                                                             #
 ##############################################################################
-# $Id: MKnames.awk,v 1.24 2020/02/02 23:34:34 tom Exp $
+# $Id: MKnames.awk,v 1.25 2024/12/07 20:04:23 tom Exp $
 function large_item(value) {
 	result = sprintf("%d,", offset);
 	offset = offset + length(value) + 1;
@@ -111,7 +111,7 @@
 		print  "#if BROKEN_LINKER || USE_REENTRANT"
 		print  ""
 		if (bigstrings) {
-			printf "static const char _nc_name_blob[] = \n"
+			printf "static const char _nc_name_blob[] =\n"
 			printf "%s;\n", bigstr;
 			print_offsets("boolfnames", large_boolfnames);
 			print_offsets("boolnames", large_boolnames);
Index: ncurses/tinfo/MKuserdefs.sh
Prereq:  1.10 
--- ncurses-6.5-20241130+/ncurses/tinfo/MKuserdefs.sh	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/MKuserdefs.sh	2024-12-07 20:04:23.000000000 +0000
@@ -1,6 +1,6 @@
 #!/bin/sh
 ##############################################################################
-# Copyright 2019,2020 Thomas E. Dickey                                       #
+# Copyright 2019-2020,2024 Thomas E. Dickey                                  #
 #                                                                            #
 # Permission is hereby granted, free of charge, to any person obtaining a    #
 # copy of this software and associated documentation files (the "Software"), #
@@ -26,7 +26,7 @@
 # use or other dealings in this Software without prior written               #
 # authorization.                                                             #
 ##############################################################################
-# $Id: MKuserdefs.sh,v 1.10 2020/02/02 23:34:34 tom Exp $
+# $Id: MKuserdefs.sh,v 1.11 2024/12/07 20:04:23 tom Exp $
 AWK=${1-awk}; shift 1
 OPT1=${1-0}; shift 1
 
@@ -69,9 +69,9 @@
 		const user_table_data *source,
 		const char *strings)
 {
-    if (*actual == 0) {
+    if (*actual == NULL) {
 	*actual = typeCalloc(struct user_table_entry, USERTABSIZE);
-	if (*actual != 0) {
+	if (*actual != NULL) {
 	    unsigned n;
 	    unsigned len = 0;
 	    for (n = 0; n < USERTABSIZE; ++n) {
Index: ncurses/tinfo/access.c
Prereq:  1.40 
--- ncurses-6.5-20241130+/ncurses/tinfo/access.c	2024-11-09 18:30:28.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/access.c	2024-12-07 18:05:04.000000000 +0000
@@ -52,7 +52,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: access.c,v 1.40 2024/11/09 18:30:28 tom Exp $")
+MODULE_ID("$Id: access.c,v 1.41 2024/12/07 18:05:04 tom Exp $")
 
 #define LOWERCASE(c) ((isalpha(UChar(c)) && isupper(UChar(c))) ? tolower(UChar(c)) : (c))
 
@@ -70,7 +70,7 @@
     static char *temp;
     char *s;
 
-    if ((temp = strdup(result)) != 0)
+    if ((temp = strdup(result)) != NULL)
 	result = temp;
 #if !MIXEDCASE_FILENAMES
     for (s = result; *s != '\0'; ++s) {
@@ -97,7 +97,7 @@
 #define is_pathname(s) ((((s) != 0) && ((s)[0] == '/')) \
 		  || (((s)[0] != 0) && ((s)[1] == ':')))
 #else
-#define is_pathname(s) ((s) != 0 && (s)[0] == '/')
+#define is_pathname(s) ((s) != NULL && (s)[0] == '/')
 #endif
     return is_pathname(path);
 }
@@ -113,7 +113,7 @@
     if (test == 0)
 	test = strrchr(path, '\\');
 #endif
-    if (test == 0)
+    if (test == NULL)
 	test = path;
     else
 	test++;
@@ -131,7 +131,7 @@
 {
     int result;
 
-    if (path == 0) {
+    if (path == NULL) {
 	errno = ENOENT;
 	result = -1;
     } else if (ACCESS(path, mode) < 0) {
@@ -143,7 +143,7 @@
 
 	    _nc_STRCPY(head, path, sizeof(head));
 	    leaf = _nc_basename(head);
-	    if (leaf == 0)
+	    if (leaf == NULL)
 		leaf = head;
 	    *leaf = '\0';
 	    if (head == leaf)
Index: ncurses/tinfo/add_tries.c
Prereq:  1.13 
--- ncurses-6.5-20241130+/ncurses/tinfo/add_tries.c	2023-06-24 15:36:13.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/add_tries.c	2024-12-07 20:04:23.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019-2020,2023 Thomas E. Dickey                                *
+ * Copyright 2019-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2009,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -41,7 +41,7 @@
 #include <curses.priv.h>
 #include <tic.h>
 
-MODULE_ID("$Id: add_tries.c,v 1.13 2023/06/24 15:36:13 tom Exp $")
+MODULE_ID("$Id: add_tries.c,v 1.14 2024/12/07 20:04:23 tom Exp $")
 
 #define SET_TRY(dst,src) if ((dst->ch = *src++) == 128) dst->ch = '\0'
 #define CMP_TRY(a,b) ((a)? (a == b) : (b == 128))
@@ -57,14 +57,14 @@
     if (!VALID_STRING(str) || *txt == '\0' || code == 0)
 	returnCode(ERR);
 
-    if ((*tree) != 0) {
+    if ((*tree) != NULL) {
 	ptr = savedptr = (*tree);
 
 	for (;;) {
 	    unsigned char cmp = *txt;
 
 	    while (!CMP_TRY(ptr->ch, cmp)
-		   && ptr->sibling != 0)
+		   && ptr->sibling != NULL)
 		ptr = ptr->sibling;
 
 	    if (CMP_TRY(ptr->ch, cmp)) {
@@ -72,12 +72,12 @@
 		    ptr->value = (unsigned short) code;
 		    returnCode(OK);
 		}
-		if (ptr->child != 0)
+		if (ptr->child != NULL)
 		    ptr = ptr->child;
 		else
 		    break;
 	    } else {
-		if ((ptr->sibling = typeCalloc(TRIES, 1)) == 0) {
+		if ((ptr->sibling = typeCalloc(TRIES, 1)) == NULL) {
 		    returnCode(ERR);
 		}
 
@@ -91,7 +91,7 @@
     } else {			/* (*tree) == 0 :: First sequence to be added */
 	savedptr = ptr = (*tree) = typeCalloc(TRIES, 1);
 
-	if (ptr == 0) {
+	if (ptr == NULL) {
 	    returnCode(ERR);
 	}
 
@@ -106,8 +106,8 @@
 
 	ptr = ptr->child;
 
-	if (ptr == 0) {
-	    while ((ptr = savedptr) != 0) {
+	if (ptr == NULL) {
+	    while ((ptr = savedptr) != NULL) {
 		savedptr = ptr->child;
 		free(ptr);
 	    }
Index: ncurses/tinfo/alloc_entry.c
Prereq:  1.80 
--- ncurses-6.5-20241130+/ncurses/tinfo/alloc_entry.c	2024-11-09 20:36:48.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/alloc_entry.c	2024-12-07 21:12:53.000000000 +0000
@@ -48,7 +48,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: alloc_entry.c,v 1.80 2024/11/09 20:36:48 tom Exp $")
+MODULE_ID("$Id: alloc_entry.c,v 1.81 2024/12/07 21:12:53 tom Exp $")
 
 #define ABSENT_OFFSET    -1
 #define CANCELLED_OFFSET -2
@@ -104,7 +104,7 @@
 NCURSES_EXPORT(char *)
 _nc_save_str(const char *string)
 {
-    char *result = 0;
+    char *result = NULL;
     size_t old_next_free = next_free;
 
     if (stringbuf != NULL) {
@@ -164,7 +164,7 @@
 	}
 
 	for (i = 0; i < nuses; i++) {
-	    if (ep->uses[i].name == 0) {
+	    if (ep->uses[i].name == NULL) {
 		ep->uses[i].name = _nc_save_str(ep->uses[i].name);
 	    }
 	}
@@ -187,7 +187,7 @@
     }
 
     for (i = 0; i < nuses; i++) {
-	if (ep->uses[i].name == 0)
+	if (ep->uses[i].name == NULL)
 	    useoffsets[i] = ABSENT_OFFSET;
 	else
 	    useoffsets[i] = (int) (ep->uses[i].name - stringbuf);
@@ -237,7 +237,7 @@
 
     for (i = 0; i < nuses; i++) {
 	if (useoffsets[i] == ABSENT_OFFSET) {
-	    ep->uses[i].name = 0;
+	    ep->uses[i].name = NULL;
 	} else {
 	    ep->uses[i].name = strdup(tp->str_table + useoffsets[i]);
 	}
@@ -258,7 +258,7 @@
 #endif
     unsigned i;
 
-    if (source == 0 || from == 0 || target == 0 || to == 0)
+    if (source == NULL || from == NULL || target == NULL || to == NULL)
 	return;
 
 #if NCURSES_XNAMES
Index: ncurses/tinfo/alloc_ttype.c
Prereq:  1.52 
--- ncurses-6.5-20241130+/ncurses/tinfo/alloc_ttype.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/alloc_ttype.c	2024-12-07 18:08:56.000000000 +0000
@@ -43,7 +43,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: alloc_ttype.c,v 1.52 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: alloc_ttype.c,v 1.53 2024/12/07 18:08:56 tom Exp $")
 
 #if NCURSES_XNAMES
 /*
@@ -532,8 +532,8 @@
     char *new_table;
     size_t new_table_size;
 #if NCURSES_EXT_NUMBERS
-    short *oldptr = 0;
-    int *newptr = 0;
+    short *oldptr = NULL;
+    int *newptr = NULL;
 #endif
 
     DEBUG(2, (T_CALLED("copy_termtype(dst=%p, src=%p, mode=%d)"), (void *)
@@ -594,7 +594,7 @@
 	TYPE_MALLOC(int, NUM_NUMBERS(dst), newptr);
 	dst->Numbers = newptr;
     }
-    if ((mode == srcINT) && (oldptr != 0)) {
+    if ((mode == srcINT) && (oldptr != NULL)) {
 	DEBUG(2, ("...copy int ->short"));
 	for (i = 0; i < NUM_NUMBERS(dst); ++i) {
 	    if (src->Numbers[i] > MAX_OF_TYPE(short)) {
@@ -603,7 +603,7 @@
 		oldptr[i] = (short) src->Numbers[i];
 	    }
 	}
-    } else if ((mode == dstINT) && (newptr != 0)) {
+    } else if ((mode == dstINT) && (newptr != NULL)) {
 	DEBUG(2, ("...copy short ->int"));
 	for (i = 0; i < NUM_NUMBERS(dst); ++i) {
 	    newptr[i] = ((const short *) (src->Numbers))[i];
@@ -672,7 +672,7 @@
 	    }
 	}
     } else {
-	dst->ext_Names = 0;
+	dst->ext_Names = NULL;
     }
 #endif
     (void) new_table_size;
Index: ncurses/tinfo/captoinfo.c
Prereq:  1.104 
--- ncurses-6.5-20241130+/ncurses/tinfo/captoinfo.c	2024-10-19 21:18:54.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/captoinfo.c	2024-12-07 21:12:53.000000000 +0000
@@ -98,7 +98,7 @@
 #include <ctype.h>
 #include <tic.h>
 
-MODULE_ID("$Id: captoinfo.c,v 1.104 2024/10/19 21:18:54 tom Exp $")
+MODULE_ID("$Id: captoinfo.c,v 1.105 2024/12/07 21:12:53 tom Exp $")
 
 #if 0
 #define DEBUG_THIS(p) DEBUG(9, p)
@@ -124,7 +124,7 @@
 init_string(void)
 /* initialize 'my_string', 'my_length' */
 {
-    if (my_string == 0)
+    if (my_string == NULL)
 	TYPE_MALLOC(char, my_length = 256, my_string);
 
     *my_string = '\0';
@@ -138,7 +138,7 @@
     size_t need = have + strlen(s) + 2;
     if (need > my_length) {
 	my_string = (char *) _nc_doalloc(my_string, my_length = (need + need));
-	if (my_string == 0)
+	if (my_string == NULL)
 	    _nc_err_abort(MSG_NO_MEMORY);
 	d = my_string + have;
     }
@@ -313,8 +313,8 @@
     dp = init_string();
 
     /* skip the initial padding (if we haven't been told not to) */
-    capstart = 0;
-    if (s == 0)
+    capstart = NULL;
+    if (s == NULL)
 	s = "";
     if (parameterized >= 0 && isdigit(UChar(*s)))
 	for (capstart = s; *s != '\0'; s++)
@@ -619,7 +619,7 @@
 {
     int seenone = 0, seentwo = 0, saw_m = 0, saw_n = 0;
     const char *padding;
-    const char *trimmed = 0;
+    const char *trimmed = NULL;
     int in0, in1, in2;
     char ch1 = 0, ch2 = 0;
     char *bufptr = init_string();
@@ -655,9 +655,9 @@
 
     for (; !syntax_error &&
 	 *str &&
-	 ((trimmed == 0) || (str < trimmed)); str++) {
+	 ((trimmed == NULL) || (str < trimmed)); str++) {
 	int c1, c2;
-	char *cp = 0;
+	char *cp = NULL;
 
 	if (str[0] == '^') {
 	    if (str[1] == '\0' || (str + 1) == trimmed) {
@@ -743,7 +743,7 @@
 				++myfix;
 			    }
 			}
-		    } else if (strchr("E\\nrtbf", xx1) == 0) {
+		    } else if (strchr("E\\nrtbf", xx1) == NULL) {
 			switch (xx1) {
 			case 'e':
 			    xx1 = 'E';
@@ -814,7 +814,7 @@
 		   && ((in0 == 4 && in1 == 10 && in2 == 48)
 		       || (in0 == 3 && in1 == 9 && in2 == 38))) {
 	    /* dumb-down an optimized case from xterm-256color for termcap */
-	    if ((str = strstr(str, ";m")) == 0)
+	    if ((str = strstr(str, ";m")) == NULL)
 		break;		/* cannot happen */
 	    ++str;
 	    if (in2 == 48) {
@@ -981,7 +981,7 @@
 	 * but that may not be the end of the string.
 	 */
 	assert(str != 0);
-	if (str == 0 || *str == '\0')
+	if (str == NULL || *str == '\0')
 	    break;
 
     }				/* endwhile (*str) */
@@ -1050,7 +1050,7 @@
 NCURSES_EXPORT(void)
 _nc_captoinfo_leaks(void)
 {
-    if (my_string != 0) {
+    if (my_string != NULL) {
 	FreeAndNull(my_string);
     }
     my_length = 0;
Index: ncurses/tinfo/comp_error.c
Prereq:  1.44 
--- ncurses-6.5-20241130+/ncurses/tinfo/comp_error.c	2023-06-15 20:27:02.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/comp_error.c	2024-12-07 20:04:23.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019-2020,2023 Thomas E. Dickey                                *
+ * Copyright 2019-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -42,7 +42,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: comp_error.c,v 1.44 2023/06/15 20:27:02 tom Exp $")
+MODULE_ID("$Id: comp_error.c,v 1.45 2024/12/07 20:04:23 tom Exp $")
 
 NCURSES_EXPORT_VAR(bool) _nc_suppress_warnings = FALSE;
 NCURSES_EXPORT_VAR(int) _nc_curr_line = 0; /* current line # in input */
@@ -75,9 +75,9 @@
 _nc_set_type(const char *const name)
 {
 #define MY_SIZE (size_t) MAX_NAME_SIZE
-    if (TermType == 0)
+    if (TermType == NULL)
 	TermType = typeMalloc(char, MY_SIZE + 1);
-    if (TermType != 0) {
+    if (TermType != NULL) {
 	TermType[0] = '\0';
 	if (name) {
 	    _nc_STRNCAT(TermType, name, MY_SIZE, MY_SIZE);
@@ -89,13 +89,13 @@
 _nc_get_type(char *name)
 {
 #if NO_LEAKS
-    if (name == 0 && TermType != 0) {
+    if (name == NULL && TermType != NULL) {
 	FreeAndNull(TermType);
 	return;
     }
 #endif
-    if (name != 0)
-	_nc_STRCPY(name, TermType != 0 ? TermType : "", MAX_NAME_SIZE);
+    if (name != NULL)
+	_nc_STRCPY(name, TermType != NULL ? TermType : "", MAX_NAME_SIZE);
 }
 
 static NCURSES_INLINE void
@@ -106,7 +106,7 @@
 	fprintf(stderr, ", line %d", _nc_curr_line);
     if (_nc_curr_col > 0)
 	fprintf(stderr, ", col %d", _nc_curr_col);
-    if (TermType != 0 && TermType[0] != '\0')
+    if (TermType != NULL && TermType[0] != '\0')
 	fprintf(stderr, ", terminal '%s'", TermType);
     fputc(':', stderr);
     fputc(' ', stderr);
Index: ncurses/tinfo/comp_expand.c
Prereq:  1.36 
--- ncurses-6.5-20241130+/ncurses/tinfo/comp_expand.c	2024-11-30 21:24:57.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/comp_expand.c	2024-12-07 21:12:53.000000000 +0000
@@ -36,7 +36,7 @@
 #include <ctype.h>
 #include <tic.h>
 
-MODULE_ID("$Id: comp_expand.c,v 1.36 2024/11/30 21:24:57 tom Exp $")
+MODULE_ID("$Id: comp_expand.c,v 1.37 2024/12/07 21:12:53 tom Exp $")
 
 #if 0
 #define DEBUG_THIS(p) DEBUG(9, p)
@@ -73,18 +73,18 @@
 	int offset;
     } fixups[MAX_TC_FIXUPS];
 
-    if (srcp == 0) {
+    if (srcp == NULL) {
 #if NO_LEAKS
-	if (buffer != 0) {
+	if (buffer != NULL) {
 	    FreeAndNull(buffer);
 	    length = 0;
 	}
 #endif
-	return 0;
+	return NULL;
     }
-    if (buffer == 0 || need > length) {
-	if ((buffer = typeRealloc(char, length = need, buffer)) == 0)
-	      return 0;
+    if (buffer == NULL || need > length) {
+	if ((buffer = typeRealloc(char, length = need, buffer)) == NULL)
+	      return NULL;
     }
 
     DEBUG_THIS(("_nc_tic_expand %s:%s:%s",
@@ -124,9 +124,9 @@
 	    case 1:
 		if (str[0] == L_BRACE
 		    && isdigit(UChar(str[1]))) {
-		    char *dst = 0;
+		    char *dst = NULL;
 		    long value = strtol(str + 1, &dst, 0);
-		    if (dst != 0
+		    if (dst != NULL
 			&& *dst == R_BRACE
 			&& value < 127
 			&& isprint(UChar(value))) {
Index: ncurses/tinfo/comp_hash.c
Prereq:  1.55 
--- ncurses-6.5-20241130+/ncurses/tinfo/comp_hash.c	2023-06-24 13:29:43.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/comp_hash.c	2024-12-07 20:05:08.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019-2020,2023 Thomas E. Dickey                                *
+ * Copyright 2019-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2008,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -45,7 +45,7 @@
 #include <tic.h>
 #include <hashsize.h>
 
-MODULE_ID("$Id: comp_hash.c,v 1.55 2023/06/24 13:29:43 tom Exp $")
+MODULE_ID("$Id: comp_hash.c,v 1.56 2024/12/07 20:05:08 tom Exp $")
 
 /*
  * Finds the entry for the given string in the hash table if present.
@@ -58,7 +58,7 @@
     bool termcap = (hash_table != _nc_get_hash_table(FALSE));
     const HashData *data = _nc_get_hash_info(termcap);
     int hashvalue;
-    struct name_table_entry const *ptr = 0;
+    struct name_table_entry const *ptr = NULL;
     struct name_table_entry const *real_table;
 
     hashvalue = data->hash_of(string);
@@ -71,7 +71,7 @@
 	ptr = real_table + data->table_data[hashvalue];
 	while (!data->compare_names(ptr->nte_name, string)) {
 	    if (ptr->nte_link < 0) {
-		ptr = 0;
+		ptr = NULL;
 		break;
 	    }
 	    ptr = real_table + (ptr->nte_link
@@ -108,7 +108,7 @@
 	    while (ptr->nte_type != type
 		   || !data->compare_names(ptr->nte_name, string)) {
 		if (ptr->nte_link < 0) {
-		    ptr = 0;
+		    ptr = NULL;
 		    break;
 		}
 		ptr = table + (ptr->nte_link + data->table_data[data->table_size]);
@@ -125,7 +125,7 @@
 {
     const HashData *data = _nc_get_hash_user();
     int hashvalue;
-    struct user_table_entry const *ptr = 0;
+    struct user_table_entry const *ptr = NULL;
     struct user_table_entry const *real_table;
 
     hashvalue = data->hash_of(string);
@@ -138,7 +138,7 @@
 	ptr = real_table + data->table_data[hashvalue];
 	while (!data->compare_names(ptr->ute_name, string)) {
 	    if (ptr->ute_link < 0) {
-		ptr = 0;
+		ptr = NULL;
 		break;
 	    }
 	    ptr = real_table + (ptr->ute_link
Index: ncurses/tinfo/comp_parse.c
Prereq:  1.135 
--- ncurses-6.5-20241130+/ncurses/tinfo/comp_parse.c	2024-07-27 19:15:16.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/comp_parse.c	2024-12-07 21:12:53.000000000 +0000
@@ -48,7 +48,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: comp_parse.c,v 1.135 2024/07/27 19:15:16 tom Exp $")
+MODULE_ID("$Id: comp_parse.c,v 1.136 2024/12/07 21:12:53 tom Exp $")
 
 static void sanity_check2(TERMTYPE2 *, bool);
 NCURSES_IMPEXP void (NCURSES_API *_nc_check_termtype2) (TERMTYPE2 *, bool) = sanity_check2;
@@ -64,13 +64,13 @@
     DEBUG(2, (T_CALLED("enqueue(ep=%p)"), (void *) ep));
 
     newp = _nc_copy_entry(ep);
-    if (newp == 0)
+    if (newp == NULL)
 	_nc_err_abort(MSG_NO_MEMORY);
 
     newp->last = _nc_tail;
     _nc_tail = newp;
 
-    newp->next = 0;
+    newp->next = NULL;
     if (newp->last)
 	newp->last->next = newp;
     DEBUG(2, (T_RETURN("")));
@@ -81,7 +81,7 @@
 static char *
 force_bar(char *dst, char *src)
 {
-    if (strchr(src, '|') == 0) {
+    if (strchr(src, '|') == NULL) {
 	size_t len = strlen(src);
 	if (len > MAX_NAME_SIZE)
 	    len = MAX_NAME_SIZE;
@@ -91,7 +91,7 @@
     }
     return src;
 }
-#define ForceBar(dst, src) ((strchr(src, '|') == 0) ? force_bar(dst, src) : src)
+#define ForceBar(dst, src) ((strchr(src, '|') == NULL) ? force_bar(dst, src) : src)
 
 #if NCURSES_USE_TERMCAP && NCURSES_XNAMES
 static char *
@@ -152,7 +152,7 @@
 name_ending(char *name)
 {
     if (*name == '\0') {
-	name = 0;
+	name = NULL;
     } else {
 	while (*name != '\0' && *name != '|')
 	    ++name;
@@ -403,7 +403,7 @@
 _nc_resolve_uses2(bool fullresolve, bool literal)
 /* try to resolve all use capabilities */
 {
-    ENTRY *qp, *rp, *lastread = 0;
+    ENTRY *qp, *rp, *lastread = NULL;
     bool keepgoing;
     unsigned i, j;
     int total_unresolved, multiples;
@@ -452,7 +452,7 @@
 	    char *lookfor = qp->uses[i].name;
 	    long lookline = qp->uses[i].line;
 
-	    if (lookfor == 0)
+	    if (lookfor == NULL)
 		continue;
 
 	    foundit = FALSE;
@@ -518,7 +518,7 @@
 
 		_nc_curr_line = (int) lookline;
 		_nc_warning("resolution of use=%s failed", lookfor);
-		qp->uses[i].link = 0;
+		qp->uses[i].link = NULL;
 	    }
 	}
     }
@@ -758,7 +758,7 @@
     _nc_names_leaks();
     _nc_codes_leaks();
 #endif
-    _nc_tic_expand(0, FALSE, 0);
+    _nc_tic_expand(NULL, FALSE, 0);
     T((T_RETURN("")));
 }
 
Index: ncurses/tinfo/comp_scan.c
Prereq:  1.124 
--- ncurses-6.5-20241130+/ncurses/tinfo/comp_scan.c	2024-11-23 18:45:01.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/comp_scan.c	2024-12-07 21:17:54.000000000 +0000
@@ -51,7 +51,7 @@
 #include <ctype.h>
 #include <tic.h>
 
-MODULE_ID("$Id: comp_scan.c,v 1.124 2024/11/23 18:45:01 tom Exp $")
+MODULE_ID("$Id: comp_scan.c,v 1.125 2024/12/07 21:17:54 tom Exp $")
 
 /*
  * Maximum length of string capability we'll accept before raising an error.
@@ -70,7 +70,7 @@
 
 NCURSES_EXPORT_VAR (struct token) _nc_curr_token =
 {
-    0, 0, 0
+    NULL, 0, NULL
 };
 
 /*****************************************************************************
@@ -116,12 +116,12 @@
        (T_CALLED("_nc_reset_input(fp=%p, buf=%p)"), (void *) fp, buf));
 
     pushtype = NO_PUSHBACK;
-    if (pushname != 0)
+    if (pushname != NULL)
 	pushname[0] = '\0';
     yyin = fp;
     bufstart = bufptr = buf;
     _nc_curr_file_pos = 0L;
-    if (fp != 0)
+    if (fp != NULL)
 	_nc_curr_line = 0;
     _nc_curr_col = 0;
 
@@ -197,18 +197,18 @@
     int the_char;
 
     if (!yyin) {
-	if (result != 0) {
+	if (result != NULL) {
 	    FreeAndNull(result);
 	    FreeAndNull(pushname);
-	    bufptr = 0;
-	    bufstart = 0;
+	    bufptr = NULL;
+	    bufstart = NULL;
 	    allocated = 0;
 	}
 	/*
 	 * An string with an embedded null will truncate the input.  This is
 	 * intentional (we don't read binary files here).
 	 */
-	if (bufptr == 0 || *bufptr == '\0')
+	if (bufptr == NULL || *bufptr == '\0')
 	    return (EOF);
 	if (*bufptr == '\n') {
 	    _nc_curr_line++;
@@ -227,12 +227,12 @@
 
 	do {
 	    size_t used = 0;
-	    bufstart = 0;
+	    bufstart = NULL;
 	    do {
 		if (used + (LEXBUFSIZ / 4) >= allocated) {
 		    allocated += (allocated + LEXBUFSIZ);
 		    result = typeRealloc(char, allocated, result);
-		    if (result == 0)
+		    if (result == NULL)
 			return (EOF);
 		    if (bufstart)
 			bufstart = result;
@@ -254,7 +254,7 @@
 		    if (used != 0)
 			_nc_STRCAT(result, "\n", allocated);
 		}
-		if ((bufptr = bufstart) != 0) {
+		if ((bufptr = bufstart) != NULL) {
 		    used = strlen(bufptr);
 		    if (used == 0)
 			return (EOF);
@@ -407,12 +407,12 @@
     if (pushtype != NO_PUSHBACK) {
 	int retval = pushtype;
 
-	_nc_set_type(pushname != 0 ? pushname : "");
+	_nc_set_type(pushname != NULL ? pushname : "");
 	DEBUG(3, ("pushed-back token: `%s', class %d",
 		  _nc_curr_token.tk_name, pushtype));
 
 	pushtype = NO_PUSHBACK;
-	if (pushname != 0)
+	if (pushname != NULL)
 	    pushname[0] = '\0';
 
 	/* currtok wasn't altered by _nc_push_token() */
@@ -421,11 +421,11 @@
     }
 
     if (end_of_stream()) {
-	yyin = 0;
+	yyin = NULL;
 	(void) next_char();	/* frees its allocated memory */
-	if (tok_buf != 0) {
+	if (tok_buf != NULL) {
 	    if (_nc_curr_token.tk_name == tok_buf)
-		_nc_curr_token.tk_name = 0;
+		_nc_curr_token.tk_name = NULL;
 	}
 	DEBUG(3, (T_RETURN("%d"), EOF));
 	return (EOF);
@@ -439,7 +439,7 @@
     }
 
     ch = eat_escaped_newline(ch);
-    _nc_curr_token.tk_valstring = 0;
+    _nc_curr_token.tk_valstring = NULL;
 
 #ifdef TRACE
     old_line = _nc_curr_line;
@@ -475,7 +475,7 @@
 #if NCURSES_EXT_FUNCS
 	    && !(ch == '.' && _nc_disable_period)
 #endif
-	    && ((strchr) (terminfo_punct, (char) ch) == 0)) {
+	    && ((strchr) (terminfo_punct, (char) ch) == NULL)) {
 	    if (!silent)
 		_nc_warning("Illegal character (expected alphanumeric or %s) - '%s'",
 			    terminfo_punct, unctrl(UChar(ch)));
@@ -483,7 +483,7 @@
 	    goto start_token;
 	}
 
-	if (tok_buf == 0)
+	if (tok_buf == NULL)
 	    tok_buf = typeMalloc(char, TOK_BUF_SIZE);
 
 #ifdef TRACE
@@ -499,14 +499,14 @@
 	    _nc_start_line = _nc_curr_line;
 
 	    _nc_syntax = ERR;
-	    after_name = 0;
-	    after_list = 0;
+	    after_name = NULL;
+	    after_list = NULL;
 	    while ((ch = next_char()) != '\n') {
 		if (ch == EOF) {
 		    _nc_err_abort(MSG_NO_INPUTS);
 		} else if (ch == '|') {
 		    after_list = tok_ptr;
-		    if (after_name == 0)
+		    if (after_name == NULL)
 			after_name = tok_ptr;
 		} else if (ch == ':' && last_char(0) != ',') {
 		    _nc_syntax = SYN_TERMCAP;
@@ -519,7 +519,7 @@
 		     * If we did not see a '|', then we found a name with no
 		     * aliases or description.
 		     */
-		    if (after_name == 0)
+		    if (after_name == NULL)
 			break;
 		    /*
 		     * We saw a comma, but are not entirely sure this is
@@ -614,7 +614,7 @@
 	     * for following warning messages.  If there's no '|', then there
 	     * is no description.
 	     */
-	    if (after_name != 0) {
+	    if (after_name != NULL) {
 		ch = *after_name;
 		*after_name = '\0';
 		_nc_set_type(tok_buf);
@@ -625,11 +625,11 @@
 	     * Compute the boundary between the aliases and the description
 	     * field for syntax-checking purposes.
 	     */
-	    if (after_list != 0) {
+	    if (after_list != NULL) {
 		if (!silent) {
 		    if (*after_list == '\0' || strchr("|", after_list[1]) != NULL) {
 			_nc_warning("empty longname field");
-		    } else if (strchr(after_list, ' ') == 0) {
+		    } else if (strchr(after_list, ' ') == NULL) {
 			_nc_warning("older tic versions may treat the description field as an alias");
 		    }
 		}
@@ -805,7 +805,7 @@
 	type = _nc_get_token(silent);
 
     DEBUG(3, ("token: `%s', class %d",
-	      ((_nc_curr_token.tk_name != 0)
+	      ((_nc_curr_token.tk_name != NULL)
 	       ? _nc_curr_token.tk_name
 	       : "<null>"),
 	      type));
@@ -1023,12 +1023,12 @@
      * _nc_get_token() touches.
      */
     pushtype = tokclass;
-    if (pushname == 0)
+    if (pushname == NULL)
 	pushname = typeMalloc(char, MAX_NAME_SIZE + 1);
     _nc_get_type(pushname);
 
     DEBUG(3, ("pushing token: `%s', class %d",
-	      ((_nc_curr_token.tk_name != 0)
+	      ((_nc_curr_token.tk_name != NULL)
 	       ? _nc_curr_token.tk_name
 	       : "<null>"),
 	      pushtype));
@@ -1053,10 +1053,10 @@
 NCURSES_EXPORT(void)
 _nc_comp_scan_leaks(void)
 {
-    if (pushname != 0) {
+    if (pushname != NULL) {
 	FreeAndNull(pushname);
     }
-    if (tok_buf != 0) {
+    if (tok_buf != NULL) {
 	FreeAndNull(tok_buf);
     }
 }
Index: ncurses/tinfo/db_iterator.c
Prereq:  1.51 
--- ncurses-6.5-20241130+/ncurses/tinfo/db_iterator.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/db_iterator.c	2024-12-07 18:23:25.000000000 +0000
@@ -44,7 +44,7 @@
 #include <hashed_db.h>
 #endif
 
-MODULE_ID("$Id: db_iterator.c,v 1.51 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: db_iterator.c,v 1.52 2024/12/07 18:23:25 tom Exp $")
 
 #define HaveTicDirectory _nc_globals.have_tic_directory
 #define KeepTicDirectory _nc_globals.keep_tic_directory
@@ -127,12 +127,12 @@
 	const char *cached_value = my_vars[which].value;
 	bool same_value;
 
-	if ((value = getenv(name)) != 0) {
+	if ((value = getenv(name)) != NULL) {
 	    value = strdup(value);
 	}
-	same_value = ((value == 0 && cached_value == 0) ||
-		      (value != 0 &&
-		       cached_value != 0 &&
+	same_value = ((value == NULL && cached_value == NULL) ||
+		      (value != NULL &&
+		       cached_value != NULL &&
 		       strcmp(value, cached_value) == 0));
 
 	/* Set variable name to enable checks in cache_expired(). */
@@ -153,7 +153,7 @@
 static char *
 cache_getenv(const char *name, DBDIRS which)
 {
-    char *result = 0;
+    char *result = NULL;
 
     (void) update_getenv(name, which);
     if (which < dbdLAST) {
@@ -185,7 +185,7 @@
     } else {
 	DBDIRS n;
 	for (n = (DBDIRS) 0; n < dbdLAST; ++n) {
-	    if (my_vars[n].name != 0
+	    if (my_vars[n].name != NULL
 		&& update_getenv(my_vars[n].name, n)) {
 		result = TRUE;
 		break;
@@ -225,7 +225,7 @@
 	} else if (HaveTicDirectory == 0) {
 	    if (use_terminfo_vars()) {
 		const char *envp;
-		if ((envp = getenv("TERMINFO")) != 0)
+		if ((envp = getenv("TERMINFO")) != NULL)
 		    return _nc_tic_dir(envp);
 	    }
 	}
@@ -251,7 +251,7 @@
 NCURSES_EXPORT(void)
 _nc_last_db(void)
 {
-    if (my_blob != 0 && cache_expired()) {
+    if (my_blob != NULL && cache_expired()) {
 	free_cache();
     }
 }
@@ -268,14 +268,14 @@
 
     (void) offset;
     if ((int) *state < my_size
-	&& my_list != 0
-	&& my_list[*state] != 0) {
+	&& my_list != NULL
+	&& my_list[*state] != NULL) {
 	result = my_list[*state];
 	(*state)++;
     } else {
-	result = 0;
+	result = NULL;
     }
-    if (result != 0) {
+    if (result != NULL) {
 	T(("_nc_next_db %d %s", *state, result));
     }
     return result;
@@ -293,7 +293,7 @@
     /* build a blob containing all of the strings we will use for a lookup
      * table.
      */
-    if (my_blob == 0 || (cache_has_expired = cache_expired())) {
+    if (my_blob == NULL || (cache_has_expired = cache_expired())) {
 	size_t blobsize = 0;
 	const char *values[dbdLAST];
 	struct stat *my_stat;
@@ -303,7 +303,7 @@
 	    free_cache();
 
 	for (j = 0; j < dbdLAST; ++j)
-	    values[j] = 0;
+	    values[j] = NULL;
 
 	/*
 	 * This is the first item in the list, and is used only when tic is
@@ -344,13 +344,13 @@
 	}
 
 	for (j = 0; j < dbdLAST; ++j) {
-	    if (values[j] == 0)
+	    if (values[j] == NULL)
 		values[j] = "";
 	    blobsize += 2 + strlen(values[j]);
 	}
 
 	my_blob = malloc(blobsize);
-	if (my_blob != 0) {
+	if (my_blob != NULL) {
 	    *my_blob = '\0';
 	    for (j = 0; j < dbdLAST; ++j) {
 		add_to_blob(values[j], blobsize);
@@ -366,7 +366,7 @@
 	    }
 	    my_list = typeCalloc(char *, blobsize);
 	    my_stat = typeCalloc(struct stat, blobsize);
-	    if (my_list != 0 && my_stat != 0) {
+	    if (my_list != NULL && my_stat != NULL) {
 		int k = 0;
 		my_list[k++] = my_blob;
 		for (j = 0; my_blob[j] != '\0'; ++j) {
@@ -381,11 +381,11 @@
 		/*
 		 * Eliminate duplicates from the list.
 		 */
-		for (j = 0; my_list[j] != 0; ++j) {
+		for (j = 0; my_list[j] != NULL; ++j) {
 #ifdef TERMINFO
 		    if (*my_list[j] == '\0') {
 			char *my_copy = strdup(TERMINFO);
-			if (my_copy != 0)
+			if (my_copy != NULL)
 			    my_list[j] = my_copy;
 		    }
 #endif
@@ -394,7 +394,7 @@
 			if (!strcmp(my_list[j], my_list[k])) {
 			    T(("duplicate %s", my_list[j]));
 			    k = j - 1;
-			    while ((my_list[j] = my_list[j + 1]) != 0) {
+			    while ((my_list[j] = my_list[j + 1]) != NULL) {
 				++j;
 			    }
 			    j = k;
@@ -407,7 +407,7 @@
 		 * Eliminate non-existent databases, and those that happen to
 		 * be symlinked to another location.
 		 */
-		for (j = 0; my_list[j] != 0; ++j) {
+		for (j = 0; my_list[j] != NULL; ++j) {
 		    bool found = check_existence(my_list[j], &my_stat[j]);
 #if HAVE_LINK
 		    if (found) {
@@ -423,7 +423,7 @@
 		    if (!found) {
 			T(("not found %s", my_list[j]));
 			k = j;
-			while ((my_list[k] = my_list[k + 1]) != 0) {
+			while ((my_list[k] = my_list[k + 1]) != NULL) {
 			    ++k;
 			}
 			--j;
@@ -446,14 +446,14 @@
 {
     DBDIRS which;
 
-    if (my_blob != 0)
+    if (my_blob != NULL)
 	FreeAndNull(my_blob);
-    if (my_list != 0)
+    if (my_list != NULL)
 	FreeAndNull(my_list);
     for (which = 0; (int) which < dbdLAST; ++which) {
-	my_vars[which].name = 0;
+	my_vars[which].name = NULL;
 	FreeIfNeeded(my_vars[which].value);
-	my_vars[which].value = 0;
+	my_vars[which].value = NULL;
     }
     update_tic_dir(NULL);
 }
Index: ncurses/tinfo/doalloc.c
Prereq:  1.14 
--- ncurses-6.5-20241130+/ncurses/tinfo/doalloc.c	2021-04-24 23:43:39.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/doalloc.c	2024-12-07 20:05:08.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2002,2012 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: doalloc.c,v 1.14 2021/04/24 23:43:39 tom Exp $")
+MODULE_ID("$Id: doalloc.c,v 1.15 2024/12/07 20:05:08 tom Exp $")
 
 void *
 _nc_doalloc(void *oldp, size_t amount)
@@ -51,7 +51,7 @@
 	if (amount == 0) {
 	    free(oldp);
 	    newp = NULL;
-	} else if ((newp = realloc(oldp, amount)) == 0) {
+	} else if ((newp = realloc(oldp, amount)) == NULL) {
 	    free(oldp);
 	    errno = ENOMEM;	/* just in case 'free' reset */
 	}
Index: ncurses/tinfo/entries.c
Prereq:  1.37 
--- ncurses-6.5-20241130+/ncurses/tinfo/entries.c	2024-10-19 21:23:31.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/entries.c	2024-12-07 18:23:25.000000000 +0000
@@ -38,7 +38,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: entries.c,v 1.37 2024/10/19 21:23:31 tom Exp $")
+MODULE_ID("$Id: entries.c,v 1.38 2024/12/07 18:23:25 tom Exp $")
 
 /****************************************************************************
  *
@@ -61,8 +61,8 @@
  *	   _nc_head                _nc_tail
  */
 
-NCURSES_EXPORT_VAR(ENTRY *) _nc_head = 0;
-NCURSES_EXPORT_VAR(ENTRY *) _nc_tail = 0;
+NCURSES_EXPORT_VAR(ENTRY *) _nc_head = NULL;
+NCURSES_EXPORT_VAR(ENTRY *) _nc_tail = NULL;
 
 static ENTRY *
 _nc_delink_entry(ENTRY * headp, const TERMTYPE2 *const tterm)
@@ -70,12 +70,12 @@
 {
     ENTRY *ep, *last;
 
-    for (last = 0, ep = headp; ep != 0; last = ep, ep = ep->next) {
+    for (last = NULL, ep = headp; ep != NULL; last = ep, ep = ep->next) {
 	if (&(ep->tterm) == tterm) {
-	    if (last != 0) {
+	    if (last != NULL) {
 		last->next = ep->next;
 	    }
-	    if (ep->next != 0) {
+	    if (ep->next != NULL) {
 		ep->next->last = last;
 	    }
 	    if (ep == _nc_head) {
@@ -96,7 +96,7 @@
 {
     ENTRY *ep;
 
-    if ((ep = _nc_delink_entry(headp, tterm)) != 0) {
+    if ((ep = _nc_delink_entry(headp, tterm)) != NULL) {
 	free(ep);
     }
 }
@@ -107,7 +107,7 @@
 {
     (void) headp;		/* unused - _nc_head is altered here! */
 
-    while (_nc_head != 0) {
+    while (_nc_head != NULL) {
 	_nc_free_termtype2(&(_nc_head->tterm));
     }
 }
@@ -141,7 +141,7 @@
     }
     _nc_unlock_global(screen);
 #endif
-    if (TerminalOf(CURRENT_SCREEN) != 0) {
+    if (TerminalOf(CURRENT_SCREEN) != NULL) {
 	del_curterm(TerminalOf(CURRENT_SCREEN));
     }
     _nc_forget_prescr();
@@ -149,8 +149,8 @@
     _nc_comp_captab_leaks();
     _nc_comp_userdefs_leaks();
     _nc_free_entries(_nc_head);
-    _nc_get_type(0);
-    _nc_first_name(0);
+    _nc_get_type(NULL);
+    _nc_first_name(NULL);
     _nc_db_iterator_leaks();
     _nc_keyname_leaks();
 #if BROKEN_LINKER || USE_REENTRANT
@@ -160,7 +160,7 @@
 #endif
     _nc_comp_error_leaks();
 
-    if ((s = _nc_home_terminfo()) != 0)
+    if ((s = _nc_home_terminfo()) != NULL)
 	free(s);
 
 #ifdef TRACE
Index: ncurses/tinfo/getenv_num.c
Prereq:  1.9 
--- ncurses-6.5-20241130+/ncurses/tinfo/getenv_num.c	2024-07-27 19:23:59.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/getenv_num.c	2024-12-07 18:14:49.000000000 +0000
@@ -37,16 +37,16 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: getenv_num.c,v 1.9 2024/07/27 19:23:59 tom Exp $")
+MODULE_ID("$Id: getenv_num.c,v 1.10 2024/12/07 18:14:49 tom Exp $")
 
 NCURSES_EXPORT(int)
 _nc_getenv_num(const char *name)
 {
-    char *dst = 0;
+    char *dst = NULL;
     const char *src = getenv(name);
     long value;
 
-    if ((src == 0)
+    if ((src == NULL)
 	|| (value = strtol(src, &dst, 0)) < 0
 	|| (dst == src)
 	|| (*dst != '\0')
@@ -59,7 +59,7 @@
 NCURSES_EXPORT(void)
 _nc_setenv_num(const char *name, int value)
 {
-    if (name != 0 && value >= 0) {
+    if (name != NULL && value >= 0) {
 	char buffer[128];
 #if HAVE_SETENV
 	_nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer)) "%d", value);
Index: ncurses/tinfo/home_terminfo.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/ncurses/tinfo/home_terminfo.c	2024-07-27 19:23:21.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/home_terminfo.c	2024-12-07 18:14:49.000000000 +0000
@@ -38,7 +38,7 @@
 #include <curses.priv.h>
 #include <tic.h>
 
-MODULE_ID("$Id: home_terminfo.c,v 1.18 2024/07/27 19:23:21 tom Exp $")
+MODULE_ID("$Id: home_terminfo.c,v 1.19 2024/12/07 18:14:49 tom Exp $")
 
 /* ncurses extension...fall back on user's private directory */
 
@@ -47,14 +47,14 @@
 NCURSES_EXPORT(char *)
 _nc_home_terminfo(void)
 {
-    char *result = 0;
+    char *result = NULL;
 #if USE_HOME_TERMINFO
     if (use_terminfo_vars()) {
 
-	if (MyBuffer == 0) {
+	if (MyBuffer == NULL) {
 	    const char *home;
 
-	    if ((home = getenv("HOME")) != 0) {
+	    if ((home = getenv("HOME")) != NULL) {
 		size_t want = (strlen(home) + sizeof(PRIVATE_INFO));
 		TYPE_MALLOC(char, want, MyBuffer);
 		_nc_SPRINTF(MyBuffer, _nc_SLIMIT(want) PRIVATE_INFO, home);
Index: ncurses/tinfo/init_keytry.c
Prereq:  1.21 
--- ncurses-6.5-20241130+/ncurses/tinfo/init_keytry.c	2024-07-27 19:23:59.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/init_keytry.c	2024-12-07 18:14:49.000000000 +0000
@@ -30,7 +30,7 @@
 #include <curses.priv.h>
 #include <tic.h>		/* struct tinfo_fkeys */
 
-MODULE_ID("$Id: init_keytry.c,v 1.21 2024/07/27 19:23:59 tom Exp $")
+MODULE_ID("$Id: init_keytry.c,v 1.22 2024/12/07 18:14:49 tom Exp $")
 
 /*
 **      _nc_init_keytry()
@@ -74,7 +74,7 @@
      * mouse_activate() (which will call keyok()) are first called.
      */
 
-    if (sp != 0) {
+    if (sp != NULL) {
 	unsigned n;
 
 	for (n = 0; _nc_tinfo_fkeys[n].code; n++) {
@@ -95,7 +95,7 @@
 	    for (n = STRCOUNT; n < NUM_STRINGS(tp); ++n) {
 		const char *name = ExtStrname(tp, (int) n, strnames);
 		const char *value = tp->Strings[n];
-		if (name != 0
+		if (name != NULL
 		    && *name == 'k'
 		    && VALID_STRING(value)
 		    && NCURSES_SP_NAME(key_defined) (NCURSES_SP_ARGx
Index: ncurses/tinfo/lib_acs.c
Prereq:  1.50 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_acs.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_acs.c	2024-12-07 20:05:08.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2019,2020 Thomas E. Dickey                                *
+ * Copyright 2018-2020,2024 Thomas E. Dickey                                *
  * Copyright 1998-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_acs.c,v 1.50 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_acs.c,v 1.51 2024/12/07 20:05:08 tom Exp $")
 
 #if BROKEN_LINKER || USE_REENTRANT
 #define MyBuffer _nc_prescreen.real_acs_map
@@ -81,7 +81,7 @@
 NCURSES_SP_NAME(_nc_init_acs) (NCURSES_SP_DCL0)
 {
     chtype *fake_map = acs_map;
-    chtype *real_map = SP_PARM != 0 ? SP_PARM->_acs_map : fake_map;
+    chtype *real_map = SP_PARM != NULL ? SP_PARM->_acs_map : fake_map;
     int j;
 
     T(("initializing ACS map"));
@@ -183,7 +183,7 @@
      *
      * test/blue.c uses this feature.
      */
-#define PCH_KLUDGE(a,b) (a != 0 && b != 0 && !strcmp(a,b))
+#define PCH_KLUDGE(a,b) (a != NULL && b != NULL && !strcmp(a,b))
     if (PCH_KLUDGE(enter_pc_charset_mode, enter_alt_charset_mode) &&
 	PCH_KLUDGE(exit_pc_charset_mode, exit_alt_charset_mode)) {
 	size_t i;
@@ -191,7 +191,7 @@
 	    if (real_map[i] == 0) {
 		real_map[i] = (chtype) i;
 		if (real_map != fake_map) {
-		    if (SP != 0)
+		    if (SP != NULL)
 			SP->_screen_acs_map[i] = TRUE;
 		}
 	    }
@@ -210,7 +210,7 @@
 		   (int) i,
 		   _tracechar(UChar(acs_chars[i])),
 		   _tracechtype(real_map[UChar(acs_chars[i])])));
-		if (SP != 0) {
+		if (SP != NULL) {
 		    SP->_screen_acs_map[UChar(acs_chars[i])] = TRUE;
 		}
 	    }
Index: ncurses/tinfo/lib_baudrate.c
Prereq:  1.45 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_baudrate.c	2020-09-05 21:15:32.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_baudrate.c	2024-12-07 20:05:08.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -84,7 +84,7 @@
 #undef USE_OLD_TTY
 #endif /* USE_OLD_TTY */
 
-MODULE_ID("$Id: lib_baudrate.c,v 1.45 2020/09/05 21:15:32 tom Exp $")
+MODULE_ID("$Id: lib_baudrate.c,v 1.46 2024/12/07 20:05:08 tom Exp $")
 
 /*
  *	int
@@ -279,7 +279,7 @@
 #ifdef TRACE
     if (IsValidTIScreen(SP_PARM)
 	&& !NC_ISATTY(fileno((SP_PARM && SP_PARM->_ofp) ? SP_PARM->_ofp : stdout))
-	&& getenv("BAUDRATE") != 0) {
+	&& getenv("BAUDRATE") != NULL) {
 	int ret;
 	if ((ret = _nc_getenv_num("BAUDRATE")) <= 0)
 	    ret = 9600;
Index: ncurses/tinfo/lib_cur_term.c
Prereq:  1.49 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_cur_term.c	2022-05-28 17:56:55.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_cur_term.c	2024-12-07 20:05:08.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
-,* Copyright 2020-2021,2022 Thomas E. Dickey                                *
+,* Copyright 2020-2022,2024 Thomas E. Dickey                                *
  * Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -41,7 +41,7 @@
 #include <termcap.h>		/* ospeed */
 #include <tic.h>		/* VALID_STRING */
 
-MODULE_ID("$Id: lib_cur_term.c,v 1.49 2022/05/28 17:56:55 tom Exp $")
+MODULE_ID("$Id: lib_cur_term.c,v 1.50 2024/12/07 20:05:08 tom Exp $")
 
 #undef CUR
 #define CUR TerminalType(termp).
@@ -74,7 +74,7 @@
 }
 
 #else
-NCURSES_EXPORT_VAR(TERMINAL *) cur_term = 0;
+NCURSES_EXPORT_VAR(TERMINAL *) cur_term = NULL;
 #endif
 
 NCURSES_EXPORT(TERMINAL *)
@@ -93,7 +93,7 @@
 #else
     cur_term = termp;
 #endif
-    if (termp != 0) {
+    if (termp != NULL) {
 #ifdef USE_TERM_DRIVER
 	TERMINAL_CONTROL_BLOCK *TCB = (TERMINAL_CONTROL_BLOCK *) termp;
 	ospeed = (NCURSES_OSPEED) _nc_ospeed(termp->_baudrate);
@@ -134,7 +134,7 @@
 
     T((T_CALLED("del_curterm(%p, %p)"), (void *) SP_PARM, (void *) termp));
 
-    if (termp != 0) {
+    if (termp != NULL) {
 #ifdef USE_TERM_DRIVER
 	TERMINAL_CONTROL_BLOCK *TCB = (TERMINAL_CONTROL_BLOCK *) termp;
 #endif
@@ -155,11 +155,11 @@
 #endif
 	_nc_free_termtype2(&TerminalType(termp));
 	if (termp == cur)
-	    NCURSES_SP_NAME(set_curterm) (NCURSES_SP_ARGx 0);
+	    NCURSES_SP_NAME(set_curterm) (NCURSES_SP_ARGx NULL);
 
 	FreeIfNeeded(termp->_termname);
 #if USE_HOME_TERMINFO
-	if (_nc_globals.home_terminfo != 0) {
+	if (_nc_globals.home_terminfo != NULL) {
 	    FreeAndNull(_nc_globals.home_terminfo);
 	}
 #endif
Index: ncurses/tinfo/lib_data.c
Prereq:  1.89 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_data.c	2024-02-24 18:11:38.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_data.c	2024-12-07 18:23:25.000000000 +0000
@@ -43,7 +43,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_data.c,v 1.89 2024/02/24 18:11:38 tom Exp $")
+MODULE_ID("$Id: lib_data.c,v 1.90 2024/12/07 18:23:25 tom Exp $")
 
 /*
  * OS/2's native linker complains if we don't initialize public data when
@@ -66,12 +66,12 @@
     return CURRENT_SCREEN ? NewScreen(CURRENT_SCREEN) : 0;
 }
 #else
-NCURSES_EXPORT_VAR(WINDOW *) stdscr = 0;
-NCURSES_EXPORT_VAR(WINDOW *) curscr = 0;
-NCURSES_EXPORT_VAR(WINDOW *) newscr = 0;
+NCURSES_EXPORT_VAR(WINDOW *) stdscr = NULL;
+NCURSES_EXPORT_VAR(WINDOW *) curscr = NULL;
+NCURSES_EXPORT_VAR(WINDOW *) newscr = NULL;
 #endif
 
-NCURSES_EXPORT_VAR(SCREEN *) _nc_screen_chain = 0;
+NCURSES_EXPORT_VAR(SCREEN *) _nc_screen_chain = NULL;
 
 /*
  * The variable 'SP' will be defined as a function on systems that cannot link
@@ -129,7 +129,7 @@
 
     FALSE,			/* have_tic_directory */
     FALSE,			/* keep_tic_directory */
-    0,				/* tic_directory */
+    NULL,			/* tic_directory */
 
     NULL,			/* dbi_list */
     0,				/* dbi_size */
@@ -150,11 +150,11 @@
     0,				/* tgetent_sequence */
     0,				/* terminal_count */
 
-    0,				/* dbd_blob */
-    0,				/* dbd_list */
+    NULL,			/* dbd_blob */
+    NULL,			/* dbd_list */
     0,				/* dbd_size */
     0,				/* dbd_time */
-    { { 0, 0 } },		/* dbd_vars */
+    { { NULL, NULL } },		/* dbd_vars */
 
 #if HAVE_TSEARCH
     NULL,			/* cached_tparm */
@@ -230,7 +230,7 @@
 #define STACK_FRAME_0s	{ STACK_FRAME_0 }
 #define NUM_VARS_0s	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
 
-#define RIPOFF_0	{ 0,0,0 }
+#define RIPOFF_0	{ NULL,0,NULL }
 #define RIPOFF_0s	{ RIPOFF_0 }
 
 NCURSES_EXPORT_VAR(NCURSES_PRESCREEN) _nc_prescreen = {
@@ -258,7 +258,7 @@
     },
     NULL,			/* saved_tty */
     FALSE,			/* use_tioctl */
-    0,				/* _outch */
+    NULL,			/* _outch */
 #ifndef USE_SP_RIPOFF
     RIPOFF_0s,			/* ripoff */
     NULL,			/* rsp */
@@ -291,9 +291,9 @@
 NCURSES_EXPORT(SCREEN *)
 _nc_screen_of(WINDOW *win)
 {
-    SCREEN *sp = 0;
+    SCREEN *sp = NULL;
 
-    if (win != 0) {
+    if (win != NULL) {
 	sp = WINDOW_EXT(win, screen);
     }
     return (sp);
Index: ncurses/tinfo/lib_kernel.c
Prereq:  1.36 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_kernel.c	2023-06-10 13:29:06.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_kernel.c	2024-12-07 20:05:08.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2009,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -49,7 +49,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_kernel.c,v 1.36 2023/06/10 13:29:06 tom Exp $")
+MODULE_ID("$Id: lib_kernel.c,v 1.37 2024/12/07 20:05:08 tom Exp $")
 
 #ifdef TERMIOS
 static int
@@ -89,7 +89,7 @@
 
     T((T_CALLED("erasechar(%p)"), (void *) SP_PARM));
 
-    if (termp != 0) {
+    if (termp != NULL) {
 #ifdef TERMIOS
 	result = termp->Ottyb.c_cc[VERASE];
 	if (result == _nc_vdisable())
@@ -126,7 +126,7 @@
 
     T((T_CALLED("killchar(%p)"), (void *) SP_PARM));
 
-    if (termp != 0) {
+    if (termp != NULL) {
 #ifdef TERMIOS
 	result = termp->Ottyb.c_cc[VKILL];
 	if (result == _nc_vdisable())
@@ -177,7 +177,7 @@
 {
     T((T_CALLED("flushinp(%p)"), (void *) SP_PARM));
 
-    if (SP_PARM != 0) {
+    if (SP_PARM != NULL) {
 	if (NC_ISATTY(SP_PARM->_ifd))
 	    flush_input(SP_PARM->_ifd);
 	else if (NC_ISATTY(SP_PARM->_ofd))
Index: ncurses/tinfo/lib_options.c
Prereq:  1.84 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_options.c	2024-11-23 19:17:25.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_options.c	2024-12-07 18:24:47.000000000 +0000
@@ -47,7 +47,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_options.c,v 1.84 2024/11/23 19:17:25 tom Exp $")
+MODULE_ID("$Id: lib_options.c,v 1.85 2024/12/07 18:24:47 tom Exp $")
 
 NCURSES_EXPORT(int)
 idlok(WINDOW *win, bool flag)
@@ -57,7 +57,7 @@
 
     if (win) {
 	SCREEN *sp = _nc_screen_of(win);
-	if (sp != 0
+	if (sp != NULL
 #ifdef USE_TERM_DRIVER
 	    && IsTermInfo(sp)
 #endif
@@ -158,14 +158,14 @@
 meta(WINDOW *win GCC_UNUSED, bool flag)
 {
     int result = ERR;
-    SCREEN *sp = (win == 0) ? CURRENT_SCREEN : _nc_screen_of(win);
+    SCREEN *sp = (win == NULL) ? CURRENT_SCREEN : _nc_screen_of(win);
 
     /* Ok, we stay relaxed and don't signal an error if win is NULL */
     T((T_CALLED("meta(%p,%d)"), (void *) win, flag));
 
     /* Ok, we stay relaxed and don't signal an error if win is NULL */
 
-    if (sp != 0) {
+    if (sp != NULL) {
 	sp->_use_meta = flag;
 #ifdef USE_TERM_DRIVER
 	if (IsTermInfo(sp)) {
@@ -195,7 +195,7 @@
     int code = ERR;
     T((T_CALLED("curs_set(%p,%d)"), (void *) SP_PARM, vis));
 
-    if (SP_PARM != 0 && vis >= 0 && vis <= 2) {
+    if (SP_PARM != NULL && vis >= 0 && vis <= 2) {
 	int cursor = SP_PARM->_cursor;
 	if (vis == cursor) {
 	    code = cursor;
@@ -269,7 +269,7 @@
 static int
 has_key_internal(int keycode, TRIES * tp)
 {
-    if (tp == 0)
+    if (tp == NULL)
 	return (FALSE);
     else if (tp->value == keycode)
 	return (TRUE);
@@ -290,7 +290,7 @@
 NCURSES_SP_NAME(has_key) (NCURSES_SP_DCLx int keycode)
 {
     T((T_CALLED("has_key(%p,%d)"), (void *) SP_PARM, keycode));
-    returnCode(SP != 0 ? has_key_internal(keycode, SP_PARM->_keytry) : FALSE);
+    returnCode(SP != NULL ? has_key_internal(keycode, SP_PARM->_keytry) : FALSE);
 }
 
 #if NCURSES_SP_FUNCS
@@ -334,7 +334,7 @@
 {
     int rc = ERR;
 
-    if (sp != 0) {
+    if (sp != NULL) {
 #ifdef USE_PTHREADS
 	/*
 	 * We might have this situation in a multithreaded application that
Index: ncurses/tinfo/lib_print.c
Prereq:  1.33 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_print.c	2024-08-31 10:46:01.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_print.c	2024-12-07 18:05:04.000000000 +0000
@@ -40,7 +40,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_print.c,v 1.33 2024/08/31 10:46:01 Rafael.Kitover Exp $")
+MODULE_ID("$Id: lib_print.c,v 1.34 2024/12/07 18:05:04 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(mcprint) (NCURSES_SP_DCLx char *data, int len)
@@ -72,8 +72,8 @@
 
     need = onsize + (size_t) len + offsize;
 
-    if (switchon == 0
-	|| (mybuf = typeMalloc(char, need + 1)) == 0) {
+    if (switchon == NULL
+	|| (mybuf = typeMalloc(char, need + 1)) == NULL) {
 	free(mybuf);
 	errno = ENOMEM;
 	return (ERR);
Index: ncurses/tinfo/lib_raw.c
Prereq:  1.31 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_raw.c	2024-05-25 20:18:20.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_raw.c	2024-12-07 18:24:47.000000000 +0000
@@ -50,7 +50,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_raw.c,v 1.31 2024/05/25 20:18:20 Branden.Robinson Exp $")
+MODULE_ID("$Id: lib_raw.c,v 1.32 2024/12/07 18:24:47 tom Exp $")
 
 #if HAVE_SYS_TERMIO_H
 #include <sys/termio.h>		/* needed for ISC */
@@ -85,7 +85,7 @@
     TERMINAL *termp;
 
     T((T_CALLED("raw(%p)"), (void *) SP_PARM));
-    if ((termp = TerminalOf(SP_PARM)) != 0) {
+    if ((termp = TerminalOf(SP_PARM)) != NULL) {
 	TTY buf;
 
 	BEFORE("raw");
@@ -141,7 +141,7 @@
     TERMINAL *termp;
 
     T((T_CALLED("cbreak(%p)"), (void *) SP_PARM));
-    if ((termp = TerminalOf(SP_PARM)) != 0) {
+    if ((termp = TerminalOf(SP_PARM)) != NULL) {
 	TTY buf;
 
 	BEFORE("cbreak");
@@ -185,7 +185,7 @@
     TERMINAL *termp;
 
     T((T_CALLED("qiflush(%p)"), (void *) SP_PARM));
-    if ((termp = TerminalOf(SP_PARM)) != 0) {
+    if ((termp = TerminalOf(SP_PARM)) != NULL) {
 	TTY buf;
 	int result;
 
@@ -220,7 +220,7 @@
     TERMINAL *termp;
 
     T((T_CALLED("noraw(%p)"), (void *) SP_PARM));
-    if ((termp = TerminalOf(SP_PARM)) != 0) {
+    if ((termp = TerminalOf(SP_PARM)) != NULL) {
 	TTY buf;
 
 	BEFORE("noraw");
@@ -275,7 +275,7 @@
     TERMINAL *termp;
 
     T((T_CALLED("nocbreak(%p)"), (void *) SP_PARM));
-    if ((termp = TerminalOf(SP_PARM)) != 0) {
+    if ((termp = TerminalOf(SP_PARM)) != NULL) {
 	TTY buf;
 
 	BEFORE("nocbreak");
@@ -316,7 +316,7 @@
     TERMINAL *termp;
 
     T((T_CALLED("noqiflush(%p)"), (void *) SP_PARM));
-    if ((termp = TerminalOf(SP_PARM)) != 0) {
+    if ((termp = TerminalOf(SP_PARM)) != NULL) {
 	TTY buf;
 	int result;
 
@@ -354,10 +354,10 @@
     TERMINAL *termp;
 
     T((T_CALLED("intrflush(%p,%d)"), (void *) SP_PARM, flag));
-    if (SP_PARM == 0)
+    if (SP_PARM == NULL)
 	returnCode(ERR);
 
-    if ((termp = TerminalOf(SP_PARM)) != 0) {
+    if ((termp = TerminalOf(SP_PARM)) != NULL) {
 	TTY buf;
 
 	BEFORE("intrflush");
Index: ncurses/tinfo/lib_setup.c
Prereq:  1.246 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_setup.c	2024-11-23 18:32:54.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_setup.c	2024-12-07 20:21:01.000000000 +0000
@@ -49,7 +49,7 @@
 #include <locale.h>
 #endif
 
-MODULE_ID("$Id: lib_setup.c,v 1.246 2024/11/23 18:32:54 tom Exp $")
+MODULE_ID("$Id: lib_setup.c,v 1.247 2024/12/07 20:21:01 tom Exp $")
 
 /****************************************************************************
  *
@@ -533,7 +533,7 @@
 	    errno = 0;
 	    do {
 		if (ioctl(cur_term->Filedes, IOCTL_WINSIZE, &size) >= 0) {
-		    *linep = ((sp != 0 && sp->_filtered)
+		    *linep = ((sp != NULL && sp->_filtered)
 			      ? 1
 			      : WINSIZE_ROWS(size));
 		    *colp = WINSIZE_COLS(size);
@@ -553,7 +553,8 @@
 		/*
 		 * If environment variables are used, update them.
 		 */
-		if ((sp == 0 || !sp->_filtered) && _nc_getenv_num("LINES") > 0) {
+		if ((sp == NULL || !sp->_filtered) &&
+		    _nc_getenv_num("LINES") > 0) {
 		    _nc_setenv_num("LINES", *linep);
 		}
 		if (_nc_getenv_num("COLUMNS") > 0) {
@@ -636,17 +637,17 @@
     int old_cols = columns;
 #endif
 
-    if (sp != 0) {
+    if (sp != NULL) {
 	TINFO_GET_SIZE(sp, sp->_term, &new_lines, &new_cols);
 	/*
 	 * See is_term_resized() and resizeterm().
 	 * We're doing it this way because those functions belong to the upper
 	 * ncurses library, while this resides in the lower terminfo library.
 	 */
-	if (sp->_resize != 0) {
+	if (sp->_resize != NULL) {
 	    if ((new_lines != old_lines) || (new_cols != old_cols)) {
 		sp->_resize(NCURSES_SP_ARGx new_lines, new_cols);
-	    } else if (sp->_sig_winch && (sp->_ungetch != 0)) {
+	    } else if (sp->_sig_winch && (sp->_ungetch != NULL)) {
 		sp->_ungetch(SP_PARM, KEY_RESIZE);	/* so application can know this */
 	    }
 	    sp->_sig_winch = FALSE;
@@ -708,7 +709,7 @@
      * since it is fairly common for developers to set the C compiler
      * name as an environment variable - using the same symbol.
      */
-    if ((tmp = getenv("CC")) != 0 && strlen(tmp) == 1) {
+    if ((tmp = getenv("CC")) != NULL && strlen(tmp) == 1) {
 	unsigned i;
 	char CC = *tmp;
 
@@ -736,7 +737,7 @@
      * This is preferable to using getenv() since it ensures that we are using
      * the locale which was actually initialized by the application.
      */
-    env = setlocale(LC_CTYPE, 0);
+    env = setlocale(LC_CTYPE, NULL);
 #else
     if (((env = getenv("LANG")) != 0 && *env != '\0')
 	|| ((env = getenv("LC_CTYPE")) != 0 && *env != '\0')
@@ -778,8 +779,8 @@
     return result;
 }
 
-#define CONTROL_N(s) ((s) != 0 && strstr(s, "\016") != 0)
-#define CONTROL_O(s) ((s) != 0 && strstr(s, "\017") != 0)
+#define CONTROL_N(s) ((s) != NULL && strstr(s, "\016") != NULL)
+#define CONTROL_O(s) ((s) != NULL && strstr(s, "\017") != NULL)
 
 /*
  * Check for known broken cases where a UTF-8 locale breaks the alternate
@@ -794,17 +795,17 @@
     int result = 0;
 
     T((T_CALLED("_nc_locale_breaks_acs:%d"), result));
-    if (getenv(env_name) != 0) {
+    if (getenv(env_name) != NULL) {
 	result = _nc_getenv_num(env_name);
     } else if ((value = tigetnum("U8")) >= 0) {
 	result = value;		/* use extension feature */
-    } else if ((env = getenv("TERM")) != 0) {
+    } else if ((env = getenv("TERM")) != NULL) {
 	if (strstr(env, "linux")) {
 	    result = 1;		/* always broken */
-	} else if (strstr(env, "screen") != 0
-		   && ((env = getenv("TERMCAP")) != 0
-		       && strstr(env, "screen") != 0)
-		   && strstr(env, "hhII00") != 0) {
+	} else if (strstr(env, "screen") != NULL
+		   && ((env = getenv("TERMCAP")) != NULL
+		       && strstr(env, "screen") != NULL)
+		   && strstr(env, "hhII00") != NULL) {
 	    if (CONTROL_N(enter_alt_charset_mode) ||
 		CONTROL_O(enter_alt_charset_mode) ||
 		CONTROL_N(set_attributes) ||
@@ -827,7 +828,7 @@
     TERMINAL_CONTROL_BLOCK *TCB = 0;
 #endif
     TERMINAL *termp;
-    SCREEN *sp = 0;
+    SCREEN *sp = NULL;
     char *myname;
     int code = ERR;
 
@@ -847,7 +848,7 @@
     T((T_CALLED("setupterm(%s,%d,%p)"), _nc_visbuf(tname), Filedes, (void *) errret));
 #endif
 
-    if (tname == 0) {
+    if (tname == NULL) {
 	tname = getenv("TERM");
 #if defined(EXP_WIN32_DRIVER)
 	if (!VALID_TERM_ENV(tname, NO_TERMINAL)) {
@@ -902,9 +903,9 @@
      * properly with this feature).
      */
     if (reuse
-	&& (termp != 0)
+	&& (termp != NULL)
 	&& termp->Filedes == Filedes
-	&& termp->_termname != 0
+	&& termp->_termname != NULL
 	&& !strcmp(termp->_termname, myname)
 	&& _nc_name_match(TerminalType(termp).term_names, myname, "|")) {
 	T(("reusing existing terminal information and mode-settings"));
@@ -923,7 +924,7 @@
 
 	termp = typeCalloc(TERMINAL, 1);
 #endif
-	if (termp == 0) {
+	if (termp == NULL) {
 	    ret_error1(TGETENT_ERR,
 		       "Not enough memory to create terminal structure.\n",
 		       myname, free(myname));
@@ -1129,10 +1130,10 @@
     T((T_CALLED("new_prescr()")));
 
     _nc_lock_global(screen);
-    if ((sp = _nc_find_prescr()) == 0) {
+    if ((sp = _nc_find_prescr()) == NULL) {
 	sp = _nc_alloc_screen_sp();
 	T(("_nc_alloc_screen_sp %p", (void *) sp));
-	if (sp != 0) {
+	if (sp != NULL) {
 #ifdef USE_PTHREADS
 	    PRESCREEN_LIST *p = typeCalloc(PRESCREEN_LIST, 1);
 	    if (p != 0) {
@@ -1151,7 +1152,7 @@
 	    sp->_no_padding = _nc_prescreen._no_padding;
 #endif
 	    sp->slk_format = 0;
-	    sp->_slk = 0;
+	    sp->_slk = NULL;
 	    sp->_prescreen = TRUE;
 	    SP_PRE_INIT(sp);
 #if USE_REENTRANT
Index: ncurses/tinfo/lib_termcap.c
Prereq:  1.90 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_termcap.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_termcap.c	2024-12-07 18:26:04.000000000 +0000
@@ -49,10 +49,10 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_termcap.c,v 1.90 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: lib_termcap.c,v 1.91 2024/12/07 18:26:04 tom Exp $")
 
-NCURSES_EXPORT_VAR(char *) UP = 0;
-NCURSES_EXPORT_VAR(char *) BC = 0;
+NCURSES_EXPORT_VAR(char *) UP = NULL;
+NCURSES_EXPORT_VAR(char *) BC = NULL;
 
 #define MyCache  _nc_globals.tgetent_cache
 #define CacheInx _nc_globals.tgetent_index
@@ -125,18 +125,18 @@
 	bool same_result = (MyCache[n].last_used && MyCache[n].last_bufp == bufp);
 	if (same_result) {
 	    CacheInx = n;
-	    if (FIX_SGR0 != 0) {
+	    if (FIX_SGR0 != NULL) {
 		FreeAndNull(FIX_SGR0);
 	    }
 	    /*
 	     * Also free the terminfo data that we loaded (much bigger leak).
 	     */
-	    if (LAST_TRM != 0 && LAST_TRM != TerminalOf(SP_PARM)) {
+	    if (LAST_TRM != NULL && LAST_TRM != TerminalOf(SP_PARM)) {
 		const TERMINAL *trm = LAST_TRM;
 		NCURSES_SP_NAME(del_curterm) (NCURSES_SP_ARGx LAST_TRM);
 		for (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx)
 		    if (LAST_TRM == trm)
-			LAST_TRM = 0;
+			LAST_TRM = NULL;
 		CacheInx = n;
 	    }
 	    found_cache = TRUE;
@@ -157,13 +157,13 @@
 	LAST_TRM = TerminalOf(SP_PARM);
 	LAST_SEQ = ++CacheSeq;
     } else {
-	LAST_TRM = 0;
+	LAST_TRM = NULL;
     }
 
     PC = 0;
-    UP = 0;
-    BC = 0;
-    FIX_SGR0 = 0;		/* don't free it - application may still use */
+    UP = NULL;
+    BC = NULL;
+    FIX_SGR0 = NULL;		/* don't free it - application may still use */
 
     if (rc == 1) {
 
@@ -180,12 +180,12 @@
 	    BC = backspace_if_not_bs;
 
 	if ((FIX_SGR0 = _nc_trim_sgr0(&TerminalType(TerminalOf(SP_PARM))))
-	    != 0) {
+	    != NULL) {
 	    if (!strcmp(FIX_SGR0, exit_attribute_mode)) {
 		if (FIX_SGR0 != exit_attribute_mode) {
 		    free(FIX_SGR0);
 		}
-		FIX_SGR0 = 0;
+		FIX_SGR0 = NULL;
 	    }
 	}
 	LAST_BUF = bufp;
@@ -246,7 +246,7 @@
 	int j = -1;
 
 	entry_ptr = _nc_find_type_entry(id, BOOLEAN, TRUE);
-	if (entry_ptr != 0) {
+	if (entry_ptr != NULL) {
 	    j = entry_ptr->nte_index;
 	}
 #if NCURSES_XNAMES
@@ -298,7 +298,7 @@
 	int j = -1;
 
 	entry_ptr = _nc_find_type_entry(id, NUMBER, TRUE);
-	if (entry_ptr != 0) {
+	if (entry_ptr != NULL) {
 	    j = entry_ptr->nte_index;
 	}
 #if NCURSES_XNAMES
@@ -350,7 +350,7 @@
 	int j = -1;
 
 	entry_ptr = _nc_find_type_entry(id, STRING, TRUE);
-	if (entry_ptr != 0) {
+	if (entry_ptr != NULL) {
 	    j = entry_ptr->nte_index;
 	}
 #if NCURSES_XNAMES
@@ -371,12 +371,12 @@
 	    /* setupterm forces canceled strings to null */
 	    if (VALID_STRING(result)) {
 		if (result == exit_attribute_mode
-		    && FIX_SGR0 != 0) {
+		    && FIX_SGR0 != NULL) {
 		    result = FIX_SGR0;
 		    TR(TRACE_DATABASE, ("altered to : %s", _nc_visbuf(result)));
 		}
-		if (area != 0
-		    && *area != 0) {
+		if (area != NULL
+		    && *area != NULL) {
 		    _nc_STRCPY(*area, result, 1024);
 		    result = *area;
 		    *area += strlen(*area) + 1;
@@ -401,13 +401,13 @@
 NCURSES_EXPORT(void)
 _nc_tgetent_leak(const TERMINAL *const termp)
 {
-    if (termp != 0) {
+    if (termp != NULL) {
 	int num;
 	for (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx) {
 	    if (LAST_TRM == termp) {
 		FreeAndNull(FIX_SGR0);
-		if (LAST_TRM != 0) {
-		    LAST_TRM = 0;
+		if (LAST_TRM != NULL) {
+		    LAST_TRM = NULL;
 		}
 		break;
 	    }
@@ -420,7 +420,7 @@
 {
     int num;
     for (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx) {
-	if (LAST_TRM != 0) {
+	if (LAST_TRM != NULL) {
 	    del_curterm(LAST_TRM);
 	    _nc_tgetent_leak(LAST_TRM);
 	}
Index: ncurses/tinfo/lib_termname.c
Prereq:  1.13 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_termname.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_termname.c	2024-12-07 20:05:27.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2003,2009 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -29,17 +29,17 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_termname.c,v 1.13 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_termname.c,v 1.14 2024/12/07 20:05:27 tom Exp $")
 
 NCURSES_EXPORT(char *)
 NCURSES_SP_NAME(termname) (NCURSES_SP_DCL0)
 {
-    char *name = 0;
+    char *name = NULL;
 
     T((T_CALLED("termname(%p)"), (void *) SP_PARM));
 
 #if NCURSES_SP_FUNCS
-    if (TerminalOf(SP_PARM) != 0) {
+    if (TerminalOf(SP_PARM) != NULL) {
 	name = TerminalOf(SP_PARM)->_termname;
     }
 #else
Index: ncurses/tinfo/lib_ti.c
Prereq:  1.34 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_ti.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_ti.c	2024-12-07 20:06:49.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018,2020 Thomas E. Dickey                                     *
+ * Copyright 2018-2020,2024 Thomas E. Dickey                                *
  * Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -37,7 +37,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: lib_ti.c,v 1.34 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_ti.c,v 1.35 2024/12/07 20:06:49 tom Exp $")
 
 #if 0
 static bool
@@ -63,7 +63,7 @@
 	int j = -1;
 
 	entry_ptr = _nc_find_type_entry(str, BOOLEAN, FALSE);
-	if (entry_ptr != 0) {
+	if (entry_ptr != NULL) {
 	    j = entry_ptr->nte_index;
 	}
 #if NCURSES_XNAMES
@@ -108,7 +108,7 @@
 	int j = -1;
 
 	entry_ptr = _nc_find_type_entry(str, NUMBER, FALSE);
-	if (entry_ptr != 0) {
+	if (entry_ptr != NULL) {
 	    j = entry_ptr->nte_index;
 	}
 #if NCURSES_XNAMES
@@ -155,7 +155,7 @@
 	int j = -1;
 
 	entry_ptr = _nc_find_type_entry(str, STRING, FALSE);
-	if (entry_ptr != 0) {
+	if (entry_ptr != NULL) {
 	    j = entry_ptr->nte_index;
 	}
 #if NCURSES_XNAMES
Index: ncurses/tinfo/lib_tparm.c
Prereq:  1.154 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_tparm.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_tparm.c	2024-12-07 18:26:59.000000000 +0000
@@ -53,7 +53,7 @@
 #include <ctype.h>
 #include <tic.h>
 
-MODULE_ID("$Id: lib_tparm.c,v 1.154 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: lib_tparm.c,v 1.155 2024/12/07 18:26:59 tom Exp $")
 
 /*
  *	char *
@@ -343,7 +343,7 @@
 #define spop(tps) \
     ((TPS(stack_ptr)-- > 0) \
      ? ((!TPS(stack)[TPS(stack_ptr)].num_type \
-        && TPS(stack)[TPS(stack_ptr)].data.str != 0) \
+        && TPS(stack)[TPS(stack_ptr)].data.str != NULL) \
          ? TPS(stack)[TPS(stack_ptr)].data.str \
          : dummy) \
      : (tparm_error(tps, "spop: stack underflow"), \
@@ -361,7 +361,7 @@
 parse_format(const char *s, char *format, int *len)
 {
     *len = 0;
-    if (format != 0) {
+    if (format != NULL) {
 	bool done = FALSE;
 	bool allowminus = FALSE;
 	bool dot = FALSE;
@@ -475,13 +475,13 @@
     int level = -1;
     const char *cp = string;
 
-    if (cp == 0)
+    if (cp == NULL)
 	return 0;
 
     if ((len2 = strlen(cp)) + 2 > TPS(fmt_size)) {
 	TPS(fmt_size) += len2 + 2;
 	TPS(fmt_buff) = typeRealloc(char, TPS(fmt_size), TPS(fmt_buff));
-	if (TPS(fmt_buff) == 0)
+	if (TPS(fmt_buff) == NULL)
 	    return 0;
     }
 
@@ -616,14 +616,14 @@
 	void *ft;
 
 	result->format = string;
-	if ((ft = tfind(result, &MyCache, cmp_format)) != 0) {
+	if ((ft = tfind(result, &MyCache, cmp_format)) != NULL) {
 	    size_t len2;
 	    fs = *(TPARM_DATA **) ft;
 	    *result = *fs;
 	    if ((len2 = strlen(string)) + 2 > TPS(fmt_size)) {
 		TPS(fmt_size) += len2 + 2;
 		TPS(fmt_buff) = typeRealloc(char, TPS(fmt_size), TPS(fmt_buff));
-		if (TPS(fmt_buff) == 0)
+		if (TPS(fmt_buff) == NULL)
 		    return ERR;
 	    }
 	} else
@@ -637,7 +637,7 @@
 	    result->num_parsed = _nc_tparm_analyze(term, string,
 						   result->p_is_s,
 						   &(result->num_popped));
-	    if (TPS(fmt_buff) == 0) {
+	    if (TPS(fmt_buff) == NULL) {
 		TR(TRACE_CALLS, ("%s: error in analysis", TPS(tname)));
 		rc = ERR;
 	    } else {
@@ -654,10 +654,10 @@
 			result->tparm_type |= (1 << n);
 		}
 #if HAVE_TSEARCH
-		if ((fs = typeCalloc(TPARM_DATA, 1)) != 0) {
+		if ((fs = typeCalloc(TPARM_DATA, 1)) != NULL) {
 		    *fs = *result;
-		    if ((fs->format = strdup(string)) != 0) {
-			if (tsearch(fs, &MyCache, cmp_format) != 0) {
+		    if ((fs->format = strdup(string)) != NULL) {
+			if (tsearch(fs, &MyCache, cmp_format) != NULL) {
 			    ++MyCount;
 			} else {
 			    free(fs);
@@ -690,9 +690,9 @@
     int i;
 
     for (i = 0; i < data->num_actual; i++) {
-	if (data->p_is_s[i] != 0) {
+	if (data->p_is_s[i] != NULL) {
 	    char *value = va_arg(ap, char *);
-	    if (value == 0)
+	    if (value == NULL)
 		value = dummy;
 	    data->p_is_s[i] = value;
 	    data->param[i] = 0;
@@ -740,7 +740,7 @@
     if (USE_TRACEF(TRACE_CALLS)) {
 	int i;
 	for (i = 0; i < data->num_actual; i++) {
-	    if (data->p_is_s[i] != 0) {
+	    if (data->p_is_s[i] != NULL) {
 		save_text(tps, ", %s", _nc_visbuf(data->p_is_s[i]), 0);
 	    } else if ((long) data->param[i] > MAX_OF_TYPE(NCURSES_INT2) ||
 		       (long) data->param[i] < 0) {
@@ -1003,12 +1003,12 @@
 		 */
 		if (!incremented_two) {
 		    incremented_two = TRUE;
-		    if (data->p_is_s[0] == 0) {
+		    if (data->p_is_s[0] == NULL) {
 			data->param[0]++;
 			if (termcap_hack)
 			    TPS(stack)[0].data.num = (int) data->param[0];
 		    }
-		    if (data->p_is_s[1] == 0) {
+		    if (data->p_is_s[1] == NULL) {
 			data->param[1]++;
 			if (termcap_hack)
 			    TPS(stack)[1].data.num = (int) data->param[1];
Index: ncurses/tinfo/lib_tputs.c
Prereq:  1.113 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_tputs.c	2024-09-14 23:11:32.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_tputs.c	2024-12-07 21:04:53.000000000 +0000
@@ -52,7 +52,7 @@
 #include <termcap.h>		/* ospeed */
 #include <tic.h>
 
-MODULE_ID("$Id: lib_tputs.c,v 1.113 2024/09/14 23:11:32 tom Exp $")
+MODULE_ID("$Id: lib_tputs.c,v 1.115 2024/12/07 21:04:53 tom Exp $")
 
 NCURSES_EXPORT_VAR(char) PC = 0;              /* used by termcap library */
 NCURSES_EXPORT_VAR(NCURSES_OSPEED) ospeed = 0;        /* used by termcap library */
@@ -63,7 +63,7 @@
 NCURSES_EXPORT(void)
 _nc_set_no_padding(SCREEN *sp)
 {
-    bool no_padding = (getenv("NCURSES_NO_PADDING") != 0);
+    bool no_padding = (getenv("NCURSES_NO_PADDING") != NULL);
 
     if (sp)
 	sp->_no_padding = no_padding;
@@ -124,7 +124,7 @@
 NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_DCL0)
 {
     T((T_CALLED("_nc_flush(%p)"), (void *) SP_PARM));
-    if (SP_PARM != 0 && SP_PARM->_ofd >= 0) {
+    if (SP_PARM != NULL && SP_PARM->_ofd >= 0) {
 	TR(TRACE_CHARPUT, ("ofd:%d inuse:%lu buffer:%p",
 			   SP_PARM->_ofd,
 			   (unsigned long) SP_PARM->out_inuse,
@@ -149,7 +149,7 @@
 		    break;	/* an error we can not recover from */
 		}
 	    }
-	} else if (SP_PARM->out_buffer == 0) {
+	} else if (SP_PARM->out_buffer == NULL) {
 	    TR(TRACE_CHARPUT, ("flushing stdout/stderr"));
 	    fflush(stdout);
 	    fflush(stderr);
@@ -159,7 +159,7 @@
 	fflush(stdout);
 	fflush(stderr);
     }
-    if (SP_PARM != 0)
+    if (SP_PARM != NULL)
 	SP_PARM->out_inuse = 0;
     returnVoid;
 }
@@ -180,8 +180,8 @@
     COUNT_OUTCHARS(1);
 
     if (HasTInfoTerminal(SP_PARM)
-	&& SP_PARM != 0) {
-	if (SP_PARM->out_buffer != 0) {
+	&& SP_PARM != NULL) {
+	if (SP_PARM->out_buffer != NULL) {
 	    if (SP_PARM->out_inuse + 1 >= SP_PARM->out_limit)
 		NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);
 	    SP_PARM->out_buffer[SP_PARM->out_inuse++] = (char) ch;
@@ -259,7 +259,7 @@
 {
     int rc = ERR;
 
-    if (string != 0) {
+    if (string != NULL) {
 	TPUTS_TRACE(name);
 	rc = NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx
 				     string, 1, NCURSES_SP_NAME(_nc_outch));
@@ -314,10 +314,10 @@
     if (!VALID_STRING(string))
 	return ERR;
 
-    if (SP_PARM != 0 && HasTInfoTerminal(SP_PARM)) {
+    if (SP_PARM != NULL && HasTInfoTerminal(SP_PARM)) {
 	if (
 #if NCURSES_SP_FUNCS
-	       (SP_PARM != 0 && SP_PARM->_term == 0)
+	       (SP_PARM != NULL && SP_PARM->_term == NULL)
 #else
 	       cur_term == 0
 #endif
@@ -444,7 +444,7 @@
 NCURSES_EXPORT(int)
 _nc_outc_wrapper(SCREEN *sp, int c)
 {
-    if (0 == sp) {
+    if (NULL == sp) {
 	return fputc(c, stdout);
     } else {
 	return sp->jump(c);
Index: ncurses/tinfo/lib_ttyflags.c
Prereq:  1.36 
--- ncurses-6.5-20241130+/ncurses/tinfo/lib_ttyflags.c	2020-09-05 22:54:47.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/lib_ttyflags.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -42,7 +42,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_ttyflags.c,v 1.36 2020/09/05 22:54:47 tom Exp $")
+MODULE_ID("$Id: lib_ttyflags.c,v 1.37 2024/12/07 21:24:18 tom Exp $")
 
 NCURSES_EXPORT(int)
 NCURSES_SP_NAME(_nc_get_tty_mode) (NCURSES_SP_DCLx TTY * buf)
@@ -50,7 +50,7 @@
     TERMINAL *termp = TerminalOf(SP_PARM);
     int result = OK;
 
-    if (buf == 0 || termp == 0) {
+    if (buf == NULL || termp == NULL) {
 	result = ERR;
     } else {
 
@@ -75,7 +75,7 @@
 			termp ? termp->Filedes : -1,
 			_nc_trace_ttymode(buf)));
     }
-    if (result == ERR && buf != 0)
+    if (result == ERR && buf != NULL)
 	memset(buf, 0, sizeof(*buf));
 
     return (result);
@@ -94,12 +94,12 @@
 {
     int result = OK;
 
-    if (buf == 0 || SP_PARM == 0) {
+    if (buf == NULL || SP_PARM == NULL) {
 	result = ERR;
     } else {
 	TERMINAL *termp = TerminalOf(SP_PARM);
 
-	if (0 == termp) {
+	if (NULL == termp) {
 	    result = ERR;
 	} else {
 #ifdef USE_TERM_DRIVER
@@ -113,7 +113,7 @@
 		    ) {
 		    if (errno == EINTR)
 			continue;
-		    if ((errno == ENOTTY) && (SP_PARM != 0))
+		    if ((errno == ENOTTY) && (SP_PARM != NULL))
 			SP_PARM->_notty = TRUE;
 		    result = ERR;
 		}
@@ -145,7 +145,7 @@
     T((T_CALLED("def_shell_mode(%p) ->term %p"),
        (void *) SP_PARM, (void *) termp));
 
-    if (termp != 0) {
+    if (termp != NULL) {
 #ifdef USE_TERM_DRIVER
 	rc = CallDriver_2(SP_PARM, td_mode, FALSE, TRUE);
 #else
@@ -185,7 +185,7 @@
 
     T((T_CALLED("def_prog_mode(%p) ->term %p"), (void *) SP_PARM, (void *) termp));
 
-    if (termp != 0) {
+    if (termp != NULL) {
 #ifdef USE_TERM_DRIVER
 	rc = CallDriver_2(SP_PARM, td_mode, TRUE, TRUE);
 #else
@@ -223,7 +223,7 @@
 
     T((T_CALLED("reset_prog_mode(%p) ->term %p"), (void *) SP_PARM, (void *) termp));
 
-    if (termp != 0) {
+    if (termp != NULL) {
 #ifdef USE_TERM_DRIVER
 	rc = CallDriver_2(SP_PARM, td_mode, TRUE, FALSE);
 #else
@@ -256,7 +256,7 @@
     T((T_CALLED("reset_shell_mode(%p) ->term %p"),
        (void *) SP_PARM, (void *) termp));
 
-    if (termp != 0) {
+    if (termp != NULL) {
 #ifdef USE_TERM_DRIVER
 	rc = CallDriver_2(SP_PARM, td_mode, FALSE, FALSE);
 #else
@@ -281,12 +281,12 @@
 static TTY *
 saved_tty(NCURSES_SP_DCL0)
 {
-    TTY *result = 0;
+    TTY *result = NULL;
 
-    if (SP_PARM != 0) {
+    if (SP_PARM != NULL) {
 	result = (TTY *) & (SP_PARM->_saved_tty);
     } else {
-	if (_nc_prescreen.saved_tty == 0) {
+	if (_nc_prescreen.saved_tty == NULL) {
 	    _nc_prescreen.saved_tty = typeCalloc(TTY, 1);
 	}
 	result = _nc_prescreen.saved_tty;
Index: ncurses/tinfo/make_hash.c
Prereq:  1.34 
--- ncurses-6.5-20241130+/ncurses/tinfo/make_hash.c	2024-03-02 19:35:40.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/make_hash.c	2024-12-07 20:51:15.000000000 +0000
@@ -44,7 +44,7 @@
 
 #include <ctype.h>
 
-MODULE_ID("$Id: make_hash.c,v 1.34 2024/03/02 19:35:40 tom Exp $")
+MODULE_ID("$Id: make_hash.c,v 1.36 2024/12/07 20:51:15 tom Exp $")
 
 /*
  *	_nc_make_hash_table()
@@ -79,7 +79,7 @@
 {
     size_t need = strlen(s) + 1;
     char *result = malloc(need);
-    if (result == 0)
+    if (result == NULL)
 	failed("strmalloc");
     _nc_STRCPY(result, s, need);
     return result;
@@ -153,7 +153,7 @@
 count_columns(char **list)
 {
     int result = 0;
-    if (list != 0) {
+    if (list != NULL) {
 	while (*list++) {
 	    ++result;
 	}
@@ -168,17 +168,17 @@
 
     int col = 0;
 
-    if (buffer == 0) {
+    if (buffer == NULL) {
 	free(list);
-	list = 0;
-	return 0;
+	list = NULL;
+	return NULL;
     }
 
     if (*buffer != '#') {
-	if (list == 0) {
+	if (list == NULL) {
 	    list = typeCalloc(char *, (MAX_COLUMNS + 1));
-	    if (list == 0)
-		return (0);
+	    if (list == NULL)
+		return (NULL);
 	}
 	while (*buffer != '\0') {
 	    char *s;
@@ -205,7 +205,7 @@
 		break;
 	}
     }
-    return col ? list : 0;
+    return col ? list : NULL;
 }
 
 #define SetType(n,t) \
@@ -272,8 +272,8 @@
 	|| (column >= MAX_COLUMNS)
 	|| *(root_name = argv[2]) == 0
 	|| (bigstring = atoi(argv[3])) < 0
-	|| name_table == 0
-	|| hash_table == 0) {
+	|| name_table == NULL
+	|| hash_table == NULL) {
 	fprintf(stderr, "usage: make_hash column root_name bigstring\n");
 	exit(EXIT_FAILURE);
     }
@@ -291,7 +291,7 @@
 	else
 	    buffer[sizeof(buffer) - 2] = '\0';
 	list = parse_columns(buffer);
-	if (list == 0)		/* blank or comment */
+	if (list == NULL)	/* blank or comment */
 	    continue;
 	if (is_user) {
 	    if (strcmp(list[0], "userdef"))
@@ -382,15 +382,15 @@
 		printf("\t%d,%d,",
 		       name_table[n].ute_argc,
 		       name_table[n].ute_args);
-	    printf("\t%3d, %3d %s%c\n",
+	    printf("\t%3d, %3d %s%s\n",
 		   name_table[n].ute_index,
 		   name_table[n].ute_link,
 		   R_BRACE,
-		   n < tablesize - 1 ? ',' : ' ');
+		   n < tablesize - 1 ? "," : "");
 	    len += (int) strlen(name_table[n].ute_name) + 1;
 	}
 	printf("%s;\n\n", R_BRACE);
-	printf("static struct %s_table_entry *_nc_%s_table = 0;\n\n",
+	printf("static struct %s_table_entry *_nc_%s_table = NULL;\n\n",
 	       table_name,
 	       root_name);
     } else {
@@ -407,11 +407,11 @@
 		printf("\t%d,%d,",
 		       name_table[n].ute_argc,
 		       name_table[n].ute_args);
-	    printf("\t%3d, %3d %s%c\n",
+	    printf("\t%3d, %3d %s%s\n",
 		   name_table[n].ute_index,
 		   name_table[n].ute_link,
 		   R_BRACE,
-		   n < tablesize - 1 ? ',' : ' ');
+		   n < tablesize - 1 ? "," : "");
 	}
 	printf("%s;\n\n", R_BRACE);
     }
@@ -439,7 +439,7 @@
 	free((void *) name_table[n].ute_name);
     }
     free(name_table);
-    parse_columns(0);
+    parse_columns(NULL);
 
     return EXIT_SUCCESS;
 }
Index: ncurses/tinfo/make_keys.c
Prereq:  1.23 
--- ncurses-6.5-20241130+/ncurses/tinfo/make_keys.c	2021-08-18 20:55:25.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/make_keys.c	2024-12-07 20:06:49.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2011,2015 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 #define USE_TERMLIB 1
 #include <build.priv.h>
 
-MODULE_ID("$Id: make_keys.c,v 1.23 2021/08/18 20:55:25 tom Exp $")
+MODULE_ID("$Id: make_keys.c,v 1.24 2024/12/07 20:06:49 tom Exp $")
 
 #include <names.c>
 
@@ -51,10 +51,10 @@
 
     if (result == 0) {
 	unsigned n;
-	for (n = 0; strnames[n] != 0; n++) {
+	for (n = 0; strnames[n] != NULL; n++) {
 	    ++result;
 	}
-	for (n = 0; strfnames[n] != 0; n++) {
+	for (n = 0; strfnames[n] != NULL; n++) {
 	    ++result;
 	}
     }
@@ -66,14 +66,14 @@
 {
     unsigned n;
     bool found = FALSE;
-    for (n = 0; strnames[n] != 0; n++) {
+    for (n = 0; strnames[n] != NULL; n++) {
 	if (!strcmp(name, strnames[n])) {
 	    found = TRUE;
 	    break;
 	}
     }
     if (!found) {
-	for (n = 0; strfnames[n] != 0; n++) {
+	for (n = 0; strfnames[n] != NULL; n++) {
 	    if (!strcmp(name, strfnames[n])) {
 		found = TRUE;
 		break;
@@ -93,7 +93,7 @@
     unsigned maxlen = 16;
     int scanned;
 
-    while (fgets(buffer, (int) sizeof(buffer), ifp) != 0) {
+    while (fgets(buffer, (int) sizeof(buffer), ifp) != NULL) {
 	if (*buffer == '#')
 	    continue;
 
@@ -119,7 +119,7 @@
 static void
 write_list(FILE *ofp, const char **list)
 {
-    while (*list != 0)
+    while (*list != NULL)
 	fprintf(ofp, "%s\n", *list++);
 }
 
@@ -139,14 +139,14 @@
 	"static",
 	"#endif",
 	"const struct tinfo_fkeys _nc_tinfo_fkeys[] = {",
-	0
+	NULL
     };
     static const char *suffix[] =
     {
 	"\t{ 0, 0} };",
 	"",
 	"#endif /* _INIT_KEYTRY_H */",
-	0
+	NULL
     };
 
     write_list(stdout, prefix);
@@ -154,7 +154,7 @@
 	int n;
 	for (n = 1; n < argc; n++) {
 	    FILE *fp = fopen(argv[n], "r");
-	    if (fp != 0) {
+	    if (fp != NULL) {
 		make_keys(fp, stdout);
 		fclose(fp);
 	    }
Index: ncurses/tinfo/name_match.c
Prereq:  1.25 
--- ncurses-6.5-20241130+/ncurses/tinfo/name_match.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/name_match.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2013,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -34,7 +34,7 @@
 #include <curses.priv.h>
 #include <tic.h>
 
-MODULE_ID("$Id: name_match.c,v 1.25 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: name_match.c,v 1.26 2024/12/07 21:24:18 tom Exp $")
 
 #define FirstName _nc_globals.first_name
 
@@ -60,17 +60,17 @@
 _nc_first_name(const char *const sp)
 {
 #if NO_LEAKS
-    if (sp == 0) {
-	if (FirstName != 0) {
+    if (sp == NULL) {
+	if (FirstName != NULL) {
 	    FreeAndNull(FirstName);
 	}
     } else
 #endif
     {
-	if (FirstName == 0)
+	if (FirstName == NULL)
 	    FirstName = typeMalloc(char, MAX_NAME_SIZE + 1);
 
-	if (FirstName != 0) {
+	if (FirstName != NULL) {
 	    unsigned n;
 	    const char *src = sp;
 #if NCURSES_USE_TERMCAP && NCURSES_XNAMES
@@ -95,7 +95,7 @@
 {
     const char *s;
 
-    if ((s = namelst) != 0) {
+    if ((s = namelst) != NULL) {
 	while (*s != '\0') {
 	    const char *d, *t;
 	    int code, found;
Index: ncurses/tinfo/obsolete.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/ncurses/tinfo/obsolete.c	2023-10-21 15:38:47.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/obsolete.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 2013-2014,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -37,7 +37,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: obsolete.c,v 1.11 2023/10/21 15:38:47 tom Exp $")
+MODULE_ID("$Id: obsolete.c,v 1.12 2024/12/07 21:24:18 tom Exp $")
 
 /*
  * Obsolete entrypoint retained for binary compatibility.
@@ -126,7 +126,7 @@
 	rc = 0;
     }
 
-    if (target != 0) {
+    if (target != NULL) {
 	switch (rc) {
 	case 1:
 	    target[0] = CH(0);
@@ -225,7 +225,7 @@
 	}
     }
 
-    if (target != 0) {
+    if (target != NULL) {
 	int shift = 0;
 	*target = 0;
 	for (j = 1; j < rc; j++) {
Index: ncurses/tinfo/parse_entry.c
Prereq:  1.111 
--- ncurses-6.5-20241130+/ncurses/tinfo/parse_entry.c	2024-11-23 18:49:08.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/parse_entry.c	2024-12-07 21:13:36.000000000 +0000
@@ -48,7 +48,7 @@
 #include <ctype.h>
 #include <tic.h>
 
-MODULE_ID("$Id: parse_entry.c,v 1.111 2024/11/23 18:49:08 tom Exp $")
+MODULE_ID("$Id: parse_entry.c,v 1.112 2024/12/07 21:13:36 tom Exp $")
 
 #ifdef LINT
 static short const parametrized[] =
@@ -204,7 +204,7 @@
 {
     struct user_table_entry const *entry = _nc_find_user_entry(name);
     bool result = TRUE;
-    if ((entry != 0) && (token_type != CANCEL)) {
+    if ((entry != NULL) && (token_type != CANCEL)) {
 	int have_type = (1 << token_type);
 	if (!(entry->ute_type & have_type)) {
 	    if (!silent)
@@ -332,7 +332,7 @@
 
     entryp->tterm.str_table = entryp->tterm.term_names = _nc_save_str(ptr);
 
-    if (entryp->tterm.str_table == 0)
+    if (entryp->tterm.str_table == NULL)
 	returnDB(ERR);
 
     DEBUG(2, ("Starting '%s'", ptr));
@@ -350,7 +350,7 @@
     _nc_set_type(name);
 
     /* check for overly-long names and aliases */
-    for (base = entryp->tterm.term_names; (ptr = strchr(base, '|')) != 0;
+    for (base = entryp->tterm.term_names; (ptr = strchr(base, '|')) != NULL;
 	 base = ptr + 1) {
 	if (ptr - base > MAX_ALIAS) {
 	    _nc_warning("%s `%.*s' may be too long",
@@ -459,7 +459,7 @@
 		if (expected_type(_nc_curr_token.tk_name, token_type, silent)) {
 		    if ((entry_ptr = _nc_extend_names(entryp,
 						      _nc_curr_token.tk_name,
-						      token_type)) != 0) {
+						      token_type)) != NULL) {
 			if (_nc_tracing >= DEBUG_LEVEL(1)) {
 			    _nc_warning("extended capability '%s'",
 					_nc_curr_token.tk_name);
@@ -629,7 +629,7 @@
 		 * have picked up defaults via translation.
 		 */
 		for (i = 0; i < entryp->nuses; i++) {
-		    if (entryp->uses[i].name != 0
+		    if (entryp->uses[i].name != NULL
 			&& !strchr(entryp->uses[i].name, '+'))
 			has_base_entry = TRUE;
 		}
@@ -697,7 +697,7 @@
 static void
 append_acs0(string_desc * dst, int code, const char *src, size_t off)
 {
-    if (src != 0 && off < strlen(src)) {
+    if (src != NULL && off < strlen(src)) {
 	char temp[3];
 	temp[0] = (char) code;
 	temp[1] = src[off];
@@ -929,15 +929,15 @@
 
 	/* we're going to use this for a special case later */
 	dp = strchr(other_non_function_keys, 'i');
-	foundim = (dp != 0) && (dp[1] == 'm');
+	foundim = (dp != NULL) && (dp[1] == 'm');
 
 	/* look at each comma-separated capability in the ko string... */
 	for (base = other_non_function_keys;
-	     (cp = strchr(base, ',')) != 0;
+	     (cp = strchr(base, ',')) != NULL;
 	     base = cp + 1) {
 	    size_t len = (unsigned) (cp - base);
 	    size_t n;
-	    assoc const *ap = 0;
+	    assoc const *ap = NULL;
 
 	    for (n = 0; n < SIZEOF(ko_xlate); ++n) {
 		if (len == strlen(ko_xlate[n].from)
@@ -946,7 +946,7 @@
 		    break;
 		}
 	    }
-	    if (ap == 0) {
+	    if (ap == NULL) {
 		_nc_warning("unknown capability `%.*s' in ko string",
 			    (int) len, base);
 		continue;
@@ -1143,7 +1143,7 @@
 	    return NOTFOUND;
 	}
 
-	for (count = 0; names[count] != 0; count++) {
+	for (count = 0; names[count] != NULL; count++) {
 	    if (!strcmp(names[count], find)) {
 		struct name_table_entry const *entry_ptr = _nc_get_table(FALSE);
 		while (entry_ptr->nte_type != state
Index: ncurses/tinfo/read_entry.c
Prereq:  1.173 
--- ncurses-6.5-20241130+/ncurses/tinfo/read_entry.c	2024-07-27 23:07:02.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/read_entry.c	2024-12-07 21:02:00.000000000 +0000
@@ -42,7 +42,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: read_entry.c,v 1.173 2024/07/27 23:07:02 tom Exp $")
+MODULE_ID("$Id: read_entry.c,v 1.174 2024/12/07 21:02:00 tom Exp $")
 
 #define MyNumber(n) (short) LOW_MSB(n)
 
@@ -237,11 +237,11 @@
     tp->ext_Numbers = 0;
     tp->ext_Strings = 0;
 #endif
-    if (tp->Booleans == 0)
+    if (tp->Booleans == NULL)
 	TYPE_MALLOC(NCURSES_SBOOL, BOOLCOUNT, tp->Booleans);
-    if (tp->Numbers == 0)
+    if (tp->Numbers == NULL)
 	TYPE_MALLOC(NCURSES_INT2, NUMCOUNT, tp->Numbers);
-    if (tp->Strings == 0)
+    if (tp->Strings == NULL)
 	TYPE_MALLOC(char *, STRCOUNT, tp->Strings);
 
     for_each_boolean(i, tp)
@@ -346,7 +346,7 @@
     want = (unsigned) (str_size + name_size + 1);
     /* try to allocate space for the string table */
     if (str_count * SIZEOF_SHORT >= max_entry_size
-	|| (string_table = typeMalloc(char, want)) == 0) {
+	|| (string_table = typeMalloc(char, want)) == NULL) {
 	returnDB(TGETENT_NO);
     }
 
@@ -483,7 +483,7 @@
 
 	if (ext_str_limit) {
 	    ptr->ext_str_table = typeMalloc(char, (size_t) ext_str_limit);
-	    if (ptr->ext_str_table == 0) {
+	    if (ptr->ext_str_table == NULL) {
 		returnDB(TGETENT_NO);
 	    }
 	    if (Read(ptr->ext_str_table, (unsigned) ext_str_limit) != ext_str_limit) {
@@ -582,11 +582,11 @@
 _nc_read_file_entry(const char *const filename, TERMTYPE2 *ptr)
 /* return 1 if read, 0 if not found or garbled */
 {
-    FILE *fp = 0;
+    FILE *fp = NULL;
     int code;
 
     if (_nc_access(filename, R_OK) < 0
-	|| (fp = safe_fopen(filename, BIN_R)) == 0) {
+	|| (fp = safe_fopen(filename, BIN_R)) == NULL) {
 	TR(TRACE_DATABASE, ("cannot open terminfo %s (errno=%d)", filename, errno));
 	code = TGETENT_NO;
     } else {
@@ -881,7 +881,7 @@
 {
     int code = TGETENT_NO;
 
-    if (name == 0)
+    if (name == NULL)
 	return _nc_read_entry2("", filename, tp);
 
     _nc_SPRINTF(filename, _nc_SLIMIT(PATH_MAX)
@@ -891,7 +891,7 @@
 	|| strcmp(name, ".") == 0
 	|| strcmp(name, "..") == 0
 	|| _nc_pathlast(name) != 0
-	|| strchr(name, NCURSES_PATHSEP) != 0) {
+	|| strchr(name, NCURSES_PATHSEP) != NULL) {
 	TR(TRACE_DATABASE, ("illegal or missing entry name '%s'", name));
     } else {
 #if NCURSES_USE_DATABASE
@@ -901,7 +901,7 @@
 
 	_nc_first_db(&state, &offset);
 	code = TGETENT_ERR;
-	while ((path = _nc_next_db(&state, &offset)) != 0) {
+	while ((path = _nc_next_db(&state, &offset)) != NULL) {
 	    code = _nc_read_tic_entry(filename, PATH_MAX, path, name, tp);
 	    if (code == TGETENT_YES) {
 		_nc_last_db();
Index: ncurses/tinfo/strings.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/ncurses/tinfo/strings.c	2023-05-27 20:13:10.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/strings.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 2000-2012,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -38,7 +38,7 @@
 #include <curses.priv.h>
 #include <tic.h>
 
-MODULE_ID("$Id: strings.c,v 1.11 2023/05/27 20:13:10 tom Exp $")
+MODULE_ID("$Id: strings.c,v 1.12 2024/12/07 21:24:18 tom Exp $")
 
 /****************************************************************************
  * Useful string functions (especially for mvcur)
@@ -71,12 +71,12 @@
 NCURSES_EXPORT(string_desc *)
 _nc_str_init(string_desc * dst, char *src, size_t len)
 {
-    if (dst != 0) {
+    if (dst != NULL) {
 	dst->s_head = src;
 	dst->s_tail = src;
 	dst->s_size = len - 1;
 	dst->s_init = dst->s_size;
-	if (src != 0)
+	if (src != NULL)
 	    *src = 0;
     }
     return dst;
@@ -88,7 +88,7 @@
 NCURSES_EXPORT(string_desc *)
 _nc_str_null(string_desc * dst, size_t len)
 {
-    return _nc_str_init(dst, 0, len);
+    return _nc_str_init(dst, NULL, len);
 }
 
 /*
@@ -111,7 +111,7 @@
 	size_t len = strlen(src);
 
 	if (len < dst->s_size) {
-	    if (dst->s_tail != 0) {
+	    if (dst->s_tail != NULL) {
 		_nc_STRCPY(dst->s_tail, src, dst->s_size);
 		dst->s_tail += len;
 	    }
@@ -132,7 +132,7 @@
 	size_t len = strlen(src);
 
 	if (len < dst->s_size) {
-	    if (dst->s_head != 0) {
+	    if (dst->s_head != NULL) {
 		_nc_STRCPY(dst->s_head, src, dst->s_size);
 		dst->s_tail = dst->s_head + len;
 	    }
Index: ncurses/tinfo/trim_sgr0.c
Prereq:  1.25 
--- ncurses-6.5-20241130+/ncurses/tinfo/trim_sgr0.c	2024-10-19 21:18:18.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/trim_sgr0.c	2024-12-07 21:02:59.000000000 +0000
@@ -37,7 +37,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: trim_sgr0.c,v 1.25 2024/10/19 21:18:18 tom Exp $")
+MODULE_ID("$Id: trim_sgr0.c,v 1.26 2024/12/07 21:02:59 tom Exp $")
 
 #undef CUR
 #define CUR tp->
@@ -52,7 +52,7 @@
     if (PRESENT(value))
 	result = strdup(value);
     else
-	result = 0;
+	result = NULL;
     return result;
 }
 
@@ -60,7 +60,7 @@
 is_csi(const char *s)
 {
     int result = 0;
-    if (s != 0) {
+    if (s != NULL) {
 	if (UChar(s[0]) == CSI_CHR)
 	    result = 1;
 	else if (s[0] == ESC_CHR && s[1] == L_BLOCK)
@@ -101,7 +101,7 @@
 static bool
 rewrite_sgr(char *s, const char *attr)
 {
-    if (s != 0) {
+    if (s != NULL) {
 	if (PRESENT(attr)) {
 	    size_t len_s = strlen(s);
 	    size_t len_a = strlen(attr);
@@ -125,7 +125,7 @@
 similar_sgr(char *a, char *b)
 {
     bool result = FALSE;
-    if (a != 0 && b != 0) {
+    if (a != NULL && b != NULL) {
 	int csi_a = is_csi(a);
 	int csi_b = is_csi(b);
 	size_t len_a;
@@ -300,7 +300,7 @@
 		}
 	    }
 	    if (!found
-		&& (tmp = strstr(end, off)) != 0
+		&& (tmp = strstr(end, off)) != NULL
 		&& strcmp(end, off) != 0) {
 		i = (size_t) (tmp - end);
 		j = strlen(off);
Index: ncurses/tinfo/write_entry.c
Prereq:  1.137 
--- ncurses-6.5-20241130+/ncurses/tinfo/write_entry.c	2024-11-09 19:24:01.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tinfo/write_entry.c	2024-12-07 21:13:36.000000000 +0000
@@ -42,7 +42,7 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: write_entry.c,v 1.137 2024/11/09 19:24:01 tom Exp $")
+MODULE_ID("$Id: write_entry.c,v 1.138 2024/12/07 21:13:36 tom Exp $")
 
 #if 1
 #define TRACE_OUT(p) DEBUG(2, p)
@@ -82,12 +82,12 @@
     } else {
 	FILE *fp = ((_nc_access(filename, W_OK) == 0)
 		    ? safe_fopen(filename, BIN_W)
-		    : 0);
+		    : NULL);
 	size_t actual;
 
-	if (fp == 0) {
+	if (fp == NULL) {
 	    _nc_syserr_abort("cannot open %s/%s: (errno %d) %s",
-			     _nc_tic_dir(0),
+			     _nc_tic_dir(NULL),
 			     filename,
 			     errno,
 			     strerror(errno));
@@ -129,9 +129,9 @@
     static const char dirnames[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
     static bool verified[sizeof(dirnames)];
 
-    const char *s = 0;
+    const char *s = NULL;
 
-    if (code == 0 || (s = (strchr) (dirnames, code)) == 0) {
+    if (code == 0 || (s = (strchr) (dirnames, code)) == NULL) {
 	_nc_err_abort("Illegal terminfo subdirectory \"" LEAF_FMT "\"", code);
     } else if (!verified[s - dirnames]) {
 	char dir[sizeof(LEAF_FMT)];
Index: ncurses/trace/lib_trace.c
Prereq:  1.108 
--- ncurses-6.5-20241130+/ncurses/trace/lib_trace.c	2024-11-23 18:40:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/lib_trace.c	2024-12-07 21:02:00.000000000 +0000
@@ -48,7 +48,7 @@
 
 #include <ctype.h>
 
-MODULE_ID("$Id: lib_trace.c,v 1.108 2024/11/23 18:40:23 tom Exp $")
+MODULE_ID("$Id: lib_trace.c,v 1.109 2024/12/07 21:02:00 tom Exp $")
 
 NCURSES_EXPORT_VAR(unsigned) _nc_tracing = 0; /* always define this */
 
@@ -135,7 +135,7 @@
 
     Locked(result = _nc_tracing);
 
-    if ((MyFP == 0) && tracelevel) {
+    if ((MyFP == NULL) && tracelevel) {
 	MyInit = TRUE;
 	if (MyFD >= 0) {
 	    MyFP = fdopen(MyFD, BIN_W);
@@ -149,7 +149,7 @@
 #define SAFE_MODE (O_CREAT | O_EXCL | O_RDWR)
 	    if (_nc_access(myFile, W_OK) < 0
 		|| (MyFD = safe_open3(myFile, SAFE_MODE, 0600)) < 0
-		|| (MyFP = fdopen(MyFD, BIN_W)) == 0) {
+		|| (MyFP = fdopen(MyFD, BIN_W)) == NULL) {
 		;		/* EMPTY */
 	    }
 	}
@@ -158,7 +158,7 @@
 	 * so that the trace-output gets flushed automatically at the
 	 * end of each line.  This is useful in case the program dies.
 	 */
-	if (MyFP != 0) {
+	if (MyFP != NULL) {
 #if HAVE_SETVBUF		/* ANSI */
 	    (void) setvbuf(MyFP, (char *) 0, _IOLBF, (size_t) 0);
 #elif HAVE_SETBUF /* POSIX */
@@ -188,10 +188,10 @@
 	    _tracef("- DEBUG_LEVEL(%u)", tracelevel >> TRACE_SHIFT);
 	}
     } else if (tracelevel == 0) {
-	if (MyFP != 0) {
+	if (MyFP != NULL) {
 	    MyFD = dup(MyFD);	/* allow reopen of same file */
 	    fclose(MyFP);
-	    MyFP = 0;
+	    MyFP = NULL;
 	}
 	Locked(_nc_tracing = tracelevel);
     } else if (_nc_tracing != tracelevel) {
@@ -226,7 +226,7 @@
 
 #ifdef TRACE
     /* verbose-trace in the command-line utilities relies on this */
-    if (fp == 0 && !MyInit && _nc_tracing >= DEBUG_LEVEL(1))
+    if (fp == NULL && !MyInit && _nc_tracing >= DEBUG_LEVEL(1))
 	fp = stderr;
 #endif
 
@@ -246,7 +246,7 @@
 	}
     }
 
-    if (doit != 0 && fp != 0) {
+    if (doit != 0 && fp != NULL) {
 #ifdef USE_PTHREADS
 	/*
 	 * TRACE_ICALLS is "really" needed to show normal use with threaded
Index: ncurses/trace/lib_traceatr.c
Prereq:  1.97 
--- ncurses-6.5-20241130+/ncurses/trace/lib_traceatr.c	2024-07-27 19:08:04.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/lib_traceatr.c	2024-12-07 21:12:53.000000000 +0000
@@ -44,7 +44,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_traceatr.c,v 1.97 2024/07/27 19:08:04 tom Exp $")
+MODULE_ID("$Id: lib_traceatr.c,v 1.98 2024/12/07 21:12:53 tom Exp $")
 
 #define COLOR_OF(c) ((c < 0) ? "default" : (c > 7 ? color_of(c) : colors[c].name))
 
@@ -126,7 +126,7 @@
 #undef DATA
     char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);
 
-    if (result != 0) {
+    if (result != NULL) {
 	size_t n;
 	unsigned save_nc_tracing = _nc_tracing;
 
@@ -167,7 +167,7 @@
 	    }
 	}
 	if (ChAttrOf(newmode) == A_NORMAL) {
-	    if (result != 0 && result[1] != '\0')
+	    if (result != NULL && result[1] != '\0')
 		(void) _nc_trace_bufcat(bufnum, "|");
 	    (void) _nc_trace_bufcat(bufnum, "A_NORMAL");
 	}
@@ -248,14 +248,14 @@
     };
 #undef DATA
 
-    const char *result = 0;
+    const char *result = NULL;
 
 #if NCURSES_SP_FUNCS
     (void) sp;
 #endif
-    if (SP_PARM != 0 && (attr & A_ALTCHARSET) && (acs_chars != 0)) {
+    if (SP_PARM != NULL && (attr & A_ALTCHARSET) && (acs_chars != NULL)) {
 	char *cp;
-	const char *found = 0;
+	const char *found = NULL;
 
 	for (cp = acs_chars; cp[0] && cp[1]; cp += 2) {
 	    if (ChCharOf(UChar(cp[1])) == ChCharOf(ch)) {
@@ -264,7 +264,7 @@
 	    }
 	}
 
-	if (found != 0) {
+	if (found != NULL) {
 	    size_t n;
 
 	    ch = ChCharOf(UChar(*found));
@@ -284,12 +284,12 @@
 {
     char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);
 
-    if (result != 0) {
+    if (result != NULL) {
 	const char *found;
 	attr_t attr = ChAttrOf(ch);
 
 	_nc_STRCPY(result, l_brace, TRACE_BUF_SIZE(bufnum));
-	if ((found = _nc_altcharset_name(attr, ch)) != 0) {
+	if ((found = _nc_altcharset_name(attr, ch)) != NULL) {
 	    (void) _nc_trace_bufcat(bufnum, found);
 	    attr &= ~A_ALTCHARSET;
 	} else
@@ -328,13 +328,13 @@
 {
     char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);
 
-    if (result != 0) {
+    if (result != NULL) {
 	_nc_STRCPY(result, l_brace, TRACE_BUF_SIZE(bufnum));
-	if (ch != 0) {
+	if (ch != NULL) {
 	    const char *found;
 	    attr_t attr = AttrOfD(ch);
 
-	    if ((found = _nc_altcharset_name(attr, (chtype) CharOfD(ch))) != 0) {
+	    if ((found = _nc_altcharset_name(attr, (chtype) CharOfD(ch))) != NULL) {
 		(void) _nc_trace_bufcat(bufnum, found);
 		attr &= ~A_ALTCHARSET;
 	    } else if (isWidecExt(CHDEREF(ch))) {
Index: ncurses/trace/lib_tracebits.c
Prereq:  1.31 
--- ncurses-6.5-20241130+/ncurses/trace/lib_tracebits.c	2020-11-14 23:38:11.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/lib_tracebits.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019,2020 Thomas E. Dickey                                     *
+ * Copyright 2019-2020,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2015 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -35,7 +35,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_tracebits.c,v 1.31 2020/11/14 23:38:11 tom Exp $")
+MODULE_ID("$Id: lib_tracebits.c,v 1.32 2024/12/07 21:24:18 tom Exp $")
 
 #if HAVE_SYS_TERMIO_H
 #include <sys/termio.h>		/* needed for ISC */
@@ -172,7 +172,7 @@
 			8 + sizeof(cflags) +
 			8 + sizeof(lflags) +
 			8);
-    if (buf != 0) {
+    if (buf != NULL) {
 
 	if (tty->c_iflag & ALLIN)
 	    lookup_bits(buf, iflags, "iflags", tty->c_iflag);
Index: ncurses/trace/lib_tracechr.c
Prereq:  1.25 
--- ncurses-6.5-20241130+/ncurses/trace/lib_tracechr.c	2024-11-23 19:50:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/lib_tracechr.c	2024-12-07 21:02:00.000000000 +0000
@@ -40,7 +40,7 @@
 
 #include <ctype.h>
 
-MODULE_ID("$Id: lib_tracechr.c,v 1.25 2024/11/23 19:50:34 tom Exp $")
+MODULE_ID("$Id: lib_tracechr.c,v 1.26 2024/12/07 21:02:00 tom Exp $")
 
 #ifdef TRACE
 
@@ -50,13 +50,13 @@
 _nc_tracechar(SCREEN *sp, int ch)
 {
     NCURSES_CONST char *name;
-    char *MyBuffer = ((sp != 0)
+    char *MyBuffer = ((sp != NULL)
 		      ? sp->tracechr_buf
 		      : _nc_globals.tracechr_buf);
 
     if ((ch > KEY_MIN && !_nc_unicode_locale()) || ch < 0) {
 	name = safe_keyname(SP_PARM, ch);
-	if (name == 0 || *name == '\0')
+	if (name == NULL || *name == '\0')
 	    name = "NULL";
 	_nc_SPRINTF(MyBuffer, _nc_SLIMIT(MyBufSize)
 		    "'%.30s' = \\x%02x", name, UChar(ch));
@@ -72,7 +72,7 @@
 		    "\\x%02x", ch);
     } else {
 	name = safe_unctrl(SP_PARM, (chtype) ch);
-	if (name == 0 || *name == 0)
+	if (name == NULL || *name == 0)
 	    name = "null";	/* shouldn't happen */
 	_nc_SPRINTF(MyBuffer, _nc_SLIMIT(MyBufSize)
 		    "'%.30s' = \\x%02x", name, ch);
Index: ncurses/trace/lib_tracedmp.c
Prereq:  1.37 
--- ncurses-6.5-20241130+/ncurses/trace/lib_tracedmp.c	2023-06-24 15:49:45.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/lib_tracedmp.c	2024-12-07 20:06:49.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2012,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 #include <curses.priv.h>
 #include <ctype.h>
 
-MODULE_ID("$Id: lib_tracedmp.c,v 1.37 2023/06/24 15:49:45 tom Exp $")
+MODULE_ID("$Id: lib_tracedmp.c,v 1.38 2024/12/07 20:06:49 tom Exp $")
 
 #ifdef TRACE
 
@@ -72,7 +72,7 @@
 	my_length = (unsigned) (2 * (width + 1));
 	my_buffer = typeRealloc(char, my_length, my_buffer);
     }
-    if (my_buffer == 0)
+    if (my_buffer == NULL)
 	return;
 
     for (n = 0; n <= win->_maxy; ++n) {
@@ -177,7 +177,7 @@
     }
 #if NO_LEAKS
     free(my_buffer);
-    my_buffer = 0;
+    my_buffer = NULL;
     my_length = 0;
 #endif
 }
Index: ncurses/trace/lib_tracemse.c
Prereq:  1.23 
--- ncurses-6.5-20241130+/ncurses/trace/lib_tracemse.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/lib_tracemse.c	2024-12-07 20:06:49.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2012,2014 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -39,7 +39,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_tracemse.c,v 1.23 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_tracemse.c,v 1.24 2024/12/07 20:06:49 tom Exp $")
 
 #ifdef TRACE
 
@@ -117,9 +117,9 @@
 NCURSES_EXPORT(char *)
 _nc_tracemouse(SCREEN *sp, MEVENT const *ep)
 {
-    char *result = 0;
+    char *result = NULL;
 
-    if (sp != 0) {
+    if (sp != NULL) {
 	_nc_SPRINTF(my_buffer, _nc_SLIMIT(sizeof(my_buffer))
 		    TRACEMSE_FMT,
 		    ep->id,
@@ -138,7 +138,7 @@
 NCURSES_EXPORT(mmask_t)
 _nc_retrace_mmask_t(SCREEN *sp, mmask_t code)
 {
-    if (sp != 0) {
+    if (sp != NULL) {
 	*my_buffer = '\0';
 	T((T_RETURN("{%s}"), _nc_trace_mmask_t(sp, code)));
     } else {
Index: ncurses/trace/trace_buf.c
Prereq:  1.22 
--- ncurses-6.5-20241130+/ncurses/trace/trace_buf.c	2023-06-24 13:37:25.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/trace_buf.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2011,2012 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -36,7 +36,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: trace_buf.c,v 1.22 2023/06/24 13:37:25 tom Exp $")
+MODULE_ID("$Id: trace_buf.c,v 1.23 2024/12/07 21:24:18 tom Exp $")
 
 #ifdef TRACE
 
@@ -46,22 +46,22 @@
 static char *
 _nc_trace_alloc(int bufnum, size_t want)
 {
-    char *result = 0;
+    char *result = NULL;
 
     if (bufnum >= 0) {
 	if ((size_t) (bufnum + 1) > MySize) {
 	    size_t need = (size_t) (bufnum + 1) * 2;
-	    if ((MyList = typeRealloc(TRACEBUF, need, MyList)) != 0) {
+	    if ((MyList = typeRealloc(TRACEBUF, need, MyList)) != NULL) {
 		while (need > MySize)
-		    MyList[MySize++].text = 0;
+		    MyList[MySize++].text = NULL;
 	    }
 	}
 
-	if (MyList != 0) {
-	    if (MyList[bufnum].text == 0
+	if (MyList != NULL) {
+	    if (MyList[bufnum].text == NULL
 		|| want > MyList[bufnum].size) {
 		MyList[bufnum].text = typeRealloc(char, want, MyList[bufnum].text);
-		if (MyList[bufnum].text != 0)
+		if (MyList[bufnum].text != NULL)
 		    MyList[bufnum].size = want;
 	    }
 	    result = MyList[bufnum].text;
@@ -72,12 +72,12 @@
 	if (MySize) {
 	    if (MyList) {
 		while (MySize--) {
-		    if (MyList[MySize].text != 0) {
+		    if (MyList[MySize].text != NULL) {
 			free(MyList[MySize].text);
 		    }
 		}
 		free(MyList);
-		MyList = 0;
+		MyList = NULL;
 	    }
 	    MySize = 0;
 	}
@@ -93,7 +93,7 @@
 _nc_trace_buf(int bufnum, size_t want)
 {
     char *result = _nc_trace_alloc(bufnum, want);
-    if (result != 0)
+    if (result != NULL)
 	*result = '\0';
     return result;
 }
@@ -109,12 +109,12 @@
     if (value == NULL)
 	value = "";
     buffer = _nc_trace_alloc(bufnum, (size_t) 0);
-    if (buffer != 0) {
+    if (buffer != NULL) {
 	size_t have = strlen(buffer);
 	size_t need = strlen(value) + have;
 
 	buffer = _nc_trace_alloc(bufnum, 1 + need);
-	if (buffer != 0)
+	if (buffer != NULL)
 	    _nc_STRCPY(buffer + have, value, need);
 
     }
Index: ncurses/trace/trace_tries.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/ncurses/trace/trace_tries.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/trace_tries.c	2024-12-07 21:24:18.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1999-2011,2012 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -36,7 +36,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: trace_tries.c,v 1.18 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: trace_tries.c,v 1.19 2024/12/07 21:24:18 tom Exp $")
 
 #ifdef TRACE
 #define my_buffer _nc_globals.tracetry_buf
@@ -50,8 +50,8 @@
 	my_buffer = (unsigned char *) _nc_doalloc(my_buffer, my_length);
     }
 
-    if (my_buffer != 0) {
-	while (tree != 0) {
+    if (my_buffer != NULL) {
+	while (tree != NULL) {
 	    if ((my_buffer[level] = tree->ch) == 0)
 		my_buffer[level] = 128;
 	    my_buffer[level + 1] = 0;
@@ -69,7 +69,7 @@
 NCURSES_EXPORT(void)
 _nc_trace_tries(TRIES * tree)
 {
-    if ((my_buffer = typeMalloc(unsigned char, my_length = 80)) != 0) {
+    if ((my_buffer = typeMalloc(unsigned char, my_length = 80)) != NULL) {
 	_tracef("BEGIN tries %p", (void *) tree);
 	recur_tries(tree, 0);
 	_tracef(". . . tries %p", (void *) tree);
Index: ncurses/trace/varargs.c
Prereq:  1.14 
--- ncurses-6.5-20241130+/ncurses/trace/varargs.c	2024-07-27 19:23:59.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/varargs.c	2024-12-07 18:00:11.000000000 +0000
@@ -35,7 +35,7 @@
 
 #include <ctype.h>
 
-MODULE_ID("$Id: varargs.c,v 1.14 2024/07/27 19:23:59 tom Exp $")
+MODULE_ID("$Id: varargs.c,v 1.15 2024/12/07 18:00:11 tom Exp $")
 
 #ifdef TRACE
 
@@ -63,17 +63,17 @@
     const char *param;
     int n;
 
-    if (fmt == 0 || *fmt == '\0')
+    if (fmt == NULL || *fmt == '\0')
 	return NULL;
     if (MyLength == 0)
 	MyBuffer = typeMalloc(char, MyLength = BUFSIZ);
-    if (MyBuffer == 0)
+    if (MyBuffer == NULL)
 	return NULL;
     *MyBuffer = '\0';
 
     while (*fmt != '\0') {
 	if (*fmt == '%') {
-	    const char *pval = 0;	/* avoid const-cast */
+	    const char *pval = NULL;	/* avoid const-cast */
 	    const char *sval = "";
 	    double fval = 0.0;
 	    int done = FALSE;
@@ -169,7 +169,7 @@
 			}
 			MyLength += strlen(param) + 2;
 			MyBuffer = typeRealloc(char, MyLength, MyBuffer);
-			if (MyBuffer != 0) {
+			if (MyBuffer != NULL) {
 			    _nc_SPRINTF(MyBuffer + strlen(MyBuffer),
 					_nc_SLIMIT(MyLength - strlen(MyBuffer))
 					", %s", param);
Index: ncurses/trace/visbuf.c
Prereq:  1.55 
--- ncurses-6.5-20241130+/ncurses/trace/visbuf.c	2024-11-30 21:24:09.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/trace/visbuf.c	2024-12-07 21:12:53.000000000 +0000
@@ -43,7 +43,7 @@
 #include <tic.h>
 #include <ctype.h>
 
-MODULE_ID("$Id: visbuf.c,v 1.55 2024/11/30 21:24:09 tom Exp $")
+MODULE_ID("$Id: visbuf.c,v 1.56 2024/12/07 21:12:53 tom Exp $")
 
 #define NUM_VISBUFS 4
 
@@ -109,11 +109,11 @@
 static const char *
 _nc_visbuf2n(int bufnum, const char *buf, int len)
 {
-    const char *vbuf = 0;
+    const char *vbuf = NULL;
     char *tp;
     int count;
 
-    if (buf == 0)
+    if (buf == NULL)
 	return ("(null)");
     if (buf == CANCELLED_STRING)
 	return ("(cancelled)");
@@ -140,7 +140,7 @@
 	}
     }
 #endif
-    if (tp != 0) {
+    if (tp != NULL) {
 	int c;
 
 	*tp++ = D_QUOTE;
@@ -196,7 +196,7 @@
     char *tp;
     int count;
 
-    if (buf == 0)
+    if (buf == NULL)
 	return ("(null)");
 
     if (len < 0)
@@ -212,7 +212,7 @@
 	vbuf = tp = mybuf[bufnum];
     }
 #endif
-    if (tp != 0) {
+    if (tp != NULL) {
 	wchar_t c;
 
 	*tp++ = D_QUOTE;
@@ -267,12 +267,12 @@
     }
     if (mylen < ++n) {
 	mylen = n + 80;
-	if (mybuf != 0)
+	if (mybuf != NULL)
 	    mybuf = typeRealloc(wchar_t, mylen, mybuf);
 	else
 	    mybuf = typeMalloc(wchar_t, mylen);
     }
-    if (mybuf != 0) {
+    if (mybuf != NULL) {
 	for (n = 0; buf[n] != 0; ++n) {
 	    mybuf[n] = (wchar_t) buf[n];
 	}
@@ -289,7 +289,7 @@
 {
     char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);
 
-    if (result != 0) {
+    if (result != NULL) {
 	int first = 0;
 
 #if USE_WIDEC_SUPPORT
@@ -317,7 +317,7 @@
 	    for (j = first; j <= last; ++j) {
 		const char *found = _nc_altcharset_name(attr, (chtype)
 							CharOf(buf[j]));
-		if (found != 0) {
+		if (found != NULL) {
 		    (void) _nc_trace_bufcat(bufnum, found);
 		    attr &= ~A_ALTCHARSET;
 		} else
Index: ncurses/tty/MKexpanded.sh
Prereq:  1.24 
--- ncurses-6.5-20241130+/ncurses/tty/MKexpanded.sh	2022-02-05 17:27:18.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tty/MKexpanded.sh	2024-12-07 20:48:46.000000000 +0000
@@ -1,6 +1,6 @@
 #! /bin/sh
 ##############################################################################
-# Copyright 2019-2020,2021 Thomas E. Dickey                                  #
+# Copyright 2019-2021,2024 Thomas E. Dickey                                  #
 # Copyright 1998-2015,2017 Free Software Foundation, Inc.                    #
 #                                                                            #
 # Permission is hereby granted, free of charge, to any person obtaining a    #
@@ -30,7 +30,7 @@
 #
 # Author: Thomas E. Dickey, 1997-on
 #
-# $Id: MKexpanded.sh,v 1.24 2022/02/05 17:27:18 tom Exp $
+# $Id: MKexpanded.sh,v 1.25 2024/12/07 20:48:46 tom Exp $
 #
 # Script to generate 'expanded.c', a dummy source that contains functions
 # corresponding to complex macros used in this library.  By making functions,
@@ -127,7 +127,12 @@
 EOF
 
 $preprocessor $TMP 2>/dev/null | \
-	sed -e '1,/^IGNORE$/d' -e 's/^@/#/' -e 's/^#[ 	]*if_/#if /' -e "s,$TMP,expanded.c,"
+	sed -e '1,/^IGNORE$/d' \
+		-e 's/^@/#/' \
+		-e 's/^#[ 	]*if_/#if /' \
+		-e "s,$TMP,expanded.c," \
+		-e 's/[ 	][ 	]*$//' \
+		-e '/^#[ 	]*[0-9]/d'
 
 cat <<EOF
 #else /* ! NCURSES_EXPANDED */
Index: ncurses/tty/hardscroll.c
Prereq:  1.58 
--- ncurses-6.5-20241130+/ncurses/tty/hardscroll.c	2023-09-09 16:04:08.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tty/hardscroll.c	2024-12-07 20:06:49.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2015,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -148,7 +148,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: hardscroll.c,v 1.58 2023/09/09 16:04:08 Nicholas.Marriott Exp $")
+MODULE_ID("$Id: hardscroll.c,v 1.59 2024/12/07 20:06:49 tom Exp $")
 
 #if defined(SCROLLDEBUG) || defined(HASHDEBUG)
 
@@ -169,7 +169,7 @@
    if OLDNUM(n) == _NEWINDEX, then the line n in new, not shifted from
    somewhere. */
 NCURSES_EXPORT_VAR (int *)
-  _nc_oldnums = 0;		/* obsolete: keep for ABI compat */
+  _nc_oldnums = NULL;		/* obsolete: keep for ABI compat */
 
 # if USE_HASHMAP
 #  define oldnums(sp)   (sp)->_oldnum_list
@@ -196,7 +196,7 @@
     /* get enough storage */
     assert(OLDNUM_SIZE(SP_PARM) >= 0);
     assert(screen_lines(SP_PARM) > 0);
-    if ((oldnums(SP_PARM) == 0)
+    if ((oldnums(SP_PARM) == NULL)
 	|| (OLDNUM_SIZE(SP_PARM) < screen_lines(SP_PARM))) {
 	int need_lines = ((OLDNUM_SIZE(SP_PARM) < screen_lines(SP_PARM))
 			  ? screen_lines(SP_PARM)
@@ -308,11 +308,11 @@
 /* dump the state of the real and virtual oldnum fields */
 {
     if (USE_TRACEF(TRACE_UPDATE | TRACE_MOVE)) {
-	char *buf = 0;
+	char *buf = NULL;
 	size_t want = ((size_t) screen_lines(SP_PARM) + 1) * 4;
 	(void) SP_PARM;
 
-	if ((buf = typeMalloc(char, want)) != 0) {
+	if ((buf = typeMalloc(char, want)) != NULL) {
 	    int n;
 
 	    *buf = '\0';
Index: ncurses/tty/hashmap.c
Prereq:  1.72 
--- ncurses-6.5-20241130+/ncurses/tty/hashmap.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tty/hashmap.c	2024-12-07 17:18:07.000000000 +0000
@@ -74,7 +74,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: hashmap.c,v 1.72 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: hashmap.c,v 1.73 2024/12/07 17:18:07 tom Exp $")
 
 #ifdef HASHDEBUG
 
@@ -311,10 +311,10 @@
 	}
     } else {
 	/* re-hash all */
-	if (oldhash(SP_PARM) == 0)
+	if (oldhash(SP_PARM) == NULL)
 	    oldhash(SP_PARM) = typeCalloc(unsigned long,
 					    (size_t) screen_lines(SP_PARM));
-	if (newhash(SP_PARM) == 0)
+	if (newhash(SP_PARM) == NULL)
 	    newhash(SP_PARM) = typeCalloc(unsigned long,
 					    (size_t) screen_lines(SP_PARM));
 	if (!oldhash(SP_PARM) || !newhash(SP_PARM)) {
Index: ncurses/tty/lib_mvcur.c
Prereq:  1.161 
--- ncurses-6.5-20241130+/ncurses/tty/lib_mvcur.c	2023-09-16 16:29:02.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tty/lib_mvcur.c	2024-12-07 20:06:49.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2018-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -160,7 +160,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_mvcur.c,v 1.161 2023/09/16 16:29:02 tom Exp $")
+MODULE_ID("$Id: lib_mvcur.c,v 1.162 2024/12/07 20:06:49 tom Exp $")
 
 #define WANT_CHAR(sp, y, x) NewScreen(sp)->_line[y].text[x]	/* desired state */
 
@@ -222,7 +222,7 @@
 NCURSES_SP_NAME(_nc_msec_cost) (NCURSES_SP_DCLx const char *const cap, int affcnt)
 /* compute the cost of a given operation */
 {
-    if (cap == 0)
+    if (cap == NULL)
 	return (INFINITY);
     else {
 	const char *cp;
@@ -364,7 +364,7 @@
     SP_PARM->_home_cost = CostOf(cursor_home, 0);
     SP_PARM->_ll_cost = CostOf(cursor_to_ll, 0);
 #if USE_HARD_TABS
-    if (getenv("NCURSES_NO_HARD_TABS") == 0
+    if (getenv("NCURSES_NO_HARD_TABS") == NULL
 	&& dest_tabs_magic_smso == 0
 	&& HasHardTabs()) {
 	SP_PARM->_ht_cost = CostOf(tab, 0);
@@ -461,12 +461,12 @@
      * nested on the various terminals (vt100, xterm, etc.) which use this
      * feature.
      */
-    if (save_cursor != 0
-	&& enter_ca_mode != 0
-	&& strstr(enter_ca_mode, save_cursor) != 0) {
+    if (save_cursor != NULL
+	&& enter_ca_mode != NULL
+	&& strstr(enter_ca_mode, save_cursor) != NULL) {
 	T(("...suppressed sc/rc capability due to conflict with smcup/rmcup"));
-	save_cursor = 0;
-	restore_cursor = 0;
+	save_cursor = NULL;
+	restore_cursor = NULL;
     }
 
     /*
@@ -580,7 +580,7 @@
     if (to_y != from_y) {
 	vcost = INFINITY;
 
-	if (row_address != 0
+	if (row_address != NULL
 	    && _nc_safe_strcat(target, TIPARM_1(row_address, to_y))) {
 	    vcost = SP_PARM->_vpa_cost;
 	}
@@ -984,7 +984,7 @@
     TR(TRACE_CALLS | TRACE_MOVE, (T_CALLED("_nc_real_mvcur(%p,%d,%d,%d,%d)"),
 				  (void *) SP_PARM, yold, xold, ynew, xnew));
 
-    if (SP_PARM == 0) {
+    if (SP_PARM == NULL) {
 	code = ERR;
     } else if (yold == ynew && xold == xnew) {
 	code = OK;
@@ -1079,7 +1079,7 @@
      * external calls.  Flush the output if the screen has not been
      * initialized, e.g., when used from low-level terminfo programs.
      */
-    if ((SP_PARM != 0) && (SP_PARM->_endwin == ewInitial))
+    if ((SP_PARM != NULL) && (SP_PARM->_endwin == ewInitial))
 	NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);
     return rc;
 }
Index: ncurses/tty/lib_tstp.c
Prereq:  1.54 
--- ncurses-6.5-20241130+/ncurses/tty/lib_tstp.c	2022-12-24 22:22:10.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tty/lib_tstp.c	2024-12-07 20:06:49.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020-2021,2022 Thomas E. Dickey                                *
+ * Copyright 2020-2022,2024 Thomas E. Dickey                                *
  * Copyright 1998-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -43,7 +43,7 @@
 
 #include <SigAction.h>
 
-MODULE_ID("$Id: lib_tstp.c,v 1.54 2022/12/24 22:22:10 tom Exp $")
+MODULE_ID("$Id: lib_tstp.c,v 1.55 2024/12/07 20:06:49 tom Exp $")
 
 #if defined(SIGTSTP) && (HAVE_SIGACTION || HAVE_SIGVEC)
 #define USE_SIGTSTP 1
@@ -159,7 +159,7 @@
      *
      * Don't do this if we're not in curses -
      */
-    if (sp != 0 && (sp->_endwin == ewRunning))
+    if (sp != NULL && (sp->_endwin == ewRunning))
 #if HAVE_TCGETPGRP
 	if (tcgetpgrp(STDIN_FILENO) == getpgrp())
 #endif
@@ -269,7 +269,7 @@
 	{
 	    SCREEN *scan;
 	    for (each_screen(scan)) {
-		if (scan->_ofp != 0
+		if (scan->_ofp != NULL
 		    && NC_ISATTY(fileno(scan->_ofp))) {
 		    scan->_outch = NCURSES_SP_NAME(_nc_outch);
 		}
Index: ncurses/tty/lib_twait.c
Prereq:  1.82 
--- ncurses-6.5-20241130+/ncurses/tty/lib_twait.c	2024-10-05 22:47:12.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tty/lib_twait.c	2024-12-07 21:02:00.000000000 +0000
@@ -76,7 +76,7 @@
 #endif
 #undef CUR
 
-MODULE_ID("$Id: lib_twait.c,v 1.82 2024/10/05 22:47:12 tom Exp $")
+MODULE_ID("$Id: lib_twait.c,v 1.83 2024/12/07 21:02:00 tom Exp $")
 
 /*
  * Returns an elapsed time, in milliseconds (if possible).
@@ -120,7 +120,7 @@
 {
     int event_delay = -1;
 
-    if (evl != 0) {
+    if (evl != NULL) {
 	int n;
 
 	for (n = 0; n < evl->count; ++n) {
Index: ncurses/tty/lib_vidattr.c
Prereq:  1.79 
--- ncurses-6.5-20241130+/ncurses/tty/lib_vidattr.c	2023-04-28 20:59:26.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tty/lib_vidattr.c	2024-12-07 20:08:15.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2020,2023 Thomas E. Dickey                                *
+ * Copyright 2018-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -70,7 +70,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_vidattr.c,v 1.79 2023/04/28 20:59:26 tom Exp $")
+MODULE_ID("$Id: lib_vidattr.c,v 1.80 2024/12/07 20:08:15 tom Exp $")
 
 #define doPut(mode) \
 	TPUTS_TRACE(#mode); \
@@ -114,9 +114,9 @@
     attr_t turn_on, turn_off;
     int pair;
     bool reverse = FALSE;
-    bool can_color = (SP_PARM == 0 || SP_PARM->_coloron);
+    bool can_color = (SP_PARM == NULL || SP_PARM->_coloron);
 #if NCURSES_EXT_FUNCS
-    bool fix_pair0 = (SP_PARM != 0 && SP_PARM->_coloron && !SP_PARM->_default_color);
+    bool fix_pair0 = (SP_PARM != NULL && SP_PARM->_coloron && !SP_PARM->_default_color);
 #else
 #define fix_pair0 FALSE
 #endif
@@ -134,7 +134,7 @@
 
     TR(TRACE_ATTRS, ("previous attribute was %s", _traceattr(PreviousAttr)));
 
-    if ((SP_PARM != 0)
+    if ((SP_PARM != NULL)
 	&& (magic_cookie_glitch > 0)) {
 #if USE_XMC_SUPPORT
 	static const chtype table[] =
Index: ncurses/tty/tty_update.c
Prereq:  1.316 
--- ncurses-6.5-20241130+/ncurses/tty/tty_update.c	2024-02-04 00:09:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/tty/tty_update.c	2024-12-07 18:00:11.000000000 +0000
@@ -85,7 +85,7 @@
 
 #include <ctype.h>
 
-MODULE_ID("$Id: tty_update.c,v 1.316 2024/02/04 00:09:34 tom Exp $")
+MODULE_ID("$Id: tty_update.c,v 1.317 2024/12/07 18:00:11 tom Exp $")
 
 /*
  * This define controls the line-breakout optimization.  Every once in a
@@ -262,7 +262,7 @@
 		|| (SP_PARM->_legacy_coding > 1 && CharOf(CHDEREF(ch)) >= 128)
 		|| (AttrOf(attr) & A_ALTCHARSET
 		    && ((CharOfD(ch) < ACS_LEN
-			 && SP_PARM->_acs_map != 0
+			 && SP_PARM->_acs_map != NULL
 			 && SP_PARM->_acs_map[CharOfD(ch)] != 0)
 			|| (CharOfD(ch) >= 128))))) {
 	    ;
@@ -275,7 +275,7 @@
 #endif
 
     if ((AttrOf(attr) & A_ALTCHARSET)
-	&& SP_PARM->_acs_map != 0
+	&& SP_PARM->_acs_map != NULL
 	&& ((CharOfD(ch) < ACS_LEN)
 #if !NCURSES_WCWIDTH_GRAPHICS
 	    || is_wacs_value(CharOfD(ch))
@@ -621,7 +621,7 @@
 		} else {
 		    return 1;	/* cursor stays in the middle */
 		}
-	    } else if (repeat_char != 0 &&
+	    } else if (repeat_char != NULL &&
 #if BSD_TPUTS
 		       !isdigit(UChar(CharOf(ntext0))) &&
 #endif
@@ -643,7 +643,7 @@
 		UpdateAttrs(SP_PARM, ntext0);
 		temp = ntext0;
 		if ((AttrOf(temp) & A_ALTCHARSET) &&
-		    SP_PARM->_acs_map != 0 &&
+		    SP_PARM->_acs_map != NULL &&
 		    (SP_PARM->_acs_map[CharOf(temp)] & A_CHARTEXT) != 0) {
 		    SetChar(temp,
 			    (SP_PARM->_acs_map[CharOf(ntext0)] & A_CHARTEXT),
@@ -745,7 +745,7 @@
 
     _nc_lock_global(update);
 
-    if (SP_PARM == 0) {
+    if (SP_PARM == NULL) {
 	_nc_unlock_global(update);
 	returnCode(ERR);
     }
@@ -762,7 +762,7 @@
     if (SP_PARM == CURRENT_SCREEN) {
 #endif
 #define SyncScreens(internal,exported) \
-	if (internal == 0) internal = exported; \
+	if (internal == NULL) internal = exported; \
 	if (internal != exported) exported = internal
 
 	SyncScreens(CurScreen(SP_PARM), curscr);
@@ -773,9 +773,9 @@
 #endif
 #endif /* !USE_REENTRANT */
 
-    if (CurScreen(SP_PARM) == 0
-	|| NewScreen(SP_PARM) == 0
-	|| StdScreen(SP_PARM) == 0) {
+    if (CurScreen(SP_PARM) == NULL
+	|| NewScreen(SP_PARM) == NULL
+	|| StdScreen(SP_PARM) == NULL) {
 	_nc_unlock_global(update);
 	returnCode(ERR);
     }
@@ -1132,7 +1132,7 @@
 ClrUpdate(NCURSES_SP_DCL0)
 {
     TR(TRACE_UPDATE, (T_CALLED("ClrUpdate")));
-    if (0 != SP_PARM) {
+    if (NULL != SP_PARM) {
 	int i;
 	NCURSES_CH_T blank = ClrBlank(NCURSES_SP_ARGx StdScreen(SP_PARM));
 	int nonempty = Min(screen_lines(SP_PARM),
@@ -1159,7 +1159,7 @@
 static void
 ClrToEOL(NCURSES_SP_DCLx NCURSES_CH_T blank, int needclear)
 {
-    if (CurScreen(SP_PARM) != 0
+    if (CurScreen(SP_PARM) != NULL
 	&& SP_PARM->_cursrow >= 0) {
 	int j;
 
@@ -2223,7 +2223,7 @@
 NCURSES_EXPORT(void)
 NCURSES_SP_NAME(_nc_screen_wrap) (NCURSES_SP_DCL0)
 {
-    if (SP_PARM != 0) {
+    if (SP_PARM != NULL) {
 
 	UpdateAttrs(SP_PARM, normal);
 #if NCURSES_EXT_FUNCS
@@ -2265,7 +2265,7 @@
 NCURSES_EXPORT(void)
 NCURSES_SP_NAME(_nc_do_xmc_glitch) (NCURSES_SP_DCLx attr_t previous)
 {
-    if (SP_PARM != 0) {
+    if (SP_PARM != NULL) {
 	attr_t chg = XMC_CHANGES(previous ^ AttrOf(SCREEN_ATTRS(SP_PARM)));
 
 	while (chg != 0) {
Index: ncurses/wcwidth.h
Prereq:  1.7 
--- ncurses-6.5-20241130+/ncurses/wcwidth.h	2024-09-21 15:49:15.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/wcwidth.h	2024-12-07 16:20:09.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: wcwidth.h,v 1.7 2024/09/21 15:49:15 tom Exp $ */
+/* $Id: wcwidth.h,v 1.8 2024/12/07 16:20:09 tom Exp $ */
 
 /*
  * Copyright 2002-2023,2024 by Thomas E. Dickey
@@ -230,7 +230,7 @@
 
   /* sorted list of non-overlapping intervals of non-spacing characters */
   /* generated by
-   *    uniset +cat=Me +cat=Mn +0600-0605 +061C +06DD +070F +1160-11FF +D7B0-D7C6 +D7CB-D7FB c 
+   *    uniset +cat=Me +cat=Mn +0600-0605 +061C +06DD +070F +1160-11FF +D7B0-D7C6 +D7CB-D7FB c
    */
   /* *INDENT-OFF* */
   /* generated by run-uniset 1.9 */
Index: ncurses/widechar/lib_add_wch.c
Prereq:  1.19 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_add_wch.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_add_wch.c	2024-12-07 18:00:11.000000000 +0000
@@ -40,7 +40,7 @@
 #include <wctype.h>
 #endif
 
-MODULE_ID("$Id: lib_add_wch.c,v 1.19 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: lib_add_wch.c,v 1.20 2024/12/07 18:00:11 tom Exp $")
 
 /* clone/adapt lib_addch.c */
 static const cchar_t blankchar = NewChar(BLANK_TEXT);
@@ -384,7 +384,7 @@
 	win->_flags &= ~_WRAPPED;
 	break;
     default:
-	if ((s = wunctrl(&ch)) != 0) {
+	if ((s = wunctrl(&ch)) != NULL) {
 	    while (*s) {
 		cchar_t sch;
 		SetChar(sch, *s++, AttrOf(ch));
Index: ncurses/widechar/lib_box_set.c
Prereq:  1.7 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_box_set.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_box_set.c	2024-12-07 20:08:15.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 2002-2009,2011 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_box_set.c,v 1.7 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_box_set.c,v 1.8 2024/12/07 20:08:15 tom Exp $")
 
 NCURSES_EXPORT(int)
 wborder_set(WINDOW *win,
@@ -67,7 +67,7 @@
     if (!win)
 	returnCode(ERR);
 
-#define RENDER_WITH_DEFAULT(ch,def) w ##ch = _nc_render(win, (ch == 0) ? *(const ARG_CH_T)def : *ch)
+#define RENDER_WITH_DEFAULT(ch,def) w ##ch = _nc_render(win, (ch == NULL) ? *(const ARG_CH_T)def : *ch)
 
     RENDER_WITH_DEFAULT(ls, WACS_VLINE);
     RENDER_WITH_DEFAULT(rs, WACS_VLINE);
Index: ncurses/widechar/lib_cchar.c
Prereq:  1.39 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_cchar.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_cchar.c	2024-12-07 18:07:52.000000000 +0000
@@ -37,7 +37,7 @@
 #include <curses.priv.h>
 #include <wchar.h>
 
-MODULE_ID("$Id: lib_cchar.c,v 1.39 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: lib_cchar.c,v 1.40 2024/12/07 18:07:52 tom Exp $")
 
 /*
  * The SuSv2 description leaves some room for interpretation.  We'll assume wch
@@ -135,7 +135,7 @@
 	     * If the value is not a null, return the length plus 1 for null.
 	     */
 	    code = (len < CCHARW_MAX) ? (len + 1) : CCHARW_MAX;
-	} else if (attrs == 0 || pair_arg == 0) {
+	} else if (attrs == NULL || pair_arg == NULL) {
 	    code = ERR;
 	} else if (len >= 0) {
 	    int color_pair;
Index: ncurses/widechar/lib_get_wch.c
Prereq:  1.26 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_get_wch.c	2021-04-17 16:12:54.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_get_wch.c	2024-12-07 20:08:15.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 2002-2011,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -41,7 +41,7 @@
 #include <curses.priv.h>
 #include <ctype.h>
 
-MODULE_ID("$Id: lib_get_wch.c,v 1.26 2021/04/17 16:12:54 tom Exp $")
+MODULE_ID("$Id: lib_get_wch.c,v 1.27 2024/12/07 20:08:15 tom Exp $")
 
 NCURSES_EXPORT(int)
 wget_wch(WINDOW *win, wint_t *result)
@@ -62,7 +62,7 @@
     _nc_lock_global(curses);
     sp = _nc_screen_of(win);
 
-    if (sp != 0) {
+    if (sp != NULL) {
 	size_t count = 0;
 
 	for (;;) {
@@ -112,7 +112,7 @@
 	code = ERR;
     }
 
-    if (result != 0)
+    if (result != NULL)
 	*result = (wint_t) value;
 
     _nc_unlock_global(curses);
Index: ncurses/widechar/lib_hline_set.c
Prereq:  1.6 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_hline_set.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_hline_set.c	2024-12-07 20:08:15.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 2002-2010,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_hline_set.c,v 1.6 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_hline_set.c,v 1.7 2024/12/07 20:08:15 tom Exp $")
 
 NCURSES_EXPORT(int)
 whline_set(WINDOW *win, const cchar_t *ch, int n)
@@ -60,7 +60,7 @@
 
 	CHANGED_RANGE(line, start, end);
 
-	if (ch == 0)
+	if (ch == NULL)
 	    wch = *WACS_HLINE;
 	else
 	    wch = *ch;
Index: ncurses/widechar/lib_in_wch.c
Prereq:  1.7 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_in_wch.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_in_wch.c	2024-12-07 20:08:15.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 2002-2009,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_in_wch.c,v 1.7 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_in_wch.c,v 1.8 2024/12/07 20:08:15 tom Exp $")
 
 NCURSES_EXPORT(int)
 win_wch(WINDOW *win, cchar_t *wcval)
@@ -49,8 +49,8 @@
 
     TR(TRACE_CCALLS, (T_CALLED("win_wch(%p,%p)"), (void *) win, (void *) wcval));
 
-    if (win != 0
-	&& wcval != 0) {
+    if (win != NULL
+	&& wcval != NULL) {
 	int row, col;
 
 	getyx(win, row, col);
Index: ncurses/widechar/lib_in_wchnstr.c
Prereq:  1.10 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_in_wchnstr.c	2024-07-27 19:23:21.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_in_wchnstr.c	2024-12-07 18:03:14.000000000 +0000
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_in_wchnstr.c,v 1.10 2024/07/27 19:23:21 tom Exp $")
+MODULE_ID("$Id: lib_in_wchnstr.c,v 1.11 2024/12/07 18:03:14 tom Exp $")
 
 NCURSES_EXPORT(int)
 win_wchnstr(WINDOW *win, cchar_t *wchstr, int n)
@@ -48,8 +48,8 @@
     int code = OK;
 
     T((T_CALLED("win_wchnstr(%p,%p,%d)"), (void *) win, (void *) wchstr, n));
-    if (win != 0
-	&& wchstr != 0) {
+    if (win != NULL
+	&& wchstr != NULL) {
 	const NCURSES_CH_T *src;
 	int row, col;
 	int j, k, limit;
Index: ncurses/widechar/lib_ins_wch.c
Prereq:  1.30 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_ins_wch.c	2024-07-27 19:22:23.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_ins_wch.c	2024-12-07 18:03:14.000000000 +0000
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_ins_wch.c,v 1.30 2024/07/27 19:22:23 tom Exp $")
+MODULE_ID("$Id: lib_ins_wch.c,v 1.31 2024/12/07 18:03:14 tom Exp $")
 
 /*
  * Insert the given character, updating the current location to simplify
@@ -87,7 +87,7 @@
 
     T((T_CALLED("wins_wch(%p, %s)"), (void *) win, _tracecchar_t(wch)));
 
-    if (win != 0) {
+    if (win != NULL) {
 	NCURSES_SIZE_T oy = win->_cury;
 	NCURSES_SIZE_T ox = win->_curx;
 
@@ -108,8 +108,8 @@
     T((T_CALLED("wins_nwstr(%p,%s,%d)"),
        (void *) win, _nc_viswbufn(wstr, n), n));
 
-    if (win != 0
-	&& wstr != 0
+    if (win != NULL
+	&& wstr != NULL
 	&& n != 0) {
 
 	if (n < 0) {
Index: ncurses/widechar/lib_inwstr.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_inwstr.c	2024-07-27 19:02:27.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_inwstr.c	2024-12-07 18:03:14.000000000 +0000
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_inwstr.c,v 1.11 2024/07/27 19:02:27 tom Exp $")
+MODULE_ID("$Id: lib_inwstr.c,v 1.12 2024/12/07 18:03:14 tom Exp $")
 
 NCURSES_EXPORT(int)
 winnwstr(WINDOW *win, wchar_t *wstr, int n)
@@ -49,7 +49,7 @@
     const cchar_t *text;
 
     T((T_CALLED("winnwstr(%p,%p,%d)"), (void *) win, (void *) wstr, n));
-    if (wstr != 0) {
+    if (wstr != NULL) {
 	if (win) {
 	    int row, col;
 	    int last = 0;
@@ -99,7 +99,7 @@
     int result = ERR;
 
     T((T_CALLED("winwstr(%p,%p)"), (void *) win, (void *) wstr));
-    if (win != 0) {
+    if (win != NULL) {
 	result = winnwstr(win, wstr,
 			  CCHARW_MAX * (win->_maxx - win->_curx + 1));
     }
Index: ncurses/widechar/lib_pecho_wchar.c
Prereq:  1.4 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_pecho_wchar.c	2021-10-23 17:07:56.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_pecho_wchar.c	2024-12-07 20:08:15.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 2004,2009 Free Software Foundation, Inc.                       *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -33,14 +33,14 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_pecho_wchar.c,v 1.4 2021/10/23 17:07:56 tom Exp $")
+MODULE_ID("$Id: lib_pecho_wchar.c,v 1.5 2024/12/07 20:08:15 tom Exp $")
 
 NCURSES_EXPORT(int)
 pecho_wchar(WINDOW *pad, const cchar_t *wch)
 {
     T((T_CALLED("pecho_wchar(%p, %s)"), (void *) pad, _tracech_t(wch)));
 
-    if (pad == 0)
+    if (pad == NULL)
 	returnCode(ERR);
 
     if (!IS_PAD(pad))
Index: ncurses/widechar/lib_slk_wset.c
Prereq:  1.15 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_slk_wset.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_slk_wset.c	2024-12-07 20:08:15.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 2003-2011,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -41,7 +41,7 @@
 #include <wctype.h>
 #endif
 
-MODULE_ID("$Id: lib_slk_wset.c,v 1.15 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_slk_wset.c,v 1.16 2024/12/07 20:08:15 tom Exp $")
 
 NCURSES_EXPORT(int)
 slk_wset(int i, const wchar_t *astr, int format)
@@ -52,7 +52,7 @@
 
     T((T_CALLED("slk_wset(%d, %s, %d)"), i, _nc_viswbuf(astr), format));
 
-    if (astr != 0) {
+    if (astr != NULL) {
 	size_t arglen;
 
 	init_mb(state);
@@ -61,7 +61,7 @@
 	if ((arglen = wcsrtombs(NULL, &str, (size_t) 0, &state)) != (size_t) -1) {
 	    char *mystr;
 
-	    if ((mystr = (char *) _nc_doalloc(0, arglen + 1)) != 0) {
+	    if ((mystr = (char *) _nc_doalloc(NULL, arglen + 1)) != NULL) {
 		str = astr;
 		if (wcsrtombs(mystr, &str, arglen, &state) != (size_t) -1) {
 		    /* glibc documentation claims that the terminating L'\0'
Index: ncurses/widechar/lib_unget_wch.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_unget_wch.c	2023-06-03 12:50:52.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_unget_wch.c	2024-12-07 20:08:15.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2023 Thomas E. Dickey                                     *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 2002-2011,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_unget_wch.c,v 1.18 2023/06/03 12:50:52 tom Exp $")
+MODULE_ID("$Id: lib_unget_wch.c,v 1.19 2024/12/07 20:08:15 tom Exp $")
 
 /*
  * Wrapper for wcrtomb() which obtains the length needed for the given
@@ -51,7 +51,7 @@
 {
     int result;
 
-    if (target == 0) {
+    if (target == NULL) {
 	wchar_t temp[2];
 	const wchar_t *tempp = temp;
 	temp[0] = source;
@@ -75,13 +75,13 @@
     T((T_CALLED("unget_wch(%p, %#lx)"), (void *) SP_PARM, (unsigned long) wch));
 
     init_mb(state);
-    length = _nc_wcrtomb(0, wch, &state);
+    length = _nc_wcrtomb(NULL, wch, &state);
 
     if (length != (size_t) (-1)
 	&& length != 0) {
 	char *string;
 
-	if ((string = (char *) malloc(length)) != 0) {
+	if ((string = (char *) malloc(length)) != NULL) {
 	    int n;
 
 	    init_mb(state);
Index: ncurses/widechar/lib_vid_attr.c
Prereq:  1.31 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_vid_attr.c	2023-04-28 20:59:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_vid_attr.c	2024-12-07 20:08:59.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2020,2023 Thomas E. Dickey                                *
+ * Copyright 2018-2023,2024 Thomas E. Dickey                                *
  * Copyright 2002-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -37,7 +37,7 @@
 #define CUR SP_TERMTYPE
 #endif
 
-MODULE_ID("$Id: lib_vid_attr.c,v 1.31 2023/04/28 20:59:34 tom Exp $")
+MODULE_ID("$Id: lib_vid_attr.c,v 1.32 2024/12/07 20:08:59 tom Exp $")
 
 #define doPut(mode) \
 	TPUTS_TRACE(#mode); \
@@ -87,9 +87,9 @@
 
     attr_t turn_on, turn_off;
     bool reverse = FALSE;
-    bool can_color = (SP_PARM == 0 || SP_PARM->_coloron);
+    bool can_color = (SP_PARM == NULL || SP_PARM->_coloron);
 #if NCURSES_EXT_FUNCS
-    bool fix_pair0 = (SP_PARM != 0 && SP_PARM->_coloron && !SP_PARM->_default_color);
+    bool fix_pair0 = (SP_PARM != NULL && SP_PARM->_coloron && !SP_PARM->_default_color);
 #else
 #define fix_pair0 FALSE
 #endif
@@ -193,15 +193,15 @@
 	    TPUTS_TRACE("set_attributes");
 	    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx
 				    TIPARM_9(set_attributes,
-					       (newmode & A_STANDOUT) != 0,
-					       (newmode & A_UNDERLINE) != 0,
-					       (newmode & A_REVERSE) != 0,
-					       (newmode & A_BLINK) != 0,
-					       (newmode & A_DIM) != 0,
-					       (newmode & A_BOLD) != 0,
-					       (newmode & A_INVIS) != 0,
-					       (newmode & A_PROTECT) != 0,
-					       (newmode & A_ALTCHARSET) != 0),
+					     (newmode & A_STANDOUT) != 0,
+					     (newmode & A_UNDERLINE) != 0,
+					     (newmode & A_REVERSE) != 0,
+					     (newmode & A_BLINK) != 0,
+					     (newmode & A_DIM) != 0,
+					     (newmode & A_BOLD) != 0,
+					     (newmode & A_INVIS) != 0,
+					     (newmode & A_PROTECT) != 0,
+					     (newmode & A_ALTCHARSET) != 0),
 				    1, outc);
 	    previous_attr &= ALL_BUT_COLOR;
 	    previous_pair = 0;
Index: ncurses/widechar/lib_vline_set.c
Prereq:  1.6 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_vline_set.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_vline_set.c	2024-12-07 20:08:15.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 2002-2010,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -40,7 +40,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_vline_set.c,v 1.6 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_vline_set.c,v 1.7 2024/12/07 20:08:15 tom Exp $")
 
 NCURSES_EXPORT(int)
 wvline_set(WINDOW *win, const cchar_t *ch, int n)
@@ -58,7 +58,7 @@
 	if (end > win->_maxy)
 	    end = win->_maxy;
 
-	if (ch == 0)
+	if (ch == NULL)
 	    wch = *WACS_VLINE;
 	else
 	    wch = *ch;
Index: ncurses/widechar/lib_wacs.c
Prereq:  1.20 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_wacs.c	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_wacs.c	2024-12-07 20:08:32.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018,2020 Thomas E. Dickey                                     *
+ * Copyright 2018-2020,2024 Thomas E. Dickey                                *
  * Copyright 2002-2015,2016 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -33,9 +33,9 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_wacs.c,v 1.20 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: lib_wacs.c,v 1.21 2024/12/07 20:08:32 tom Exp $")
 
-NCURSES_EXPORT_VAR(cchar_t) * _nc_wacs = 0;
+NCURSES_EXPORT_VAR(cchar_t) * _nc_wacs = NULL;
 
 NCURSES_EXPORT(void)
 _nc_init_wacs(void)
@@ -119,7 +119,7 @@
     T(("initializing WIDE-ACS map (Unicode is%s active)",
        active ? "" : " not"));
 
-    if ((_nc_wacs = typeCalloc(cchar_t, ACS_LEN)) != 0) {
+    if ((_nc_wacs = typeCalloc(cchar_t, ACS_LEN)) != NULL) {
 	unsigned n;
 
 	for (n = 0; n < SIZEOF(table); ++n) {
Index: ncurses/widechar/lib_wunctrl.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/ncurses/widechar/lib_wunctrl.c	2024-07-27 19:23:21.000000000 +0000
+++ ncurses-6.5-20241207/ncurses/widechar/lib_wunctrl.c	2024-12-07 18:03:14.000000000 +0000
@@ -36,7 +36,7 @@
 
 #include <curses.priv.h>
 
-MODULE_ID("$Id: lib_wunctrl.c,v 1.18 2024/07/27 19:23:21 tom Exp $")
+MODULE_ID("$Id: lib_wunctrl.c,v 1.19 2024/12/07 18:03:14 tom Exp $")
 
 NCURSES_EXPORT(wchar_t *)
 NCURSES_SP_NAME(wunctrl) (NCURSES_SP_DCLx cchar_t *wc)
@@ -44,9 +44,9 @@
     static wchar_t str[CCHARW_MAX + 1];
     wchar_t *result;
 
-    if (wc == 0) {
-	result = 0;
-    } else if (SP_PARM != 0 && Charable(*wc)) {
+    if (wc == NULL) {
+	result = NULL;
+    } else if (SP_PARM != NULL && Charable(*wc)) {
 	wchar_t *wsp;
 	const char *p =
 	NCURSES_SP_NAME(unctrl) (NCURSES_SP_ARGx
Index: package/debian-mingw/changelog
--- ncurses-6.5-20241130+/package/debian-mingw/changelog	2024-11-27 21:55:07.000000000 +0000
+++ ncurses-6.5-20241207/package/debian-mingw/changelog	2024-12-07 11:51:44.000000000 +0000
@@ -1,8 +1,8 @@
-ncurses6td (6.5+20241130) unstable; urgency=low
+ncurses6td (6.5+20241207) unstable; urgency=low
 
   * latest weekly patch
 
- -- Thomas E. Dickey <dickey@invisible-island.net>  Wed, 27 Nov 2024 16:55:07 -0500
+ -- Thomas E. Dickey <dickey@invisible-island.net>  Sat, 07 Dec 2024 06:51:44 -0500
 
 ncurses6 (5.9+20131005) unstable; urgency=low
 
Index: package/debian-mingw64/changelog
--- ncurses-6.5-20241130+/package/debian-mingw64/changelog	2024-11-27 21:55:07.000000000 +0000
+++ ncurses-6.5-20241207/package/debian-mingw64/changelog	2024-12-07 11:51:44.000000000 +0000
@@ -1,8 +1,8 @@
-ncurses6td (6.5+20241130) unstable; urgency=low
+ncurses6td (6.5+20241207) unstable; urgency=low
 
   * latest weekly patch
 
- -- Thomas E. Dickey <dickey@invisible-island.net>  Wed, 27 Nov 2024 16:55:07 -0500
+ -- Thomas E. Dickey <dickey@invisible-island.net>  Sat, 07 Dec 2024 06:51:44 -0500
 
 ncurses6 (5.9+20131005) unstable; urgency=low
 
Index: package/debian/changelog
--- ncurses-6.5-20241130+/package/debian/changelog	2024-11-27 21:55:07.000000000 +0000
+++ ncurses-6.5-20241207/package/debian/changelog	2024-12-07 11:51:44.000000000 +0000
@@ -1,8 +1,8 @@
-ncurses6td (6.5+20241130) unstable; urgency=low
+ncurses6td (6.5+20241207) unstable; urgency=low
 
   * latest weekly patch
 
- -- Thomas E. Dickey <dickey@invisible-island.net>  Wed, 27 Nov 2024 16:55:07 -0500
+ -- Thomas E. Dickey <dickey@invisible-island.net>  Sat, 07 Dec 2024 06:51:44 -0500
 
 ncurses6 (5.9+20120608) unstable; urgency=low
 
Index: package/mingw-ncurses.nsi
Prereq:  1.678 
--- ncurses-6.5-20241130+/package/mingw-ncurses.nsi	2024-11-27 21:55:07.000000000 +0000
+++ ncurses-6.5-20241207/package/mingw-ncurses.nsi	2024-12-07 11:51:44.000000000 +0000
@@ -1,4 +1,4 @@
-; $Id: mingw-ncurses.nsi,v 1.678 2024/11/27 21:55:07 tom Exp $
+; $Id: mingw-ncurses.nsi,v 1.679 2024/12/07 11:51:44 tom Exp $
 
 ; TODO add examples
 ; TODO bump ABI to 6
@@ -10,7 +10,7 @@
 !define VERSION_MAJOR "6"
 !define VERSION_MINOR "5"
 !define VERSION_YYYY  "2024"
-!define VERSION_MMDD  "1130"
+!define VERSION_MMDD  "1207"
 !define VERSION_PATCH ${VERSION_YYYY}${VERSION_MMDD}
 
 !define MY_ABI   "5"
Index: package/mingw-ncurses.spec
--- ncurses-6.5-20241130+/package/mingw-ncurses.spec	2024-11-27 21:55:07.000000000 +0000
+++ ncurses-6.5-20241207/package/mingw-ncurses.spec	2024-12-07 11:51:44.000000000 +0000
@@ -3,7 +3,7 @@
 Summary: shared libraries for terminal handling
 Name: mingw32-ncurses6
 Version: 6.5
-Release: 20241130
+Release: 20241207
 License: X11
 Group: Development/Libraries
 URL: https://invisible-island.net/ncurses/
Index: package/ncurses.spec
--- ncurses-6.5-20241130+/package/ncurses.spec	2024-11-27 21:55:07.000000000 +0000
+++ ncurses-6.5-20241207/package/ncurses.spec	2024-12-07 11:51:44.000000000 +0000
@@ -1,7 +1,7 @@
 Summary: shared libraries for terminal handling
 Name: ncurses6
 Version: 6.5
-Release: 20241130
+Release: 20241207
 License: X11
 Group: Development/Libraries
 URL: https://invisible-island.net/ncurses/
Index: package/ncursest.spec
--- ncurses-6.5-20241130+/package/ncursest.spec	2024-11-27 21:55:07.000000000 +0000
+++ ncurses-6.5-20241207/package/ncursest.spec	2024-12-07 11:51:44.000000000 +0000
@@ -1,7 +1,7 @@
 Summary: Curses library with POSIX thread support.
 Name: ncursest6
 Version: 6.5
-Release: 20241130
+Release: 20241207
 License: X11
 Group: Development/Libraries
 Source: ncurses-%{version}-%{release}.tgz
Index: panel/p_above.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/panel/p_above.c	2020-05-24 01:40:20.000000000 +0000
+++ ncurses-6.5-20241207/panel/p_above.c	2024-12-07 23:05:20.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2010,2012 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -37,11 +37,11 @@
  */
 #include "panel.priv.h"
 
-MODULE_ID("$Id: p_above.c,v 1.11 2020/05/24 01:40:20 anonymous.maarten Exp $")
+MODULE_ID("$Id: p_above.c,v 1.12 2024/12/07 23:05:20 tom Exp $")
 
 #if NCURSES_SP_FUNCS
 PANEL_EXPORT(PANEL *)
-ground_panel(SCREEN * sp)
+ground_panel(SCREEN *sp)
 {
   T((T_CALLED("ground_panel(%p)"), (void *)sp));
   if (sp)
@@ -51,12 +51,12 @@
       if (_nc_bottom_panel)	/* this is the pseudo panel */
 	returnPanel(_nc_bottom_panel->above);
       else
-	returnPanel(0);
+	returnPanel(NULL);
     }
   else
     {
-      if (0 == CURRENT_SCREEN)
-	returnPanel(0);
+      if (NULL == CURRENT_SCREEN)
+	returnPanel(NULL);
       else
 	returnPanel(ground_panel(CURRENT_SCREEN));
     }
@@ -64,7 +64,7 @@
 #endif
 
 PANEL_EXPORT(PANEL *)
-panel_above(const PANEL * pan)
+panel_above(const PANEL *pan)
 {
   PANEL *result;
 
@@ -78,7 +78,7 @@
 #else
       /* if top and bottom are equal, we have no or only the pseudo panel;
          if not, we return the panel above the pseudo panel */
-      result = EMPTY_STACK()? (PANEL *) 0 : _nc_bottom_panel->above;
+      result = EMPTY_STACK()? (PANEL *)0 : _nc_bottom_panel->above;
 #endif
     }
   returnPanel(result);
Index: panel/p_below.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/panel/p_below.c	2020-05-24 01:40:20.000000000 +0000
+++ ncurses-6.5-20241207/panel/p_below.c	2024-12-07 23:05:20.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2010,2012 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -37,11 +37,11 @@
  */
 #include "panel.priv.h"
 
-MODULE_ID("$Id: p_below.c,v 1.11 2020/05/24 01:40:20 anonymous.maarten Exp $")
+MODULE_ID("$Id: p_below.c,v 1.12 2024/12/07 23:05:20 tom Exp $")
 
 #if NCURSES_SP_FUNCS
 PANEL_EXPORT(PANEL *)
-ceiling_panel(SCREEN * sp)
+ceiling_panel(SCREEN *sp)
 {
   T((T_CALLED("ceiling_panel(%p)"), (void *)sp));
   if (sp)
@@ -49,12 +49,12 @@
       struct panelhook *ph = NCURSES_SP_NAME(_nc_panelhook) (sp);
 
       /* if top and bottom are equal, we have no or only the pseudo panel */
-      returnPanel(EMPTY_STACK()? (PANEL *) 0 : _nc_top_panel);
+      returnPanel(EMPTY_STACK()? (PANEL *)0 : _nc_top_panel);
     }
   else
     {
-      if (0 == CURRENT_SCREEN)
-	returnPanel(0);
+      if (NULL == CURRENT_SCREEN)
+	returnPanel(NULL);
       else
 	returnPanel(ceiling_panel(CURRENT_SCREEN));
     }
@@ -62,7 +62,7 @@
 #endif
 
 PANEL_EXPORT(PANEL *)
-panel_below(const PANEL * pan)
+panel_below(const PANEL *pan)
 {
   PANEL *result;
 
@@ -71,7 +71,7 @@
     {
       GetHook(pan);
       /* we must not return the pseudo panel */
-      result = Is_Pseudo(pan->below) ? (PANEL *) 0 : pan->below;
+      result = Is_Pseudo(pan->below) ? (PANEL *)0 : pan->below;
     }
   else
     {
@@ -79,7 +79,7 @@
       result = ceiling_panel(CURRENT_SCREEN);
 #else
       /* if top and bottom are equal, we have no or only the pseudo panel */
-      result = EMPTY_STACK()? (PANEL *) 0 : _nc_top_panel;
+      result = EMPTY_STACK()? (PANEL *)0 : _nc_top_panel;
 #endif
     }
   returnPanel(result);
Index: panel/p_new.c
Prereq:  1.24 
--- ncurses-6.5-20241130+/panel/p_new.c	2021-10-23 15:12:06.000000000 +0000
+++ ncurses-6.5-20241207/panel/p_new.c	2024-12-07 23:00:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2021 Thomas E. Dickey                                     *
+ * Copyright 2020-2021,2024 Thomas E. Dickey                                *
  * Copyright 1998-2009,2010 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -39,7 +39,7 @@
  */
 #include "panel.priv.h"
 
-MODULE_ID("$Id: p_new.c,v 1.24 2021/10/23 15:12:06 tom Exp $")
+MODULE_ID("$Id: p_new.c,v 1.25 2024/12/07 23:00:37 tom Exp $")
 
 #ifdef TRACE
 static char *stdscr_id;
@@ -86,7 +86,7 @@
       ph->destroy = del_panel;
 #endif
       _nc_stdscr_pseudo_panel = AllocPanel("root_panel");
-      if (_nc_stdscr_pseudo_panel != 0)
+      if (_nc_stdscr_pseudo_panel != NULL)
 	{
 	  PANEL *pan = _nc_stdscr_pseudo_panel;
 	  WINDOW *win = SP_PARM->_stdscr;
Index: panel/panel.c
Prereq:  1.30 
--- ncurses-6.5-20241130+/panel/panel.c	2020-09-26 18:05:17.000000000 +0000
+++ ncurses-6.5-20241207/panel/panel.c	2024-12-07 23:05:20.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2010,2012 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -37,14 +37,14 @@
 /* panel.c -- implementation of panels library, some core routines */
 #include "panel.priv.h"
 
-MODULE_ID("$Id: panel.c,v 1.30 2020/09/26 18:05:17 tom Exp $")
+MODULE_ID("$Id: panel.c,v 1.31 2024/12/07 23:05:20 tom Exp $")
 
 /*+-------------------------------------------------------------------------
 	_nc_retrace_panel (pan)
 --------------------------------------------------------------------------*/
 #ifdef TRACE
 PANEL_EXPORT(PANEL *)
-_nc_retrace_panel(PANEL * pan)
+_nc_retrace_panel(PANEL *pan)
 {
   T((T_RETURN("%p"), (void *)pan));
   return pan;
@@ -61,7 +61,7 @@
 {
   char temp[32];
 
-  if (ptr != 0)
+  if (ptr != NULL)
     _nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp)) "%p", ptr);
   else
     _nc_STRCPY(temp, "<null>", sizeof(temp));
@@ -75,7 +75,7 @@
 --------------------------------------------------------------------------*/
 #ifdef TRACE
 PANEL_EXPORT(void)
-_nc_dPanel(const char *text, const PANEL * pan)
+_nc_dPanel(const char *text, const PANEL *pan)
 {
   _tracef("%s id=%s b=%s a=%s y=%d x=%d",
 	  text, USER_PTR(pan->user, 1),
@@ -90,7 +90,7 @@
 --------------------------------------------------------------------------*/
 #ifdef TRACE
 PANEL_EXPORT(void)
-_nc_dStack(const char *fmt, int num, const PANEL * pan)
+_nc_dStack(const char *fmt, int num, const PANEL *pan)
 {
   char s80[80];
 
@@ -116,7 +116,7 @@
 --------------------------------------------------------------------------*/
 #ifdef TRACE
 PANEL_EXPORT(void)
-_nc_Wnoutrefresh(const PANEL * pan)
+_nc_Wnoutrefresh(const PANEL *pan)
 {
   dPanel("wnoutrefresh", pan);
   wnoutrefresh(pan->win);
@@ -128,7 +128,7 @@
 --------------------------------------------------------------------------*/
 #ifdef TRACE
 PANEL_EXPORT(void)
-_nc_Touchpan(const PANEL * pan)
+_nc_Touchpan(const PANEL *pan)
 {
   dPanel("Touchpan", pan);
   touchwin(pan->win);
@@ -140,7 +140,7 @@
 --------------------------------------------------------------------------*/
 #ifdef TRACE
 PANEL_EXPORT(void)
-_nc_Touchline(const PANEL * pan, int start, int count)
+_nc_Touchline(const PANEL *pan, int start, int count)
 {
   char s80[80];
 
Index: panel/panel.priv.h
Prereq:  1.30 
--- ncurses-6.5-20241130+/panel/panel.priv.h	2020-09-26 18:05:32.000000000 +0000
+++ ncurses-6.5-20241207/panel/panel.priv.h	2024-12-07 23:01:42.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020 Thomas E. Dickey                                          *
+ * Copyright 2020,2024 Thomas E. Dickey                                     *
  * Copyright 1998-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 
-/* $Id: panel.priv.h,v 1.30 2020/09/26 18:05:32 tom Exp $ */
+/* $Id: panel.priv.h,v 1.31 2024/12/07 23:01:42 tom Exp $ */
 
 #ifndef NCURSES_PANEL_PRIV_H
 #define NCURSES_PANEL_PRIV_H 1
@@ -86,7 +86,7 @@
 #define GetScreenHook(sp) \
 			struct panelhook* ph = NCURSES_SP_NAME(_nc_panelhook)(sp)
 #define GetPanelHook(pan) \
-			GetScreenHook(pan ? _nc_screen_of((pan)->win) : 0)
+			GetScreenHook(pan ? _nc_screen_of((pan)->win) : NULL)
 #define GetWindowHook(win) \
 			SCREEN* sp = _nc_screen_of(win); \
 			GetScreenHook(sp)
Index: progs/dump_entry.c
Prereq:  1.197 
--- ncurses-6.5-20241130+/progs/dump_entry.c	2024-10-19 22:00:53.000000000 +0000
+++ ncurses-6.5-20241207/progs/dump_entry.c	2024-12-07 22:06:39.000000000 +0000
@@ -40,7 +40,7 @@
 #include <termsort.h>		/* this C file is generated */
 #include <parametrized.h>	/* so is this */
 
-MODULE_ID("$Id: dump_entry.c,v 1.197 2024/10/19 22:00:53 tom Exp $")
+MODULE_ID("$Id: dump_entry.c,v 1.198 2024/12/07 22:06:39 tom Exp $")
 
 #define DISCARD(string) string = ABSENT_STRING
 #define PRINTF (void) printf
@@ -121,7 +121,7 @@
     if (want > dst->size) {
 	dst->size += (want + 1024);	/* be generous */
 	dst->text = typeRealloc(char, dst->size, dst->text);
-	if (dst->text == 0)
+	if (dst->text == NULL)
 	    failed("strncpy_DYN");
     }
     _nc_STRNCPY(dst->text + dst->used, src, need + 1);
@@ -132,7 +132,7 @@
 static void
 strcpy_DYN(DYNBUF * dst, const char *src)
 {
-    if (src == 0) {
+    if (src == NULL) {
 	dst->used = 0;
 	strcpy_DYN(dst, "");
     } else {
@@ -144,9 +144,9 @@
 static void
 free_DYN(DYNBUF * p)
 {
-    if (p->text != 0)
+    if (p->text != NULL)
 	free(p->text);
-    p->text = 0;
+    p->text = NULL;
     p->size = 0;
     p->used = 0;
 }
@@ -170,7 +170,7 @@
 {
     const struct name_table_entry *np;
 
-    if ((np = _nc_find_entry(name, _nc_get_hash_table(0))) != 0) {
+    if ((np = _nc_find_entry(name, _nc_get_hash_table(0))) != NULL) {
 	switch (np->nte_type) {
 	case BOOLEAN:
 	    NameTrans(bool_from_termcap, boolcodes);
@@ -186,7 +186,7 @@
 	}
     }
 
-    return (0);
+    return (NULL);
 }
 
 void
@@ -212,7 +212,7 @@
     did_wrap = (width <= 0);
 
     /* versions */
-    if (version == 0)
+    if (version == NULL)
 	tversion = V_ALLCAPS;
     else if (!strcmp(version, "SVr1") || !strcmp(version, "SVR1")
 	     || !strcmp(version, "Ultrix"))
@@ -458,7 +458,7 @@
 		}
 		n++;
 	    }
-	} else if (strchr("pPg", ch) != 0) {
+	} else if (strchr("pPg", ch) != NULL) {
 	    result += 2;
 	} else {
 	    result++;		/* ordinary operator */
@@ -526,7 +526,7 @@
     const char *fill = "\\s";
     size_t need = strlen(src);
     size_t size = strlen(fill);
-    char *result = 0;
+    char *result = NULL;
     int pass;
     size_t s, d;
     for (pass = 0; pass < 2; ++pass) {
@@ -550,7 +550,7 @@
 	    result[d] = '\0';
 	} else {
 	    result = calloc(need + 1, sizeof(char));
-	    if (result == 0)
+	    if (result == NULL)
 		failed("fill_spaces");
 	}
     }
@@ -598,7 +598,7 @@
 	if (TcOutput())
 	    trailer = "\\\n\t ";
 
-	if (!TcOutput() && (p = strchr(fill, '=')) != 0) {
+	if (!TcOutput() && (p = strchr(fill, '=')) != NULL) {
 	    base = (int) (p + 1 - fill);
 	    if (base > 8)
 		base = 8;
@@ -612,7 +612,7 @@
 	    align[base] = '\0';
 	}
 	/* "pretty" overrides wrapping if it already split the line */
-	if (!pretty || strchr(fill, '\n') == 0) {
+	if (!pretty || strchr(fill, '\n') == NULL) {
 	    int tag = 0;
 
 	    if (TcOutput() && outbuf.used && !wrap_1ST(mode)) {
@@ -841,7 +841,7 @@
 		    strncpy_DYN(&tmpbuf, src++, (size_t) 1);
 		    if (src[0] == '%'
 			&& src[1] != '\0'
-			&& (strchr("?e;", src[1])) == 0) {
+			&& (strchr("?e;", src[1])) == NULL) {
 			tmpbuf.text[tmpbuf.used++] = '\n';
 			indent_DYN(&tmpbuf, level);
 		    }
@@ -926,12 +926,12 @@
 
     len = 12;			/* terminfo file-header */
 
-    if (pred == 0) {
+    if (pred == NULL) {
 	cur_type = tterm;
 	pred = dump_predicate;
     }
 
-    strcpy_DYN(&outbuf, 0);
+    strcpy_DYN(&outbuf, NULL);
     if (content_only) {
 	column = indent;	/* workaround to prevent empty lines */
     } else {
@@ -1120,7 +1120,7 @@
 				 : has_params(srccap, FALSE)));
 		const char *cv = _nc_infotocap(name, srccap, params);
 
-		if (cv == 0) {
+		if (cv == NULL) {
 		    if (outform == F_TCONVERR) {
 			_nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))
 				    "%s=!!! %s WILL NOT CONVERT !!!",
@@ -1169,7 +1169,7 @@
 		char *src = _nc_tic_expand(capability,
 					   outform == F_TERMINFO, numbers);
 
-		strcpy_DYN(&tmpbuf, 0);
+		strcpy_DYN(&tmpbuf, NULL);
 		strcpy_DYN(&tmpbuf, name);
 		strcpy_DYN(&tmpbuf, "=");
 		if (pretty
@@ -1400,7 +1400,7 @@
  * Check if the given acsc string is a 1-1 mapping, i.e., just-like-vt100.
  * Also, since this is for termcap, we only care about the line-drawing map.
  */
-#define isLine(c) (strchr("lmkjtuvwqxn", c) != 0)
+#define isLine(c) (strchr("lmkjtuvwqxn", c) != NULL)
 
 static bool
 one_one_mapping(const char *mapping)
@@ -1703,7 +1703,7 @@
 	}
 	outbuf.text[outbuf.used] = '\0';
     }
-    if (outbuf.text != 0) {
+    if (outbuf.text != NULL) {
 	(void) fputs(outbuf.text, stdout);
 	putchar('\n');
     }
Index: progs/infocmp.c
Prereq:  1.169 
--- ncurses-6.5-20241130+/progs/infocmp.c	2024-11-30 21:29:41.000000000 +0000
+++ ncurses-6.5-20241207/progs/infocmp.c	2024-12-07 22:10:45.000000000 +0000
@@ -43,7 +43,7 @@
 
 #include <dump_entry.h>
 
-MODULE_ID("$Id: infocmp.c,v 1.169 2024/11/30 21:29:41 tom Exp $")
+MODULE_ID("$Id: infocmp.c,v 1.170 2024/12/07 22:10:45 tom Exp $")
 
 #ifndef ACTUAL_TIC
 #define ACTUAL_TIC "tic"
@@ -694,7 +694,7 @@
 #define DATAX()        DATA("", "")
 
 typedef struct {
-    const char from[4];
+    const char from[8];
     const char to[12];
 } assoc;
 
@@ -812,10 +812,10 @@
 static char *
 lookup_params(const assoc * table, char *dst, char *src)
 {
-    char *result = 0;
+    char *result = NULL;
     const char *ep = strtok(src, ";");
 
-    if (ep != 0) {
+    if (ep != NULL) {
 	const assoc *ap;
 
 	do {
@@ -861,7 +861,7 @@
 	int csi;
 	size_t len = 0;
 	size_t next;
-	const char *expansion = 0;
+	const char *expansion = NULL;
 	char buf3[MAX_TERMINFO_LENGTH];
 
 	/* first, check other capabilities in this entry */
@@ -1052,14 +1052,14 @@
 	      FALSE, 0, 65535, itrace, FALSE, FALSE, FALSE);
 
     for (n = 0; n < argc && n < MAXCOMPARE; n++) {
-	if (freopen(argv[n], "r", stdin) == 0)
+	if (freopen(argv[n], "r", stdin) == NULL)
 	    _nc_err_abort("Can't open %s: %s", argv[n], strerror(errno));
 
 #if NO_LEAKS
 	entered[n].head = _nc_head;
 	entered[n].tail = _nc_tail;
 #endif
-	_nc_head = _nc_tail = 0;
+	_nc_head = _nc_tail = NULL;
 
 	/* parse entries out of the source file */
 	_nc_set_source(argv[n]);
@@ -1187,7 +1187,7 @@
 
 		names[0] = name1;
 		names[1] = name2;
-		names[2] = 0;
+		names[2] = NULL;
 
 		entries[0] = *qp;
 		entries[1] = *rp;
@@ -1298,12 +1298,12 @@
     static size_t need;
     char *s;
 
-    if (initializer == 0) {
+    if (initializer == NULL) {
 	need = (strlen(entries->tterm.term_names)
 		+ strlen(type)
 		+ strlen(fmt));
 	initializer = (char *) malloc(need + 1);
-	if (initializer == 0)
+	if (initializer == NULL)
 	    failed("any_initializer");
     }
 
@@ -1334,7 +1334,7 @@
 dump_initializers(const TERMTYPE2 *term)
 {
     unsigned n;
-    const char *str = 0;
+    const char *str = NULL;
 
     printf("\nstatic char %s[] = \"%s\";\n\n",
 	   name_initializer("alias"), entries->tterm.term_names);
@@ -1496,10 +1496,10 @@
 static int
 optarg_to_number(void)
 {
-    char *temp = 0;
+    char *temp = NULL;
     long value = strtol(optarg, &temp, 0);
 
-    if (temp == 0 || temp == optarg || *temp != 0) {
+    if (temp == NULL || temp == optarg || *temp != 0) {
 	fprintf(stderr, "Expected a number, not \"%s\"\n", optarg);
 	ExitProgram(EXIT_FAILURE);
     }
@@ -1511,7 +1511,7 @@
 {
     char *terminal;
 
-    if ((terminal = getenv("TERM")) == 0) {
+    if ((terminal = getenv("TERM")) == NULL) {
 	(void) fprintf(stderr,
 		       "%s: environment variable TERM not set\n",
 		       _nc_progname);
@@ -1531,7 +1531,7 @@
     const char *path2;
 
     _nc_first_db(&state, &offset);
-    while ((path2 = _nc_next_db(&state, &offset)) != 0) {
+    while ((path2 = _nc_next_db(&state, &offset)) != NULL) {
 	printf("%s\n", path2);
     }
     _nc_last_db();
@@ -1559,8 +1559,8 @@
 {
     /* Avoid "local data >32k" error with mwcc */
     /* Also avoid overflowing smaller stacks on systems like AmigaOS */
-    path *tfile = 0;
-    char **tname = 0;
+    path *tfile = NULL;
+    char **tname = NULL;
     size_t maxterms;
 
     char **myargv;
@@ -1576,7 +1576,7 @@
     bool wrap_strings = FALSE;
 
     /* where is the terminfo database location going to default to? */
-    restdir = firstdir = 0;
+    restdir = firstdir = NULL;
 
 #if NCURSES_XNAMES
     use_extended_names(FALSE);
@@ -1587,7 +1587,7 @@
 
     /* make sure we have enough space to add two terminal entries */
     myargv = typeCalloc(char *, (size_t) (argc + 3));
-    if (myargv == 0)
+    if (myargv == NULL)
 	failed("myargv");
 
     memcpy(myargv, argv, (sizeof(char *) * (size_t) argc));
@@ -1671,7 +1671,7 @@
 	    outform = F_TERMINFO;
 	    if (sortmode == S_DEFAULT)
 		sortmode = S_VARIABLE;
-	    tversion = 0;
+	    tversion = NULL;
 	    break;
 
 	case 'i':
@@ -1712,7 +1712,7 @@
 	    break;
 
 	case 'r':
-	    tversion = 0;
+	    tversion = NULL;
 	    break;
 
 	case 's':
@@ -1780,20 +1780,20 @@
     }
 
     maxterms = (size_t) (argc + 2 - optind);
-    if ((tfile = typeMalloc(path, maxterms)) == 0)
+    if ((tfile = typeMalloc(path, maxterms)) == NULL)
 	failed("tfile");
-    if ((tname = typeCalloc(char *, maxterms)) == 0)
+    if ((tname = typeCalloc(char *, maxterms)) == NULL)
 	  failed("tname");
-    if ((entries = typeCalloc(ENTRY, maxterms)) == 0)
+    if ((entries = typeCalloc(ENTRY, maxterms)) == NULL)
 	failed("entries");
 #if NO_LEAKS
-    if ((entered = typeCalloc(ENTERED, maxterms)) == 0)
+    if ((entered = typeCalloc(ENTERED, maxterms)) == NULL)
 	failed("entered");
 #endif
 
-    if (tfile == 0
-	|| tname == 0
-	|| entries == 0) {
+    if (tfile == NULL
+	|| tname == NULL
+	|| entries == NULL) {
 	fprintf(stderr, "%s: not enough memory\n", _nc_progname);
 	ExitProgram(EXIT_FAILURE);
     }
Index: progs/reset_cmd.c
Prereq:  1.37 
--- ncurses-6.5-20241130+/progs/reset_cmd.c	2024-04-08 17:29:34.000000000 +0000
+++ ncurses-6.5-20241207/progs/reset_cmd.c	2024-12-07 22:12:53.000000000 +0000
@@ -53,7 +53,7 @@
 #include <sys/ptem.h>
 #endif
 
-MODULE_ID("$Id: reset_cmd.c,v 1.37 2024/04/08 17:29:34 tom Exp $")
+MODULE_ID("$Id: reset_cmd.c,v 1.38 2024/12/07 22:12:53 tom Exp $")
 
 /*
  * SCO defines TIOCGSIZE and the corresponding struct.  Other systems (SunOS,
@@ -104,8 +104,8 @@
     char buf[BUFSIZ];
     bool sent = FALSE;
 
-    if (file != 0) {
-	if ((fp = safe_fopen(file, "r")) == 0)
+    if (file != NULL) {
+	if ((fp = safe_fopen(file, "r")) == NULL)
 	    failed(file);
 
 	while ((nr = fread(buf, sizeof(char), sizeof(buf), fp)) != 0) {
@@ -528,7 +528,7 @@
 
     (void) old_settings;
 #if TAB3
-    if (old_settings != 0 &&
+    if (old_settings != NULL &&
 	old_settings->c_oflag & (TAB3 | ONLCR | OCRNL | ONLRET)) {
 	old_settings->c_oflag &= (TAB3 | ONLCR | OCRNL | ONLRET);
 	SET_TTY(fd, old_settings);
@@ -539,11 +539,11 @@
 	    IGNORE_RC(system(init_prog));
 	}
 
-	need_flush |= sent_string((use_reset && (reset_1string != 0))
+	need_flush |= sent_string((use_reset && (reset_1string != NULL))
 				  ? reset_1string
 				  : init_1string);
 
-	need_flush |= sent_string((use_reset && (reset_2string != 0))
+	need_flush |= sent_string((use_reset && (reset_2string != NULL))
 				  ? reset_2string
 				  : init_2string);
 
@@ -584,7 +584,7 @@
 
 	need_flush |= cat_file((use_reset && reset_file) ? reset_file : init_file);
 
-	need_flush |= sent_string((use_reset && (reset_3string != 0))
+	need_flush |= sent_string((use_reset && (reset_3string != NULL))
 				  ? reset_3string
 				  : init_3string);
     }
@@ -629,7 +629,7 @@
 	 */
     } else if (newer == 0177) {
 	(void) fprintf(stderr, "delete.\n");
-    } else if ((p = key_backspace) != 0
+    } else if ((p = key_backspace) != NULL
 	       && newer == (unsigned char) p[0]
 	       && p[1] == '\0') {
 	(void) fprintf(stderr, "backspace.\n");
@@ -655,7 +655,7 @@
 void
 reset_flush(void)
 {
-    if (my_file != 0)
+    if (my_file != NULL)
 	fflush(my_file);
 }
 
Index: progs/tabs.c
Prereq:  1.55 
--- ncurses-6.5-20241130+/progs/tabs.c	2024-10-19 21:45:18.000000000 +0000
+++ ncurses-6.5-20241207/progs/tabs.c	2024-12-07 22:10:45.000000000 +0000
@@ -39,7 +39,7 @@
 #include <progs.priv.h>
 #include <tty_settings.h>
 
-MODULE_ID("$Id: tabs.c,v 1.55 2024/10/19 21:45:18 tom Exp $")
+MODULE_ID("$Id: tabs.c,v 1.56 2024/12/07 22:10:45 tom Exp $")
 
 static GCC_NORETURN void usage(void);
 
@@ -147,7 +147,7 @@
 			"%s: tab-stops are not in increasing order: %d %d\n",
 			_nc_progname, value, result[n - 1]);
 		free(result);
-		result = 0;
+		result = NULL;
 		break;
 	    }
 	    ++n;
@@ -159,7 +159,7 @@
 	}
     }
 
-    if (result != 0) {
+    if (result != NULL) {
 	/*
 	 * If there is only one value, then it is an option such as "-8".
 	 */
@@ -250,7 +250,7 @@
 trimmed_tab_list(const char *source)
 {
     char *result = strdup(source);
-    if (result != 0) {
+    if (result != NULL) {
 	int j, k, last;
 
 	for (j = k = last = 0; result[j] != 0; ++j) {
@@ -280,7 +280,7 @@
 {
     bool result = FALSE;
 
-    if (source != 0) {
+    if (source != NULL) {
 	size_t len = strlen(source);
 	if (len != 0)
 	    result = (source[len - 1] != ',');
@@ -303,7 +303,7 @@
     char *result = *append;
     char *copied = trimmed_tab_list(value);
 
-    if (copied != 0 && *copied != '\0') {
+    if (copied != NULL && *copied != '\0') {
 	const char *comma = ",";
 	size_t need = 1 + strlen(copied);
 
@@ -313,15 +313,15 @@
 	    comma = "";
 
 	need += strlen(comma);
-	if (*append != 0)
+	if (*append != NULL)
 	    need += strlen(*append);
 
 	result = malloc(need);
-	if (result == 0)
+	if (result == NULL)
 	    failed("add_to_tab_list");
 
 	*result = '\0';
-	if (*append != 0) {
+	if (*append != NULL) {
 	    _nc_STRCPY(result, *append, need);
 	    free(*append);
 	}
@@ -402,7 +402,7 @@
 {
     bool result = TRUE;
 
-    if (tab_list != 0 && *tab_list != '\0') {
+    if (tab_list != NULL && *tab_list != '\0') {
 	if (comma_is_needed(tab_list)) {
 	    int n;
 
@@ -433,7 +433,7 @@
     while (*value != '\0' &&
 	   (isdigit(UChar(*value)) ||
 	    isspace(UChar(*value)) ||
-	    strchr("+,", UChar(*value)) != 0)) {
+	    strchr("+,", UChar(*value)) != NULL)) {
 	++value;
     }
     return value;
@@ -483,9 +483,9 @@
     bool no_op = FALSE;
     bool change_tty = FALSE;
     int n, ch;
-    NCURSES_CONST char *term_name = 0;
-    char *append = 0;
-    const char *tab_list = 0;
+    NCURSES_CONST char *term_name = NULL;
+    char *append = NULL;
+    const char *tab_list = NULL;
     const char *new_line = "\n";
     int margin = -1;
     TTY tty_settings;
@@ -493,7 +493,7 @@
 
     _nc_progname = _nc_rootname(argv[0]);
 
-    if ((term_name = getenv("TERM")) == 0)
+    if ((term_name = getenv("TERM")) == NULL)
 	term_name = "ansi+tabs";
 
     /* cannot use getopt, since some options are two-character */
@@ -617,11 +617,11 @@
 	    }
 	    break;
 	default:
-	    if (append != 0) {
+	    if (append != NULL) {
 		if (tab_list != (const char *) append) {
 		    /* one of the predefined options was used */
 		    free(append);
-		    append = 0;
+		    append = NULL;
 		}
 	    }
 	    tab_list = add_to_tab_list(&append, option);
@@ -683,7 +683,7 @@
 
 	list = decode_tabs(tab_list, margin);
 
-	if (list != 0) {
+	if (list != NULL) {
 	    if (!no_op)
 		do_tabs(list);
 	    if (debug) {
@@ -704,7 +704,7 @@
 	}
 	rc = EXIT_SUCCESS;
     }
-    if (append != 0)
+    if (append != NULL)
 	free(append);
     ExitProgram(rc);
 }
Index: progs/tic.c
Prereq:  1.329 
--- ncurses-6.5-20241130+/progs/tic.c	2024-11-30 21:29:07.000000000 +0000
+++ ncurses-6.5-20241207/progs/tic.c	2024-12-07 23:19:49.000000000 +0000
@@ -49,7 +49,7 @@
 #include <parametrized.h>
 #include <transform.h>
 
-MODULE_ID("$Id: tic.c,v 1.329 2024/11/30 21:29:07 tom Exp $")
+MODULE_ID("$Id: tic.c,v 1.331 2024/12/07 23:19:49 tom Exp $")
 
 #define STDIN_NAME "<stdin>"
 
@@ -61,7 +61,7 @@
 static bool infodump = FALSE;	/* running as captoinfo? */
 static bool showsummary = FALSE;
 static unsigned debug_level;
-static char **namelst = 0;
+static char **namelst = NULL;
 static const char *to_remove;
 
 #if NCURSES_XNAMES
@@ -104,9 +104,9 @@
 static void
 free_namelist(char **src)
 {
-    if (src != 0) {
+    if (src != NULL) {
 	int n;
-	for (n = 0; src[n] != 0; ++n)
+	for (n = 0; src[n] != NULL; ++n)
 	    free(src[n]);
 	free(src);
     }
@@ -120,9 +120,9 @@
     free_namelist(namelst);
     _nc_leaks_dump_entry();
 #endif
-    if (tmp_fp != 0)
+    if (tmp_fp != NULL)
 	fclose(tmp_fp);
-    if (to_remove != 0) {
+    if (to_remove != NULL) {
 	int rc;
 
 #if HAVE_REMOVE
@@ -214,7 +214,7 @@
     for (n = 0; n < STRCOUNT; n++) {
 	s = ep->tterm.Strings[n];
 	if (VALID_STRING(s)
-	    && strchr(s, L_BRACE) != 0) {
+	    && strchr(s, L_BRACE) != NULL) {
 	    d = result;
 	    t = s;
 	    while ((ch = *t++) != 0) {
@@ -224,9 +224,9 @@
 			break;
 		} else if ((ch == '%')
 			   && (*t == L_BRACE)) {
-		    char *v = 0;
+		    char *v = NULL;
 		    long value = strtol(t + 1, &v, 0);
-		    if (v != 0
+		    if (v != NULL
 			&& *v == R_BRACE
 			&& value > 0
 			&& value != '\\'	/* FIXME */
@@ -334,14 +334,14 @@
 	    in_name = FALSE;
 
 	    suffix[0] = '\0';
-	    if ((up = strchr(namebuf, '#')) != 0
-		|| (up = strchr(namebuf, '=')) != 0
-		|| ((up = strchr(namebuf, '@')) != 0 && up[1] == '>')) {
+	    if ((up = strchr(namebuf, '#')) != NULL
+		|| (up = strchr(namebuf, '=')) != NULL
+		|| ((up = strchr(namebuf, '@')) != NULL && up[1] == '>')) {
 		_nc_STRCPY(suffix, up, have);
 		*up = '\0';
 	    }
 
-	    if ((tp = nametrans(namebuf)) != 0) {
+	    if ((tp = nametrans(namebuf)) != NULL) {
 		(void) putchar(':');
 		(void) fputs(tp, stdout);
 		(void) fputs(suffix, stdout);
@@ -368,7 +368,7 @@
 static char *
 stripped(char *src)
 {
-    char *dst = 0;
+    char *dst = NULL;
 
     while (isspace(UChar(*src)))
 	src++;
@@ -388,7 +388,7 @@
 static FILE *
 open_tempfile(char *filename)
 {
-    FILE *result = 0;
+    FILE *result = NULL;
 
     _nc_STRCPY(filename, "/tmp/XXXXXX", PATH_MAX);
 #if HAVE_MKSTEMP
@@ -410,7 +410,7 @@
 copy_input(FILE *source, const char *filename, char *alt_file)
 {
     char my_altfile[PATH_MAX];
-    FILE *result = 0;
+    FILE *result = NULL;
     FILE *target;
 
     if (alt_file == NULL)
@@ -476,7 +476,7 @@
 	    ExitProgram(EXIT_FAILURE);
 	}
 	if (mode != S_IFREG) {
-	    if (alt_file != 0) {
+	    if (alt_file != NULL) {
 		FILE *fp2 = copy_input(fp, filename, alt_file);
 		fp = fp2;
 	    } else {
@@ -493,7 +493,7 @@
 static char **
 make_namelist(char *src)
 {
-    char **dst = 0;
+    char **dst = NULL;
 
     char *s, *base;
     unsigned pass, n, nn;
@@ -501,14 +501,14 @@
 
     if (src == NULL) {
 	/* EMPTY */ ;
-    } else if (strchr(src, '/') != 0) {		/* a filename */
+    } else if (strchr(src, '/') != NULL) {	/* a filename */
 	FILE *fp = open_input(src, (char *) 0);
 
 	for (pass = 1; pass <= 2; pass++) {
 	    nn = 0;
-	    while (fgets(buffer, sizeof(buffer), fp) != 0) {
-		if ((s = stripped(buffer)) != 0) {
-		    if (dst != 0)
+	    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
+		if ((s = stripped(buffer)) != NULL) {
+		    if (dst != NULL)
 			dst[nn] = s;
 		    else
 			free(s);
@@ -520,7 +520,7 @@
 		      failed("make_namelist (alloc)");
 		rewind(fp);
 		if (errno != 0)
-		      failed("make_namelist (rewind)");
+		    failed("make_namelist (rewind)");
 	    }
 	}
 	fclose(fp);
@@ -533,7 +533,7 @@
 			nn++;
 		    } else {
 			src[n] = '\0';
-			if ((s = stripped(base)) != 0)
+			if ((s = stripped(base)) != NULL)
 			    dst[nn++] = s;
 			base = &src[n + 1];
 		    }
@@ -547,9 +547,9 @@
 	    }
 	}
     }
-    if (showsummary && (dst != 0)) {
+    if (showsummary && (dst != NULL)) {
 	fprintf(log_fp, "Entries that will be compiled:\n");
-	for (n = 0; dst[n] != 0; n++)
+	for (n = 0; dst[n] != NULL; n++)
 	    fprintf(log_fp, "%u:%s\n", n + 1, dst[n]);
     }
     return dst;
@@ -561,10 +561,10 @@
 {
     bool code = FALSE;
 
-    if (needle != 0) {
+    if (needle != NULL) {
 	size_t n;
 
-	for (n = 0; needle[n] != 0; n++) {
+	for (n = 0; needle[n] != NULL; n++) {
 	    if (_nc_name_match(haystack, needle[n], "|")) {
 		code = TRUE;
 		break;
@@ -608,7 +608,7 @@
 	    || access(result, R_OK | W_OK | X_OK) != 0) {
 	    DEBUG(1, ("...not a writable directory"));
 	    free(result);
-	    result = 0;
+	    result = NULL;
 	}
 #endif
     } else {
@@ -626,12 +626,12 @@
 	    } else {
 		DEBUG(1, ("...parent directory %s is not writable", result));
 		free(result);
-		result = 0;
+		result = NULL;
 	    }
 	} else {
 	    DEBUG(1, ("... no parent directory"));
 	    free(result);
-	    result = 0;
+	    result = NULL;
 	}
     }
     return result;
@@ -645,14 +645,14 @@
 static void
 show_databases(const char *outdir)
 {
-    bool specific = (outdir != 0) || getenv("TERMINFO") != 0;
+    bool specific = (outdir != NULL) || getenv("TERMINFO") != NULL;
     char *result;
-    const char *tried = 0;
+    const char *tried = NULL;
 
     if (outdir == NULL) {
 	outdir = _nc_tic_dir(NULL);
     }
-    if ((result = valid_db_path(outdir)) != 0) {
+    if ((result = valid_db_path(outdir)) != NULL) {
 	printf("%s\n", result);
 	free(result);
     } else {
@@ -924,13 +924,13 @@
 	if (infodump == TRUE) {
 	    /* captoinfo's no-argument case */
 	    source_file = "/etc/termcap";
-	    if ((termcap = getenv("TERMCAP")) != 0
-		&& (namelst = make_namelist(getenv("TERM"))) != 0) {
+	    if ((termcap = getenv("TERMCAP")) != NULL
+		&& (namelst = make_namelist(getenv("TERM"))) != NULL) {
 		if (access(termcap, F_OK) == 0) {
 		    /* file exists */
 		    source_file = termcap;
 		} else {
-		    if ((tmp_fp = open_tempfile(my_tmpname)) != 0) {
+		    if ((tmp_fp = open_tempfile(my_tmpname)) != NULL) {
 			source_file = my_tmpname;
 			fprintf(tmp_fp, "%s\n", termcap);
 			fclose(tmp_fp);
@@ -1335,7 +1335,7 @@
     if ((ch = keypad_final(string)) != '\0') {
 	const char *list = "PQRSwxymtuvlqrsPpn";	/* app-keypad except "Enter" */
 	const char *test = (strchr) (list, ch);
-	if (test != 0)
+	if (test != NULL)
 	    result = (long) (test - list);
     }
     return result;
@@ -1712,8 +1712,8 @@
 static bool
 uses_SGR_39_49(const char *value)
 {
-    return (strstr(value, "39;49") != 0
-	    || strstr(value, "49;39") != 0);
+    return (strstr(value, "39;49") != NULL
+	    || strstr(value, "49;39") != NULL);
 }
 
 /*
@@ -1897,7 +1897,7 @@
 static struct user_table_entry const *
 lookup_user_capability(const char *name)
 {
-    struct user_table_entry const *result = 0;
+    struct user_table_entry const *result = NULL;
     if (*name != 'k') {
 	result = _nc_find_user_entry(name);
     }
@@ -1929,7 +1929,7 @@
 #if NCURSES_XNAMES
     else if (using_extensions) {
 	struct user_table_entry const *p = lookup_user_capability(name);
-	if (p != 0) {
+	if (p != NULL) {
 	    result = (int) p->ute_argc;
 	}
     }
@@ -2134,7 +2134,7 @@
 skip_DECSCNM(const char *value, int *flag)
 {
     *flag = -1;
-    if (value != 0) {
+    if (value != NULL) {
 	int skip = csi_length(value);
 	if (skip > 0 &&
 	    value[skip++] == '?' &&
@@ -2154,13 +2154,13 @@
 check_delays(const TERMTYPE2 *tp, const char *name, const char *value)
 {
     const char *p, *q;
-    const char *first = 0;
-    const char *last = 0;
+    const char *first = NULL;
+    const char *last = NULL;
 
     for (p = value; *p != '\0'; ++p) {
 	if (p[0] == '$' && p[1] == '<') {
 	    const char *base = p + 2;
-	    const char *mark = 0;
+	    const char *mark = NULL;
 	    bool mixed = FALSE;
 	    int proportional = 0;
 	    int mandatory = 0;
@@ -2179,7 +2179,7 @@
 			++mandatory;
 		    if (mark == NULL)
 			mark = q;
-		} else if (!(isalnum(UChar(*q)) || strchr("+-.", *q) != 0)) {
+		} else if (!(isalnum(UChar(*q)) || strchr("+-.", *q) != NULL)) {
 		    break;
 		} else if (proportional || mandatory) {
 		    mixed = TRUE;
@@ -2215,7 +2215,7 @@
     if (!strcmp(name, "flash") ||
 	!strcmp(name, "beep")) {
 
-	if (first != 0) {
+	if (first != NULL) {
 	    if (first == value || *last == 0) {
 		/*
 		 * Delay is on one end or the other.
@@ -2229,9 +2229,9 @@
 	     * Check for missing delay when using VT100 reverse-video.
 	     * A real VT100 might not need this, but terminal emulators do.
 	     */
-	    if ((p = skip_DECSCNM(value, &flag)) != 0 &&
+	    if ((p = skip_DECSCNM(value, &flag)) != NULL &&
 		flag > 0 &&
-		skip_DECSCNM(p, &flag) != 0 &&
+		skip_DECSCNM(p, &flag) != NULL &&
 		flag == 0) {
 		_nc_warning("expected a delay in %s", name);
 	    }
@@ -2304,7 +2304,7 @@
 	break;
     case Other:
     default:
-#define myParam(n) (p_is_s[n - 1] != 0 ? ((TPARM_ARG) strings[n]) : numbers[n])
+#define myParam(n) (p_is_s[n - 1] != NULL ? ((TPARM_ARG) strings[n]) : numbers[n])
 	result = TPARM_9(value,
 			 myParam(1),
 			 myParam(2),
@@ -2648,7 +2648,7 @@
 		    num == 7,
 		    num == 8,
 		    num == 9);
-    if (test != 0) {
+    if (test != NULL) {
 	if (PRESENT(cap)) {
 	    if (!similar_sgr(num, test, cap)) {
 		_nc_warning("%s differs from sgr(%d)\n\t%s=%s\n\tsgr(%d)=%s",
@@ -2868,7 +2868,7 @@
 static void
 check_exit_attribute(const char *name, char *test, char *trimmed, char *untrimmed)
 {
-    if (VALID_STRING(test) && (trimmed != 0)) {
+    if (VALID_STRING(test) && (trimmed != NULL)) {
 	if (similar_sgr(-1, trimmed, test) ||
 	    similar_sgr(-1, untrimmed, test)) {
 	    _nc_warning("%s matches exit_attribute_mode", name);
@@ -2963,7 +2963,7 @@
     int result = -1;
     const struct name_table_entry *np;
 
-    if ((np = _nc_find_entry(name, _nc_get_hash_table(0))) != 0) {
+    if ((np = _nc_find_entry(name, _nc_get_hash_table(0))) != NULL) {
 	result = np->nte_type;
     }
     return result;
@@ -2990,7 +2990,7 @@
 static void
 check_user_capability_type(const char *name, int actual)
 {
-    if (lookup_user_capability(name) == 0) {
+    if (lookup_user_capability(name) == NULL) {
 	int expected = standard_type(name);
 	if (expected >= 0) {
 	    _nc_warning("expected %s to be %s, but actually %s",
@@ -3156,7 +3156,7 @@
 check_user_6789(const TERMTYPE2 *tp)
 {
     /*
-     * Check if the terminal is known to not 
+     * Check if the terminal is known to not
      */
 #define NO_QUERY(longname,shortname) \
 	if (PRESENT(longname)) _nc_warning(#shortname " is not supported")
@@ -3272,7 +3272,7 @@
     ANDMISSING(clear_all_tabs, set_tab);
 
     if (PRESENT(set_attributes)) {
-	char *zero = 0;
+	char *zero = NULL;
 
 	_nc_tparm_err = 0;
 	if (PRESENT(exit_attribute_mode)) {
@@ -3282,7 +3282,7 @@
 	}
 	check_tparm_err(0);
 
-	if (zero != 0) {
+	if (zero != NULL) {
 	    CHECK_SGR(1, enter_standout_mode);
 	    CHECK_SGR(2, enter_underline_mode);
 	    CHECK_SGR(3, enter_reverse_mode);
@@ -3368,6 +3368,6 @@
     /*
      * Finally, do the non-verbose checks
      */
-    if (save_check_termtype != 0)
+    if (save_check_termtype != NULL)
 	save_check_termtype(tp, literal);
 }
Index: progs/toe.c
Prereq:  1.91 
--- ncurses-6.5-20241130+/progs/toe.c	2024-11-23 20:09:23.000000000 +0000
+++ ncurses-6.5-20241207/progs/toe.c	2024-12-07 22:12:53.000000000 +0000
@@ -45,7 +45,7 @@
 #include <hashed_db.h>
 #endif
 
-MODULE_ID("$Id: toe.c,v 1.91 2024/11/23 20:09:23 tom Exp $")
+MODULE_ID("$Id: toe.c,v 1.92 2024/12/07 22:12:53 tom Exp $")
 
 #define isDotname(name) (!strcmp(name, ".") || !strcmp(name, ".."))
 
@@ -86,7 +86,7 @@
 strmalloc(const char *value)
 {
     char *result = strdup(value);
-    if (result == 0) {
+    if (result == NULL) {
 	failed("strmalloc");
     }
     return result;
@@ -100,7 +100,7 @@
     if (want >= len_termdata) {
 	len_termdata = (2 * want) + 10;
 	ptr_termdata = typeRealloc(TERMDATA, len_termdata, ptr_termdata);
-	if (ptr_termdata == 0)
+	if (ptr_termdata == NULL)
 	    failed("ptr_termdata");
     }
 
@@ -200,14 +200,14 @@
 static void
 free_termdata(void)
 {
-    if (ptr_termdata != 0) {
+    if (ptr_termdata != NULL) {
 	while (use_termdata != 0) {
 	    --use_termdata;
 	    free(ptr_termdata[use_termdata].term_name);
 	    free(ptr_termdata[use_termdata].description);
 	}
 	free(ptr_termdata);
-	ptr_termdata = 0;
+	ptr_termdata = NULL;
     }
     use_termdata = 0;
     len_termdata = 0;
@@ -217,7 +217,7 @@
 allocArgv(size_t count)
 {
     char **result = typeCalloc(char *, count + 1);
-    if (result == 0)
+    if (result == NULL)
 	failed("realloc eargv");
 
     assert(result != 0);
@@ -272,8 +272,8 @@
 {
     const char *desc;
 
-    if (tp->term_names == 0
-	|| (desc = strrchr(tp->term_names, '|')) == 0
+    if (tp->term_names == NULL
+	|| (desc = strrchr(tp->term_names, '|')) == NULL
 	|| (*++desc == '\0')) {
 	desc = "(No description)";
     }
@@ -389,7 +389,7 @@
 {
     size_t len = NAMLEN(src);
     char *result = malloc(len + 1);
-    if (result == 0)
+    if (result == NULL)
 	failed("copy entryname");
     memcpy(result, src->d_name, len);
     result[len] = '\0';
@@ -409,11 +409,11 @@
     for (i = 0; i < eargc; i++) {
 #if NCURSES_USE_DATABASE
 	if (_nc_is_dir_path(eargv[i])) {
-	    char *cwd_buf = 0;
+	    char *cwd_buf = NULL;
 	    DIR *termdir;
 	    const DIRENT *subdir;
 
-	    if ((termdir = opendir(eargv[i])) == 0) {
+	    if ((termdir = opendir(eargv[i])) == NULL) {
 		(void) fflush(stdout);
 		(void) fprintf(stderr,
 			       "%s: can't open terminfo directory %s\n",
@@ -424,7 +424,7 @@
 	    if (verbosity)
 		(void) printf("#\n#%s:\n#\n", eargv[i]);
 
-	    while ((subdir = readdir(termdir)) != 0) {
+	    while ((subdir = readdir(termdir)) != NULL) {
 		size_t cwd_len;
 		char *name_1;
 		DIR *entrydir;
@@ -438,7 +438,7 @@
 
 		cwd_len = strlen(name_1) + strlen(eargv[i]) + 3;
 		cwd_buf = typeRealloc(char, cwd_len, cwd_buf);
-		if (cwd_buf == 0)
+		if (cwd_buf == NULL)
 		    failed("realloc cwd_buf");
 
 		assert(cwd_buf != 0);
@@ -451,11 +451,11 @@
 		    continue;
 
 		entrydir = opendir(".");
-		if (entrydir == 0) {
+		if (entrydir == NULL) {
 		    perror(cwd_buf);
 		    continue;
 		}
-		while ((entry = readdir(entrydir)) != 0) {
+		while ((entry = readdir(entrydir)) != NULL) {
 		    char *name_2;
 		    TERMTYPE2 lterm;
 		    char *cn;
@@ -489,7 +489,7 @@
 		closedir(entrydir);
 	    }
 	    closedir(termdir);
-	    if (cwd_buf != 0)
+	    if (cwd_buf != NULL)
 		free(cwd_buf);
 	    continue;
 	}
@@ -605,7 +605,7 @@
     bool direct_dependencies = FALSE;
     bool invert_dependencies = FALSE;
     bool header = FALSE;
-    const char *report_file = 0;
+    const char *report_file = NULL;
     int code;
     int this_opt, last_opt = '?';
     unsigned v_opt = 0;
@@ -660,8 +660,8 @@
     }
     use_verbosity(v_opt);
 
-    if (report_file != 0) {
-	if (freopen(report_file, "r", stdin) == 0) {
+    if (report_file != NULL) {
+	if (freopen(report_file, "r", stdin) == NULL) {
 	    (void) fflush(stdout);
 	    fprintf(stderr, "%s: can't open %s\n", _nc_progname, report_file);
 	    ExitProgram(EXIT_FAILURE);
@@ -669,7 +669,7 @@
 
 	/* parse entries out of the source file */
 	_nc_set_source(report_file);
-	_nc_read_entry_source(stdin, 0, FALSE, FALSE, NULLHOOK);
+	_nc_read_entry_source(stdin, NULL, FALSE, FALSE, NULLHOOK);
     }
 
     /* maybe we want a direct-dependency listing? */
@@ -729,7 +729,7 @@
 	DBDIRS state;
 	int offset;
 	int pass;
-	char **eargv = 0;
+	char **eargv = NULL;
 
 	code = EXIT_FAILURE;
 	for (pass = 0; pass < 2; ++pass) {
@@ -737,7 +737,7 @@
 	    const char *path;
 
 	    _nc_first_db(&state, &offset);
-	    while ((path = _nc_next_db(&state, &offset)) != 0) {
+	    while ((path = _nc_next_db(&state, &offset)) != NULL) {
 		if (quick_prefix(path))
 		    continue;
 		if (pass) {
@@ -747,7 +747,7 @@
 	    }
 	    if (!pass) {
 		eargv = allocArgv(count);
-		if (eargv == 0)
+		if (eargv == NULL)
 		    failed("eargv");
 	    } else {
 		code = typelist((int) count, eargv, header, hook);
@@ -761,10 +761,10 @@
 	char **eargv = allocArgv((size_t) 2);
 	size_t count = 0;
 
-	if (eargv == 0)
+	if (eargv == NULL)
 	    failed("eargv");
 	_nc_first_db(&state, &offset);
-	if ((path = _nc_next_db(&state, &offset)) != 0) {
+	if ((path = _nc_next_db(&state, &offset)) != NULL) {
 	    if (!quick_prefix(path))
 		eargv[count++] = strmalloc(path);
 	}
Index: progs/tput.c
Prereq:  1.106 
--- ncurses-6.5-20241130+/progs/tput.c	2024-11-30 21:47:34.000000000 +0000
+++ ncurses-6.5-20241207/progs/tput.c	2024-12-07 22:12:53.000000000 +0000
@@ -47,7 +47,7 @@
 #include <transform.h>
 #include <tty_settings.h>
 
-MODULE_ID("$Id: tput.c,v 1.106 2024/11/30 21:47:34 tom Exp $")
+MODULE_ID("$Id: tput.c,v 1.107 2024/12/07 22:12:53 tom Exp $")
 
 #define PUTS(s)		fputs(s, stdout)
 
@@ -256,15 +256,15 @@
 	     */
 
 	    for (k = 1; (k < argc) && (k <= NUM_PARM); k++) {
-		char *tmp = 0;
+		char *tmp = NULL;
 		strings[k] = argv[k];
 		numbers[k] = strtol(argv[k], &tmp, 0);
-		if (tmp == 0 || *tmp != 0)
+		if (tmp == NULL || *tmp != 0)
 		    numbers[k] = 0;
 	    }
 	    for (k = argc; k <= NUM_PARM; k++) {
 		numbers[k] = 0;
-		strings[k] = 0;
+		strings[k] = NULL;
 	    }
 
 	    paramType = tparm_type(name);
@@ -342,7 +342,7 @@
 		/* FALLTHRU */
 	    default:
 		analyzed = _nc_tparm_analyze(NULL, s, p_is_s, &popcount);
-#define myParam(n) (p_is_s[n - 1] != 0 ? ((TPARM_ARG) strings[n]) : numbers[n])
+#define myParam(n) (p_is_s[n - 1] != NULL ? ((TPARM_ARG) strings[n]) : numbers[n])
 		s = TPARM_9(s,
 			    myParam(1),
 			    myParam(2),
@@ -440,7 +440,7 @@
 	argv += optind;
     }
 
-    if (term == 0 || *term == '\0')
+    if (term == NULL || *term == '\0')
 	quit(ErrUsage, "No value for $TERM and no -T specified");
 
     fd = save_tty_settings(&tty_settings, need_tty);
@@ -464,7 +464,7 @@
 	ExitProgram(code);
     }
 
-    while (fgets(buf, sizeof(buf), stdin) != 0) {
+    while (fgets(buf, sizeof(buf), stdin) != NULL) {
 	size_t need = strlen(buf);
 	char **argvec = typeCalloc(char *, need + 1);
 	char **argnow;
Index: progs/tset.c
Prereq:  1.138 
--- ncurses-6.5-20241130+/progs/tset.c	2024-11-30 21:30:49.000000000 +0000
+++ ncurses-6.5-20241207/progs/tset.c	2024-12-07 22:14:46.000000000 +0000
@@ -98,7 +98,7 @@
 char *ttyname(int fd);
 #endif
 
-MODULE_ID("$Id: tset.c,v 1.138 2024/11/30 21:30:49 tom Exp $")
+MODULE_ID("$Id: tset.c,v 1.139 2024/12/07 22:14:46 tom Exp $")
 
 #ifndef environ
 extern char **environ;
@@ -185,19 +185,19 @@
 	    (void) fprintf(stderr, "Terminal type? ");
 	(void) fflush(stderr);
 
-	if (fgets(answer, sizeof(answer), stdin) == 0) {
-	    if (dflt == 0) {
+	if (fgets(answer, sizeof(answer), stdin) == NULL) {
+	    if (dflt == NULL) {
 		exit_error();
 		/* NOTREACHED */
 	    }
 	    return (dflt);
 	}
 
-	if ((p = strchr(answer, '\n')) != 0)
+	if ((p = strchr(answer, '\n')) != NULL)
 	    *p = '\0';
 	if (answer[0])
 	    return (answer);
-	if (dflt != 0)
+	if (dflt != NULL)
 	    return (dflt);
     }
 }
@@ -344,7 +344,7 @@
 static int
 tbaudrate(char *rate)
 {
-    const SPEEDS *sp = 0;
+    const SPEEDS *sp = NULL;
     size_t n;
 
     /* The baudrate number can be preceded by a 'B', which is ignored. */
@@ -361,7 +361,7 @@
 	    break;
 	}
     }
-    if (sp == 0)
+    if (sp == NULL)
 	err("unknown baud rate %s", rate);
     return (sp->speed);
 }
@@ -377,18 +377,18 @@
     MAP *mapp;
     char *copy, *p;
     const char *termp;
-    char *base = 0;
+    char *base = NULL;
 
     copy = strdup(arg);
     mapp = typeMalloc(MAP, 1);
-    if (copy == 0 || mapp == 0)
+    if (copy == NULL || mapp == NULL)
 	failed("malloc");
 
     assert(copy != 0);
     assert(mapp != 0);
 
-    mapp->next = 0;
-    if (maplist == 0)
+    mapp->next = NULL;
+    if (maplist == NULL)
 	cur = maplist = mapp;
     else {
 	cur->next = mapp;
@@ -400,14 +400,14 @@
 
     arg = strpbrk(arg, "><@=!:");
 
-    if (arg == 0) {		/* [?]term */
+    if (arg == NULL) {		/* [?]term */
 	mapp->type = mapp->porttype;
-	mapp->porttype = 0;
+	mapp->porttype = NULL;
 	goto done;
     }
 
     if (arg == mapp->porttype)	/* [><@=! baud]:term */
-	termp = mapp->porttype = 0;
+	termp = mapp->porttype = NULL;
     else
 	termp = base = arg;
 
@@ -442,7 +442,7 @@
 	++arg;
     } else {			/* Optional baudrate. */
 	arg = strchr(p = arg, ':');
-	if (arg == 0)
+	if (arg == NULL)
 	    goto badmopt;
 	*arg++ = '\0';
 	mapp->speed = tbaudrate(p);
@@ -451,7 +451,7 @@
     mapp->type = arg;
 
     /* Terminate porttype, if specified. */
-    if (termp != 0)
+    if (termp != NULL)
 	*base = '\0';
 
     /* If a NOT conditional, reverse the test. */
@@ -499,7 +499,7 @@
     int match;
 
     for (mapp = maplist; mapp; mapp = mapp->next)
-	if (mapp->porttype == 0 || !strcmp(mapp->porttype, type)) {
+	if (mapp->porttype == NULL || !strcmp(mapp->porttype, type)) {
 	    switch (mapp->conditional) {
 	    case 0:		/* No test specified. */
 		match = TRUE;
@@ -562,11 +562,11 @@
     }
 
     /* Try the environment. */
-    if ((ttype = getenv("TERM")) != 0)
+    if ((ttype = getenv("TERM")) != NULL)
 	goto map;
 
 #if HAVE_PATH_TTYS
-    if ((ttypath = ttyname(fd)) != 0) {
+    if ((ttypath = ttyname(fd)) != NULL) {
 	p = _nc_basename(ttypath);
 #if HAVE_GETTTYNAM
 	/*
@@ -616,14 +616,14 @@
      * by out of date stuff in the environment.
      */
   found:
-    if ((p = getenv("TERMCAP")) != 0 && !_nc_is_abs_path(p)) {
+    if ((p = getenv("TERMCAP")) != NULL && !_nc_is_abs_path(p)) {
 	/* 'unsetenv("TERMCAP")' is not portable.
 	 * The 'environ' array is better.
 	 */
 	int n;
-	for (n = 0; environ[n] != 0; n++) {
+	for (n = 0; environ[n] != NULL; n++) {
 	    if (!strncmp("TERMCAP=", environ[n], (size_t) 8)) {
-		while ((environ[n] = environ[n + 1]) != 0) {
+		while ((environ[n] = environ[n + 1]) != NULL) {
 		    n++;
 		}
 		break;
@@ -639,7 +639,7 @@
 	if (ttype[1] != '\0')
 	    ttype = askuser(ttype + 1);
 	else
-	    ttype = askuser(0);
+	    ttype = askuser(NULL);
     }
     /* Find the terminfo entry.  If it doesn't exist, ask the user. */
     while (setupterm((NCURSES_CONST char *) ttype, fd, &errret)
@@ -647,12 +647,12 @@
 	if (errret == 0) {
 	    (void) fprintf(stderr, "%s: unknown terminal type %s\n",
 			   _nc_progname, ttype);
-	    ttype = 0;
+	    ttype = NULL;
 	} else {
 	    (void) fprintf(stderr,
 			   "%s: can't initialize terminal type %s (error %d)\n",
 			   _nc_progname, ttype, errret);
-	    ttype = 0;
+	    ttype = NULL;
 	}
 	ttype = askuser(ttype);
     }
@@ -713,7 +713,7 @@
      * Figure out what shell we're using.  A hack, we look for an
      * environmental variable SHELL ending in "csh".
      */
-    if ((var = getenv("SHELL")) != 0
+    if ((var = getenv("SHELL")) != NULL
 	&& ((len = (int) strlen(leaf = _nc_basename(var))) >= 3)
 	&& !strcmp(leaf + len - 3, "csh"))
 	p = "set noglob;\nsetenv TERM %s;\nunset noglob;\n";
@@ -806,7 +806,7 @@
 	    tkillchar = arg_to_char();
 	    break;
 	case 'm':		/* map identifier to type */
-	    add_mapping(0, optarg);
+	    add_mapping(NULL, optarg);
 	    break;
 	case 'p':		/* OBSOLETE: map identifier to type */
 	    add_mapping("plugboard", optarg);
Index: test/blue.c
Prereq:  1.56 
--- ncurses-6.5-20241130+/test/blue.c	2024-10-05 19:26:24.000000000 +0000
+++ ncurses-6.5-20241207/test/blue.c	2024-12-07 22:27:13.000000000 +0000
@@ -37,7 +37,7 @@
  *****************************************************************************/
 
 /*
- * $Id: blue.c,v 1.56 2024/10/05 19:26:24 tom Exp $
+ * $Id: blue.c,v 1.57 2024/12/07 22:27:13 tom Exp $
  */
 
 #include <test.priv.h>
@@ -454,7 +454,7 @@
 	     * The ncurses library makes this check to decide whether to allow
 	     * the alternate character set for the (normally) nonprinting codes.
 	     */
-	    if (smacs != 0 && smpch != 0 && !strcmp(smacs, smpch)) {
+	    if (smacs != NULL && smpch != NULL && !strcmp(smacs, smpch)) {
 		suits = glyphs;
 	    }
 	}
Index: test/bs.c
Prereq:  1.81 
--- ncurses-6.5-20241130+/test/bs.c	2024-11-30 16:47:02.000000000 +0000
+++ ncurses-6.5-20241207/test/bs.c	2024-12-07 22:18:28.000000000 +0000
@@ -35,7 +35,7 @@
  * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
  * v2.1 with ncurses mouse support, September 1995
  *
- * $Id: bs.c,v 1.81 2024/11/30 16:47:02 tom Exp $
+ * $Id: bs.c,v 1.82 2024/12/07 22:18:28 tom Exp $
  */
 
 #include <test.priv.h>
@@ -224,12 +224,12 @@
 {
     const char *tmpname;
 
-    srand((unsigned) (time(0L) + getpid()));	/* Kick the random number generator */
+    srand((unsigned) (time(NULL) + getpid()));	/* Kick the random number generator */
 
     InitAndCatch(initscr(), uninitgame);
 
-    if ((tmpname = getlogin()) != 0 &&
-	(your_name = strdup(tmpname)) != 0) {
+    if ((tmpname = getlogin()) != NULL &&
+	(your_name = strdup(tmpname)) != NULL) {
 	your_name[0] = (char) toupper(UChar(your_name[0]));
     } else {
 	your_name = strdup(dftname);
@@ -475,7 +475,7 @@
 	} else if (c == FF) {
 	    (void) clearok(stdscr, TRUE);
 	    (void) refresh();
-	} else if (ss == 0) {
+	} else if (ss == NULL) {
 	    beep();		/* simple to verify, unlikely to happen */
 	} else if (c == 'r') {
 	    prompt(1, "Random-placing your %s", ss->name);
@@ -877,7 +877,7 @@
 	    m = " You'll pick up survivors from my %s, I hope...!";
 	    break;
 	}
-	if (m != 0) {
+	if (m != NULL) {
 	    (void) printw(m, ss->name);
 	}
 	(void) beep();
Index: test/cardfile.c
Prereq:  1.53 
--- ncurses-6.5-20241130+/test/cardfile.c	2024-11-30 16:47:59.000000000 +0000
+++ ncurses-6.5-20241207/test/cardfile.c	2024-12-07 22:27:13.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey
  *
- * $Id: cardfile.c,v 1.53 2024/11/30 16:47:59 tom Exp $
+ * $Id: cardfile.c,v 1.54 2024/12/07 22:27:13 tom Exp $
  *
  * File format: text beginning in column 1 is a title; other text is content.
  */
@@ -47,7 +47,7 @@
 #define pair_1 1
 #define pair_2 2
 
-#define isVisible(cardp) ((cardp)->panel != 0)
+#define isVisible(cardp) ((cardp)->panel != NULL)
 
 enum {
     MY_CTRL_x = MAX_FORM_COMMAND
@@ -100,7 +100,7 @@
 {
     CARD *card, *p, *q;
 
-    for (p = all_cards, q = 0; p != 0; q = p, p = p->link) {
+    for (p = all_cards, q = NULL; p != NULL; q = p, p = p->link) {
 	int cmp = strcmp(p->title, title);
 	if (cmp == 0)
 	    return p;
@@ -112,7 +112,7 @@
     card->title = strdup(title);
     card->content = strdup("");
 
-    if (q == 0) {
+    if (q == NULL) {
 	card->link = all_cards;
 	all_cards = card;
     } else {
@@ -132,7 +132,7 @@
     if ((total = strlen(content)) != 0) {
 	size_t offset;
 
-	if (card->content != 0 && (offset = strlen(card->content)) != 0) {
+	if (card->content != NULL && (offset = strlen(card->content)) != 0) {
 	    total += 1 + offset;
 	    card->content = typeRealloc(char, total + 1, card->content);
 	    if (card->content) {
@@ -141,7 +141,7 @@
 	    }
 	} else {
 	    offset = 0;
-	    if (card->content != 0)
+	    if (card->content != NULL)
 		free(card->content);
 	    card->content = typeMalloc(char, total + 1);
 	}
@@ -165,7 +165,7 @@
 {
     CARD *card;
 
-    for (card = all_cards; card != 0; card = card->link)
+    for (card = all_cards; card != NULL; card = card->link)
 	if (!strcmp(card->title, title))
 	    break;
 
@@ -177,17 +177,17 @@
 {
     FILE *fp;
 
-    if ((fp = fopen(fname, "r")) != 0) {
-	CARD *card = 0;
+    if ((fp = fopen(fname, "r")) != NULL) {
+	CARD *card = NULL;
 	char buffer[BUFSIZ];
 
 	while (fgets(buffer, sizeof(buffer), fp)) {
 	    trim(buffer);
 	    if (isspace(UChar(*buffer))) {
-		if (card == 0)
+		if (card == NULL)
 		    card = add_title("");
 		add_content(card, buffer);
-	    } else if ((card = find_card(buffer)) == 0) {
+	    } else if ((card = find_card(buffer)) == NULL) {
 		card = add_title(buffer);
 	    }
 	}
@@ -205,17 +205,17 @@
     if (!strcmp(fname, default_name))
 	fname = "cardfile.out";
 
-    if ((fp = fopen(fname, "w")) != 0) {
-	CARD *p = 0;
+    if ((fp = fopen(fname, "w")) != NULL) {
+	CARD *p = NULL;
 
-	for (p = all_cards; p != 0; p = p->link) {
+	for (p = all_cards; p != NULL; p = p->link) {
 	    FIELD **f = form_fields(p->form);
 	    int n;
 
-	    for (n = 0; f[n] != 0; n++) {
+	    for (n = 0; f[n] != NULL; n++) {
 		char *s = field_buffer(f[n], 0);
-		if (s != 0
-		    && (s = strdup(s)) != 0) {
+		if (s != NULL
+		    && (s = strdup(s)) != NULL) {
 		    trim(s);
 		    fprintf(fp, "%s%s\n", n ? "\t" : "", s);
 		    free(s);
@@ -237,7 +237,7 @@
     CARD *p;
     int count = 0;
 
-    for (p = all_cards; p != 0; p = p->link)
+    for (p = all_cards; p != NULL; p = p->link)
 	count++;
 
     return count;
@@ -263,7 +263,7 @@
 static CARD *
 next_card(CARD * now)
 {
-    if (now->link != 0) {
+    if (now->link != NULL) {
 	CARD *tst = now->link;
 	if (isVisible(tst))
 	    now = tst;
@@ -280,7 +280,7 @@
 prev_card(CARD * now)
 {
     CARD *p;
-    for (p = all_cards; p != 0; p = p->link) {
+    for (p = all_cards; p != NULL; p = p->link) {
 	if (p->link == now) {
 	    if (!isVisible(p))
 		p = prev_card(p);
@@ -355,7 +355,7 @@
     set_field_just(f[1], JUSTIFY_LEFT);
     field_opts_off(f[1], O_BLANK);
 
-    f[2] = 0;
+    f[2] = NULL;
     return f;
 }
 
@@ -375,7 +375,7 @@
 {
     int n;
 
-    for (n = 0; f[n] != 0; ++n) {
+    for (n = 0; f[n] != NULL; ++n) {
 	free_field(f[n]);
     }
     free(f);
@@ -414,9 +414,9 @@
     x = 0;
 
     /* make a panel for each CARD */
-    for (p = all_cards; p != 0; p = p->link) {
+    for (p = all_cards; p != NULL; p = p->link) {
 
-	if ((win = newwin(panel_high, panel_wide, y, x)) == 0)
+	if ((win = newwin(panel_high, panel_wide, y, x)) == NULL)
 	    break;
 
 	wbkgd(win, (chtype) COLOR_PAIR(pair_2));
@@ -478,7 +478,7 @@
 		x = 0;
 
 		show_legend();
-		for (p = all_cards; p != 0; p = p->link) {
+		for (p = all_cards; p != NULL; p = p->link) {
 		    FIELD **oldf = form_fields(p->form);
 		    WINDOW *olds = form_sub(p->form);
 
@@ -528,7 +528,7 @@
 	}
     }
 #if NO_LEAKS
-    while (all_cards != 0) {
+    while (all_cards != NULL) {
 	p = all_cards;
 	all_cards = all_cards->link;
 
Index: test/chgat.c
Prereq:  1.23 
--- ncurses-6.5-20241130+/test/chgat.c	2024-10-06 22:35:55.000000000 +0000
+++ ncurses-6.5-20241207/test/chgat.c	2024-12-07 22:27:13.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: chgat.c,v 1.23 2024/10/06 22:35:55 tom Exp $
+ * $Id: chgat.c,v 1.24 2024/12/07 22:27:13 tom Exp $
  *
  * test-driver for chgat/wchgat/mvchgat/mvwchgat
  */
@@ -77,7 +77,7 @@
     };
     /* *INDENT-ON* */
 
-    const char *result = 0;
+    const char *result = NULL;
 
     if (has_colors()) {
 	static bool first = TRUE;
@@ -114,7 +114,7 @@
     };
     /* *INDENT-ON* */
 
-    const char *result = 0;
+    const char *result = NULL;
 
     if (state < SIZEOF(table)) {
 	*attr = table[state].attr;
@@ -151,9 +151,9 @@
     getyx(win, y, x);
     wmove(win, 0, 0);
     wprintw(win, "Count %d", sp->count);
-    if (sp->v_msg != 0)
+    if (sp->v_msg != NULL)
 	wprintw(win, " Video %s", sp->v_msg);
-    if (sp->c_msg != 0)
+    if (sp->c_msg != NULL)
 	wprintw(win, " Color %s", sp->c_msg);
     wclrtoeol(win);
     wmove(win, y, x);
@@ -165,10 +165,10 @@
     WINDOW *win1 = newwin(sp->y_max - 2, sp->x_max - 2,
 			  sp->y_beg + 1, sp->x_beg + 1);
 
-    if (win1 != 0 && sp->y_max > 4 && sp->x_max > 4) {
+    if (win1 != NULL && sp->y_max > 4 && sp->x_max > 4) {
 	WINDOW *win2 = derwin(win1, sp->y_max - 4, sp->x_max - 4, 1, 1);
 
-	if (win2 != 0) {
+	if (win2 != NULL) {
 	    box(win1, 0, 0);
 	    wrefresh(win1);
 	    func(win2);
@@ -180,7 +180,7 @@
 	delwin(win1);
 	touchwin(win);
     } else {
-	if (win1 != 0)
+	if (win1 != NULL)
 	    delwin(win1);
 	beep();
     }
@@ -218,7 +218,7 @@
 	,"=     resets count to zero."
 	,"-     negates count."
 	,"?     shows this help-window"
-	,0
+	,NULL
     };
 
     popup_msg(win, msgs);
@@ -230,14 +230,14 @@
     switch (sp->ch) {
     case ' ':			/* next test-iteration */
 	if (has_colors()) {
-	    if ((sp->c_msg = color_params(++(sp->c), &(sp->pair))) == 0) {
+	    if ((sp->c_msg = color_params(++(sp->c), &(sp->pair))) == NULL) {
 		sp->c_msg = color_params(sp->c = 0, &(sp->pair));
-		if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == 0) {
+		if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == NULL) {
 		    sp->v_msg = video_params(sp->v = 0, &(sp->attr));
 		}
 	    }
 	} else {
-	    if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == 0) {
+	    if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == NULL) {
 		sp->v_msg = video_params(sp->v = 0, &(sp->attr));
 	    }
 	}
Index: test/clip_printw.c
Prereq:  1.25 
--- ncurses-6.5-20241130+/test/clip_printw.c	2024-10-06 22:36:25.000000000 +0000
+++ ncurses-6.5-20241207/test/clip_printw.c	2024-12-07 22:22:51.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: clip_printw.c,v 1.25 2024/10/06 22:36:25 tom Exp $
+ * $Id: clip_printw.c,v 1.26 2024/12/07 22:22:51 tom Exp $
  *
  * demonstrate how to use printw with/without wrapping.
  */
@@ -122,7 +122,7 @@
     };
     /* *INDENT-ON* */
 
-    const char *result = 0;
+    const char *result = NULL;
 
     if (has_colors()) {
 	static bool first = TRUE;
@@ -161,7 +161,7 @@
     };
     /* *INDENT-ON* */
 
-    const char *result = 0;
+    const char *result = NULL;
 
     if (state < SIZEOF(table)) {
 	*attr = table[state].attr;
@@ -201,9 +201,9 @@
     wmove(win, 0, 0);
     wprintw(win, "Clip %s", sp->single ? "line" : "window");
     wprintw(win, " Count %d", sp->count);
-    if (sp->v_msg != 0)
+    if (sp->v_msg != NULL)
 	wprintw(win, " Video %s", sp->v_msg);
-    if (sp->c_msg != 0)
+    if (sp->c_msg != NULL)
 	wprintw(win, " Color %s", sp->c_msg);
     wprintw(win, " (%d)", sp->status);
     wclrtoeol(win);
@@ -219,14 +219,14 @@
 			  sp->y_beg + MARGIN,
 			  sp->x_beg + MARGIN);
 
-    if (win1 != 0 && sp->y_max > 4 && sp->x_max > 4) {
+    if (win1 != NULL && sp->y_max > 4 && sp->x_max > 4) {
 	WINDOW *win2 = derwin(win1,
 			      sp->y_max - (2 * MARGIN) - 2,
 			      sp->x_max - (2 * MARGIN) - 2,
 			      (win == stdscr) ? Y_BASE : Y_BASE,
 			      MARGIN);
 
-	if (win2 != 0) {
+	if (win2 != NULL) {
 	    box(win1, 0, 0);
 	    wrefresh(win1);
 	    func(win2);
@@ -283,7 +283,7 @@
 	,".     calls vw_printw at the current position with the given count."
 	,"=     resets count to zero."
 	,"?     shows this help-window"
-	,0
+	,NULL
     };
 
     popup_msg(win, msgs);
@@ -297,14 +297,14 @@
     switch (sp->ch) {
     case ' ':			/* next test-iteration */
 	if (has_colors()) {
-	    if ((sp->c_msg = color_params(++(sp->c), &(sp->pair))) == 0) {
+	    if ((sp->c_msg = color_params(++(sp->c), &(sp->pair))) == NULL) {
 		sp->c_msg = color_params(sp->c = 0, &(sp->pair));
-		if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == 0) {
+		if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == NULL) {
 		    sp->v_msg = video_params(sp->v = 0, &(sp->attr));
 		}
 	    }
 	} else {
-	    if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == 0) {
+	    if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == NULL) {
 		sp->v_msg = video_params(sp->v = 0, &(sp->attr));
 	    }
 	}
@@ -396,7 +396,7 @@
 		need = (unsigned) want - 1;
 		_nc_STRCPY(fmt, "%c%s%c", sizeof(fmt));
 	    }
-	    if ((buffer = typeMalloc(char, need + 1)) != 0) {
+	    if ((buffer = typeMalloc(char, need + 1)) != NULL) {
 		for (j = 0; j < need; ++j) {
 		    buffer[j] = (char) ('A' + (j % 26));
 		}
Index: test/color_content.c
Prereq:  1.21 
--- ncurses-6.5-20241130+/test/color_content.c	2024-11-30 18:31:01.000000000 +0000
+++ ncurses-6.5-20241207/test/color_content.c	2024-12-07 22:22:51.000000000 +0000
@@ -26,7 +26,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: color_content.c,v 1.21 2024/11/30 18:31:01 tom Exp $
+ * $Id: color_content.c,v 1.22 2024/12/07 22:22:51 tom Exp $
  */
 
 #define NEED_TIME_H
@@ -186,7 +186,7 @@
 	my_color_t g;
 	my_color_t b;
 	if (ColorContent(color, &r, &g, &b) == OK) {
-	    if (expected != 0) {
+	    if (expected != NULL) {
 		if (r != expected[color].r)
 		    success = FALSE;
 		if (g != expected[color].g)
Index: test/color_name.h
Prereq:  1.10 
--- ncurses-6.5-20241130+/test/color_name.h	2024-10-05 19:26:24.000000000 +0000
+++ ncurses-6.5-20241207/test/color_name.h	2024-12-07 22:17:24.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: color_name.h,v 1.10 2024/10/05 19:26:24 tom Exp $
+ * $Id: color_name.h,v 1.11 2024/12/07 22:17:24 tom Exp $
  */
 
 #ifndef __COLORNAME_H
@@ -62,10 +62,10 @@
 color_code(const char *color)
 {
     int result = 0;
-    char *endp = 0;
+    char *endp = NULL;
 
     if ((result = (int) strtol(color, &endp, 0)) >= 0
-	&& (endp == 0 || *endp == 0)) {
+	&& (endp == NULL || *endp == 0)) {
 	;
     } else if (!strcmp(color, "default")) {
 	result = -1;
@@ -87,7 +87,7 @@
 color_name(int color)
 {
     static char temp[20];
-    const char *result = 0;
+    const char *result = NULL;
 
     if (color >= (int) SIZEOF(the_color_names)) {
 	_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp)) "%d", color);
Index: test/combine.c
Prereq:  1.25 
--- ncurses-6.5-20241130+/test/combine.c	2024-11-30 19:08:20.000000000 +0000
+++ ncurses-6.5-20241207/test/combine.c	2024-12-07 22:22:51.000000000 +0000
@@ -26,7 +26,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: combine.c,v 1.25 2024/11/30 19:08:20 tom Exp $
+ * $Id: combine.c,v 1.26 2024/12/07 22:22:51 tom Exp $
  */
 
 #include <test.priv.h>
@@ -174,7 +174,7 @@
 	++d;
     }
     popup_msg2(current, msgs);
-    for (s = 0; msgs[s] != 0; ++s) {
+    for (s = 0; msgs[s] != NULL; ++s) {
 	free(msgs[s]);
     }
     free(msgs);
Index: test/demo_altkeys.c
Prereq:  1.17 
--- ncurses-6.5-20241130+/test/demo_altkeys.c	2023-02-25 18:08:02.000000000 +0000
+++ ncurses-6.5-20241207/test/demo_altkeys.c	2024-12-07 23:02:27.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2018-2023,2024 Thomas E. Dickey                                *
  * Copyright 2005-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: demo_altkeys.c,v 1.17 2023/02/25 18:08:02 tom Exp $
+ * $Id: demo_altkeys.c,v 1.18 2024/12/07 23:02:27 tom Exp $
  *
  * Demonstrate the define_key() function.
  * Thomas Dickey - 2005/10/22
@@ -49,7 +49,7 @@
 {
     FILE *fp;
 
-    if ((fp = fopen(MY_LOGFILE, "a")) != 0) {
+    if ((fp = fopen(MY_LOGFILE, "a")) != NULL) {
 	char temp[256];
 	int y, x, n;
 	int need = sizeof(temp) - 1;
@@ -114,7 +114,7 @@
     unlink(MY_LOGFILE);
 
     setlocale(LC_ALL, "");
-    if (newterm(0, stdout, stdin) == 0) {
+    if (newterm(NULL, stdout, stdin) == NULL) {
 	fprintf(stderr, "Cannot initialize terminal\n");
 	ExitProgram(EXIT_FAILURE);
     }
@@ -135,7 +135,7 @@
     }
     for (n = KEY_MIN; n < KEY_MAX; ++n) {
 	char *value;
-	if ((value = keybound(n, 0)) != 0) {
+	if ((value = keybound(n, 0)) != NULL) {
 	    size_t need = strlen(value) + 2;
 	    char *temp = typeMalloc(char, need);
 	    _nc_SPRINTF(temp, _nc_SLIMIT(need) "\033%s", value);
@@ -158,7 +158,7 @@
 	printw("Keycode %d, name %s%s\n",
 	       ch,
 	       escaped ? "ESC-" : "",
-	       name != 0 ? name : "<null>");
+	       name != NULL ? name : "<null>");
 	log_last_line(stdscr);
 	clrtoeol();
 	if (ch == 'q')
Index: test/demo_defkey.c
Prereq:  1.36 
--- ncurses-6.5-20241130+/test/demo_defkey.c	2024-10-05 18:20:04.000000000 +0000
+++ ncurses-6.5-20241207/test/demo_defkey.c	2024-12-07 22:22:51.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: demo_defkey.c,v 1.36 2024/10/05 18:20:04 tom Exp $
+ * $Id: demo_defkey.c,v 1.37 2024/12/07 22:22:51 tom Exp $
  *
  * Demonstrate the define_key() function.
  * Thomas Dickey - 2002/11/23
@@ -47,7 +47,7 @@
 {
     FILE *fp;
 
-    if ((fp = fopen(MY_LOGFILE, "a")) != 0) {
+    if ((fp = fopen(MY_LOGFILE, "a")) != NULL) {
 	char temp[256];
 	int y, x, n;
 	int need = sizeof(temp) - 1;
@@ -98,7 +98,7 @@
 static char *
 visible(const char *string)
 {
-    char *result = 0;
+    char *result = NULL;
 
     if (VALID_STRING(string) && *string != '\0') {
 	int pass;
@@ -130,15 +130,15 @@
     int rc;
     const char *code_name = keyname(code);
     char *old_string;
-    char *vis_string = 0;
+    char *vis_string = NULL;
     char temp[80];
 
-    if (code_name == 0) {
+    if (code_name == NULL) {
 	_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp)) "Keycode %d", code);
 	code_name = temp;
     }
 
-    if ((old_string = keybound(code, 0)) != 0) {
+    if ((old_string = keybound(code, 0)) != NULL) {
 	wprintw(win, "%s is %s\n",
 		code_name,
 		vis_string = visible(old_string));
@@ -153,7 +153,7 @@
     if ((rc = key_defined(new_string)) > 0) {
 	wprintw(win, "%s was bound to %s\n", vis_string, keyname(rc));
 	log_last_line(win);
-    } else if (new_string != 0 && rc < 0) {
+    } else if (new_string != NULL && rc < 0) {
 	wprintw(win, "%s conflicts with longer strings\n", vis_string);
 	log_last_line(win);
     }
@@ -161,18 +161,18 @@
     if (rc == ERR) {
 	wprintw(win, "%s unchanged\n", code_name);
 	log_last_line(win);
-    } else if (new_string != 0) {
+    } else if (new_string != NULL) {
 	wprintw(win, "%s is now bound to %s\n",
 		vis_string,
 		code_name);
 	log_last_line(win);
-    } else if (old_string != 0) {
+    } else if (old_string != NULL) {
 	wprintw(win, "%s deleted\n", code_name);
 	log_last_line(win);
     }
-    if (vis_string != 0)
+    if (vis_string != NULL)
 	free(vis_string);
-    if (old_string != 0)
+    if (old_string != NULL)
 	free(old_string);
 }
 
@@ -182,14 +182,14 @@
     char *value = tigetstr(name);
 
     if (VALID_STRING(value)) {
-	const char *prefix = 0;
+	const char *prefix = NULL;
 
 	if (!(strncmp) (value, "\033[", (size_t) 2)) {
 	    prefix = "\033O";
 	} else if (!(strncmp) (value, "\033O", (size_t) 2)) {
 	    prefix = "\033[";
 	}
-	if (prefix != 0) {
+	if (prefix != NULL) {
 	    char temp[BUFSIZ];
 	    _nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))
 			"%s%s", prefix, value + 2);
@@ -207,7 +207,7 @@
 static void
 remove_definition(WINDOW *win, int code)
 {
-    really_define_key(win, 0, code);
+    really_define_key(win, NULL, code);
 }
 
 static void
@@ -297,7 +297,7 @@
 	const char *name = keyname(ch);
 	wprintw(win, "Keycode %d, name %s\n",
 		ch,
-		name != 0 ? name : "<null>");
+		name != NULL ? name : "<null>");
 	log_last_line(win);
 	wclrtoeol(win);
 	if (ch == 'q')
Index: test/demo_forms.c
Prereq:  1.67 
--- ncurses-6.5-20241130+/test/demo_forms.c	2024-10-06 21:15:12.000000000 +0000
+++ ncurses-6.5-20241207/test/demo_forms.c	2024-12-07 22:27:13.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: demo_forms.c,v 1.67 2024/10/06 21:15:12 tom Exp $
+ * $Id: demo_forms.c,v 1.68 2024/12/07 22:27:13 tom Exp $
  *
  * Demonstrate a variety of functions from the form library.
  * Thomas Dickey - 2003/4/26
@@ -50,7 +50,7 @@
 static int j_value = 0;
 static int m_value = 0;
 static int o_value = 0;
-static char *t_value = 0;
+static char *t_value = NULL;
 
 static void
 failed(const char *s)
@@ -82,9 +82,9 @@
 get_data(const char *name)
 {
     char *result = t_value;
-    if (my_data != 0) {
+    if (my_data != NULL) {
 	int n;
-	for (n = 0; my_data[n].name != 0; ++n) {
+	for (n = 0; my_data[n].name != NULL; ++n) {
 	    if (!strcmp(name, my_data[n].name)) {
 		result = my_data[n].value;
 		break;
@@ -102,21 +102,21 @@
 {
     FILE *fp = fopen(filename, "r");
 
-    if (fp != 0) {
+    if (fp != NULL) {
 	char buffer[BUFSIZ];
 	char *colon;
 	int more = 0;
 	int item = 0;
 
 	my_data = typeCalloc(MY_DATA, (size_t) 100);	/* FIXME */
-	while (fgets(buffer, sizeof(buffer), fp) != 0) {
+	while (fgets(buffer, sizeof(buffer), fp) != NULL) {
 	    chomp(buffer);
 	    if (more) {
 		if (strcmp(buffer, ".")) {
 		    char *prior = my_data[more - 1].value;
 		    size_t need = strlen(buffer) + 2 + strlen(prior);
 		    char *value = typeRealloc(char, need, prior);
-		    if (value == 0)
+		    if (value == NULL)
 			failed("realloc");
 		    _nc_STRCAT(value, "\n", need);
 		    _nc_STRCAT(value, buffer, need);
@@ -126,13 +126,13 @@
 		}
 	    } else if (*buffer == '#') {
 		continue;
-	    } else if ((colon = strchr(buffer, ':')) != 0) {
+	    } else if ((colon = strchr(buffer, ':')) != NULL) {
 		char *name;
 		char *value;
 		*colon++ = '\0';
 		name = strdup(buffer);
 		value = strdup(colon);
-		if (name == 0 || value == 0)
+		if (name == NULL || value == NULL)
 		    failed("strdup");
 		my_data[item].name = name;
 		my_data[item].value = value;
@@ -245,10 +245,10 @@
 another_field(NCURSES_CONST FORM *form, NCURSES_CONST FIELD *const field)
 {
     FIELD **f = form_fields(form);
-    FIELD *result = 0;
+    FIELD *result = NULL;
     int n;
 
-    for (n = 0; f[n] != 0; ++n) {
+    for (n = 0; f[n] != NULL; ++n) {
 	if (f[n] != field) {
 	    result = f[n];
 	    field_opts_on(result, O_SELECTABLE);
@@ -273,7 +273,7 @@
 	help_edit_field();
 	break;
     case MY_EDT_MODE:
-	if ((field = current_field(form)) != 0) {
+	if ((field = current_field(form)) != NULL) {
 	    set_current_field(form, another_field(form, field));
 	    if ((unsigned) field_opts(field) & O_EDIT) {
 		field_opts_off(field, O_EDIT);
@@ -324,7 +324,7 @@
 	waddstr(win, " behind");
     waddch(win, '\n');
 
-    if ((field = current_field(form)) != 0) {
+    if ((field = current_field(form)) != NULL) {
 	NCURSES_CONST FIELDTYPE *type;
 	int nbuf;
 
@@ -333,7 +333,7 @@
 		new_page(field) ? "*" : "",
 		field_index(field), field_count(form),
 		field_arg(field) ? "(arg)" : "");
-	if ((type = field_type(field)) != 0) {
+	if ((type = field_type(field)) != NULL) {
 	    if (type == TYPE_ALNUM)
 		waddstr(win, "ALNUM");
 	    else if (type == TYPE_ALPHA)
@@ -384,7 +384,7 @@
 	waddstr(win, "\n");
 	for (nbuf = 0; nbuf <= 2; ++nbuf) {
 	    NCURSES_CONST char *buffer;
-	    if ((buffer = field_buffer(field, nbuf)) != 0) {
+	    if ((buffer = field_buffer(field, nbuf)) != NULL) {
 		wprintw(win, "buffer %d:", nbuf);
 		(void) wattrset(win, A_REVERSE);
 		if (nbuf) {
@@ -410,7 +410,7 @@
     int pg;
     NCURSES_CONST char *fname;
     static NCURSES_CONST char *my_enum[] =
-    {"first", "second", "third", 0};
+    {"first", "second", "third", NULL};
 
 #ifdef NCURSES_MOUSE_VERSION
     mousemask(ALL_MOUSE_EVENTS, (mmask_t *) 0);
@@ -514,7 +514,7 @@
 
     f[n] = (FIELD *) 0;
 
-    if ((form = new_form(f)) != 0) {
+    if ((form = new_form(f)) != NULL) {
 	NCURSES_CONST WINDOW *w;
 	WINDOW *also;
 	int finished = 0;
@@ -543,7 +543,7 @@
 
 	free_form(form);
     }
-    for (c = 0; f[c] != 0; c++) {
+    for (c = 0; f[c] != NULL; c++) {
 	free_edit_field(f[c]);
 	free_field(f[c]);
     }
Index: test/demo_keyok.c
Prereq:  1.10 
--- ncurses-6.5-20241130+/test/demo_keyok.c	2024-08-24 17:16:49.000000000 +0000
+++ ncurses-6.5-20241207/test/demo_keyok.c	2024-12-07 22:22:51.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: demo_keyok.c,v 1.10 2024/08/24 17:16:49 tom Exp $
+ * $Id: demo_keyok.c,v 1.11 2024/12/07 22:22:51 tom Exp $
  *
  * Demonstrate the keyok() function.
  * Thomas Dickey - 2002/11/23
@@ -100,7 +100,7 @@
 	prior = ch;
 	wprintw(win, "Keycode %d, name %s\n",
 		ch,
-		name != 0 ? name : "<null>");
+		name != NULL ? name : "<null>");
 	wclrtoeol(win);
 	wrefresh(win);
 	if (ch >= KEY_MIN) {
Index: test/demo_menus.c
Prereq:  1.85 
--- ncurses-6.5-20241130+/test/demo_menus.c	2024-11-30 18:52:09.000000000 +0000
+++ ncurses-6.5-20241207/test/demo_menus.c	2024-12-07 22:27:13.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: demo_menus.c,v 1.85 2024/11/30 18:52:09 tom Exp $
+ * $Id: demo_menus.c,v 1.86 2024/12/07 22:27:13 tom Exp $
  *
  * Demonstrate a variety of functions from the menu library.
  * Thomas Dickey - 2005/4/9
@@ -311,9 +311,9 @@
 menu_destroy(MENU * m, int itemsToo)
 {
     Trace(("menu_destroy %p", (void *) m));
-    if (m != 0) {
+    if (m != NULL) {
 	ITEM **items = menu_items(m);
-	const char *blob = 0;
+	const char *blob = NULL;
 	int count;
 
 	count = item_count(m);
@@ -335,7 +335,7 @@
 	if (count > 0 && itemsToo) {
 	    if (itemsToo & 1) {
 		ITEM **ip = items;
-		if (ip != 0) {
+		if (ip != NULL) {
 		    while (*ip)
 			free_item(*ip++);
 		}
@@ -362,14 +362,14 @@
     static MENU_DATA table[] =
     {
 	{"Exit", call_files, 0},
-	{(char *) 0, 0, 0}
+	{(char *) 0, NULL, 0}
     };
     static ITEM *items[SIZEOF(table)];
 
     ITEM **ip = items;
     int n;
 
-    for (n = 0; table[n].name != 0; ++n) {
+    for (n = 0; table[n].name != NULL; ++n) {
 	*ip = new_item(table[n].name, empty);
 	set_item_userptr(*ip, (void *) &table[n]);
 	++ip;
@@ -413,17 +413,17 @@
 	MY_DATA("Pumas"),
 	MY_DATA("Lions, Tigers, Bears, (Oh my!), Newts, Platypi, Lemurs"),
 	MY_DATA("Lions, Tigers, Bears, (Oh my!), Newts, Platypi, Lemurs, Lions, Tigers, Bears, (Oh my!), Newts, Platypi, Lemurs"),
-	{(char *) 0, 0, 0}
+	{(char *) 0, NULL, 0}
     };
     static ITEM **items;
 
     ITEM **ip;
-    MENU_DATA *ap = 0;
-    MENU_DATA *myList = 0;
+    MENU_DATA *ap = NULL;
+    MENU_DATA *myList = NULL;
     int i;
     size_t count = 0;
 
-    if (filename != 0) {
+    if (filename != NULL) {
 	struct stat sb;
 	if (stat(filename, &sb) == 0
 	    && (sb.st_mode & S_IFMT) == S_IFREG
@@ -436,9 +436,9 @@
 	    Trace(("build_select_menu blob=%p, items=%p",
 		   (void *) blob,
 		   (void *) items));
-	    if (blob != 0 && list != 0) {
+	    if (blob != NULL && list != NULL) {
 		FILE *fp = fopen(filename, "r");
-		if (fp != 0) {
+		if (fp != NULL) {
 		    if (fread(blob, sizeof(char), size, fp) == size) {
 			bool mark = TRUE;
 			unsigned j, k;
@@ -456,7 +456,7 @@
 				blob[j] = ' ';	/* menu items are printable */
 			    }
 			}
-			list[k].name = 0;
+			list[k].name = NULL;
 			count = k;
 			ap = myList = list;
 		    }
@@ -464,28 +464,28 @@
 		}
 		loaded_file = TRUE;
 	    }
-	    if (ap == 0)
+	    if (ap == NULL)
 		free(items);
 	}
     }
-    if (ap == 0) {
+    if (ap == NULL) {
 	count = SIZEOF(table) - 1;
 	items = typeCalloc(ITEM *, count + 1);
 	ap = table;
     }
 
     ip = items;
-    for (i = 0; ap[i].name != 0; ++i) {
+    for (i = 0; ap[i].name != NULL; ++i) {
 	ap[i].func = call_select;
 	ap[i].mask = (unsigned) i;
 	*ip = new_item(ap[i].name, empty);
 	set_item_userptr(*ip, (void *) &table[i]);
 	++ip;
     }
-    *ip = 0;
+    *ip = NULL;
 
     mpSelect = menu_create(items, (int) count, 1, number);
-    if (myList != 0)
+    if (myList != NULL)
 	free(myList);
 }
 
@@ -527,7 +527,7 @@
     T_TBL(TRACE_ATTRS),
     T_TBL(TRACE_MAXIMUM),
     {
-	(char *) 0, 0, 0
+	(char *) 0, NULL, 0
     }
 };
 
@@ -539,7 +539,7 @@
     ITEM **ip = items;
     int n;
 
-    for (n = 0; t_tbl[n].name != 0; n++) {
+    for (n = 0; t_tbl[n].name != NULL; n++) {
 	*ip = new_item(t_tbl[n].name, empty);
 	set_item_userptr(*ip, (void *) &t_tbl[n]);
 	++ip;
@@ -556,8 +556,8 @@
     static size_t need = 12;
     int n;
 
-    if (buf == 0) {
-	for (n = 0; t_tbl[n].name != 0; n++)
+    if (buf == NULL) {
+	for (n = 0; t_tbl[n].name != NULL; n++)
 	    need += strlen(t_tbl[n].name) + 2;
 	buf = typeMalloc(char, need);
 	if (!buf)
@@ -568,7 +568,7 @@
 	_nc_STRCAT(buf, t_tbl[0].name ? t_tbl[0].name : "", need);
 	_nc_STRCAT(buf, ", ", need);
     } else {
-	for (n = 1; t_tbl[n].name != 0; n++)
+	for (n = 1; t_tbl[n].name != NULL; n++)
 	    if ((tlevel & t_tbl[n].mask) == t_tbl[n].mask) {
 		_nc_STRCAT(buf, t_tbl[n].name, need);
 		_nc_STRCAT(buf, ", ", need);
@@ -595,7 +595,7 @@
     if (i == items[0]) {
 	if (item_value(i)) {
 	    ITEM **p;
-	    for (p = items + 1; *p != 0; p++)
+	    for (p = items + 1; *p != NULL; p++)
 		if (item_value(*p)) {
 		    set_item_value(*p, FALSE);
 		    changed = TRUE;
@@ -670,7 +670,7 @@
 	break;
 #endif
     default:
-	result = 0;
+	result = NULL;
 	break;
     }
     return result;
@@ -693,14 +693,14 @@
 #ifdef TRACE
 	{"Trace", call_menus, 2},
 #endif
-	{(char *) 0, 0, 0}
+	{(char *) 0, NULL, 0}
     };
     static ITEM *items[SIZEOF(table)];
 
     ITEM **ip = items;
     int n;
 
-    for (n = 0; table[n].name != 0; ++n) {
+    for (n = 0; table[n].name != NULL; ++n) {
 	*ip = new_item(table[n].name, empty);
 	set_item_userptr(*ip, (void *) &table[n]);
 	++ip;
@@ -1023,7 +1023,7 @@
 #endif /* HAVE_RIPOFFLINE */
 #ifdef TRACE
 	case 'D':
-	    curses_trace((unsigned) strtoul(optarg, 0, 0));
+	    curses_trace((unsigned) strtoul(optarg, NULL, 0));
 	    break;
 #endif
 	case OPTS_VERSION:
@@ -1046,7 +1046,7 @@
 	init_pair(2, COLOR_BLUE, COLOR_WHITE);
     }
     status = newwin(3, COLS, LINES - 3, 0);
-    build_menus(argc > 1 ? argv[1] : 0);
+    build_menus(argc > 1 ? argv[1] : NULL);
     perform_menus();
     destroy_menus();
 
Index: test/demo_new_pair.c
Prereq:  1.31 
--- ncurses-6.5-20241130+/test/demo_new_pair.c	2024-11-09 20:43:56.000000000 +0000
+++ ncurses-6.5-20241207/test/demo_new_pair.c	2024-12-07 22:22:51.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: demo_new_pair.c,v 1.31 2024/11/09 20:43:56 tom Exp $
+ * $Id: demo_new_pair.c,v 1.32 2024/12/07 22:22:51 tom Exp $
  *
  * Demonstrate the alloc_pair() function.
  */
@@ -50,7 +50,7 @@
 valid_cap(NCURSES_CONST char *name)
 {
     const char *value = tigetstr(name);
-    return (value != 0 && value != (char *) -1) ? TRUE : FALSE;
+    return (value != NULL && value != (char *) -1) ? TRUE : FALSE;
 }
 
 static attr_t
@@ -188,7 +188,7 @@
 	"  ?      print this screen (exit on any character).",
 	"",
 	"To exit this program, press ^Q, ^[ or \"q\".",
-	0
+	NULL
     };
 
     bool done = FALSE;
@@ -243,7 +243,7 @@
 	fprintf(stderr, "cannot open terminal for output\n");
 	ExitProgram(EXIT_FAILURE);
     }
-    if (newterm(NULL, output, stdin) == 0) {
+    if (newterm(NULL, output, stdin) == NULL) {
 	fprintf(stderr, "Cannot initialize terminal\n");
 	if (output != NULL)
 	    fclose(output);
Index: test/demo_panels.c
Prereq:  1.52 
--- ncurses-6.5-20241130+/test/demo_panels.c	2024-11-23 19:07:23.000000000 +0000
+++ ncurses-6.5-20241207/test/demo_panels.c	2024-12-07 22:27:13.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: demo_panels.c,v 1.52 2024/11/23 19:07:23 tom Exp $
+ * $Id: demo_panels.c,v 1.53 2024/12/07 22:27:13 tom Exp $
  *
  * Demonstrate a variety of functions from the panel library.
  */
@@ -52,18 +52,18 @@
 static void
 close_input(void)
 {
-    if (log_in != 0) {
+    if (log_in != NULL) {
 	fclose(log_in);
-	log_in = 0;
+	log_in = NULL;
     }
 }
 
 static void
 close_output(void)
 {
-    if (log_out != 0) {
+    if (log_out != NULL) {
 	fclose(log_out);
-	log_out = 0;
+	log_out = NULL;
     }
 }
 
@@ -88,7 +88,7 @@
 saywhat(NCURSES_CONST char *text)
 {
     WINDOW *win = statusline();
-    if (text != 0 && *text != '\0') {
+    if (text != NULL && *text != '\0') {
 	waddstr(win, text);
 	waddstr(win, "; ");
     }
@@ -124,7 +124,7 @@
 
     show_position(text, also, which, y1, x1);
 
-    if (log_in != 0) {
+    if (log_in != NULL) {
 	if (fscanf(log_in, "%c%d,%d\n", &cmd, &y1, &x1) == 3) {
 	    switch (cmd) {
 	    case LAST_POS:
@@ -204,12 +204,12 @@
 mkpanel(short color, int rows, int cols, int tly, int tlx)
 {
     WINDOW *win;
-    PANEL *pan = 0;
+    PANEL *pan = NULL;
     char *userdata = typeMalloc(char, 6);
 
-    if ((win = newwin(rows, cols, tly, tlx)) != 0) {
+    if ((win = newwin(rows, cols, tly, tlx)) != NULL) {
 	keypad(win, TRUE);
-	if ((pan = new_panel(win)) == 0) {
+	if ((pan = new_panel(win)) == NULL) {
 	    delwin(win);
 	} else if (use_colors) {
 	    short fg = (short) ((color == COLOR_BLUE)
@@ -231,7 +231,7 @@
 static void
 my_remove_panel(PANEL **pans, int which)
 {
-    if (pans[which] != 0) {
+    if (pans[which] != NULL) {
 	PANEL *pan = pans[which];
 	WINDOW *win = panel_window(pan);
 	char *user = (char *) panel_userptr(pan);
@@ -240,7 +240,7 @@
 	del_panel(pan);
 	delwin(win);
 
-	pans[which] = 0;
+	pans[which] = NULL;
     }
 }
 
@@ -297,7 +297,7 @@
 static void
 my_move_panel(PANEL **pans, int which, bool continuous)
 {
-    if (pans[which] != 0) {
+    if (pans[which] != NULL) {
 	int code;
 	int y0, x0;
 	int y1, x1;
@@ -322,7 +322,7 @@
 static void
 my_resize_panel(PANEL **pans, int which, FillPanel myFill)
 {
-    if (pans[which] != 0) {
+    if (pans[which] != NULL) {
 	int code;
 	int y0, x0;
 	int y1, x1;
@@ -341,7 +341,7 @@
 				  ABS(x1 - x0) + 1,
 				  MIN(y0, y1),
 				  MIN(x0, x1));
-	    if (next != 0) {
+	    if (next != NULL) {
 		keypad(next, TRUE);
 		if (use_colors) {
 		    wbkgdset(next, (chtype) (COLOR_PAIR(which) | ' '));
@@ -411,7 +411,7 @@
 
     source[0] = (wchar_t) (digit + 0xff10);
     source[1] = 0;
-    setcchar(target, source, A_NORMAL, 0, 0);
+    setcchar(target, source, A_NORMAL, 0, NULL);
 }
 
 static void
@@ -507,7 +507,7 @@
 
     memset(table, 0, sizeof(table));
     for (j = 1; j <= MAX_PANELS; ++j) {
-	table[j].valid = (px[j] != 0);
+	table[j].valid = (px[j] != NULL);
 	if (table[j].valid) {
 	    table[j].hidden = panel_hidden(px[j]) ? TRUE : FALSE;
 	    table[j].above = panel_above(px[j]);
@@ -515,11 +515,11 @@
 	}
     }
 
-    if ((win = newwin(LINES - 1, COLS, 0, 0)) != 0) {
+    if ((win = newwin(LINES - 1, COLS, 0, 0)) != NULL) {
 	PANEL *pan;
 
 	keypad(win, TRUE);
-	if ((pan = new_panel(win)) != 0) {
+	if ((pan = new_panel(win)) != NULL) {
 	    werase(win);
 	    MvWPrintw(win, 0, 0, "Panels:\n");
 	    for (j = 1; j <= MAX_PANELS; ++j) {
@@ -554,7 +554,7 @@
 static int my_##func(PANEL *pan) \
 { \
     int code = ERR; \
-    if (pan != 0) { \
+    if (pan != NULL) { \
 	code = func(pan); \
     } \
     return code; \
@@ -578,7 +578,7 @@
 	return;
     }
 
-    if (log_in != 0) {
+    if (log_in != NULL) {
 	pflush();
     }
 
@@ -617,7 +617,7 @@
 static bool
 ok_letter(int ch)
 {
-    return isalpha(UChar(ch)) && strchr("bcdhmMrst", ch) != 0;
+    return isalpha(UChar(ch)) && strchr("bcdhmMrst", ch) != NULL;
 }
 
 static bool
@@ -644,8 +644,8 @@
     waddstr(win, "Command:");
     buffer[length = 0] = '\0';
 
-    if (log_in != 0) {
-	if (fgets(buffer, limit - 3, log_in) != 0) {
+    if (log_in != NULL) {
+	if (fgets(buffer, limit - 3, log_in) != NULL) {
 	    length = (int) strlen(buffer);
 	    while (length > 0 && isspace(UChar(buffer[length - 1])))
 		buffer[--length] = '\0';
Index: test/demo_termcap.c
Prereq:  1.72 
--- ncurses-6.5-20241130+/test/demo_termcap.c	2024-11-30 18:31:01.000000000 +0000
+++ ncurses-6.5-20241207/test/demo_termcap.c	2024-12-07 22:27:13.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey
  *
- * $Id: demo_termcap.c,v 1.72 2024/11/30 18:31:01 tom Exp $
+ * $Id: demo_termcap.c,v 1.73 2024/12/07 22:27:13 tom Exp $
  *
  * A simple demo of the termcap interface.
  */
@@ -101,7 +101,7 @@
 static long total_n_values;
 static long total_s_values;
 
-#define isCapName(c) (isgraph(c) && strchr("^=:\\", c) == 0)
+#define isCapName(c) (isgraph(c) && strchr("^=:\\", c) == NULL)
 #define EachCapName(n) n = 33; n < 127; ++n
 
 static char *
@@ -150,17 +150,17 @@
 static char *
 next_dbitem(void)
 {
-    char *result = 0;
+    char *result = NULL;
 
     if (db_list) {
-	if ((result = db_list[db_item]) == 0) {
+	if ((result = db_list[db_item]) == NULL) {
 	    db_item = 0;
 	    result = db_list[0];
 	} else {
 	    db_item++;
 	}
     }
-    if (result != 0)
+    if (result != NULL)
 	printf("** %s\n", result);
     return result;
 }
@@ -174,7 +174,7 @@
 	for (n = 0; db_list[n]; ++n)
 	    free(db_list[n]);
 	free(db_list);
-	db_list = 0;
+	db_list = NULL;
     }
 }
 #endif /* NO_LEAKS */
@@ -259,7 +259,7 @@
     NCURSES_CONST char *str;
     int num;
 
-    if ((str = tgetstr(cap, &ap)) != 0) {
+    if ((str = tgetstr(cap, &ap)) != NULL) {
 	total_values++;
 	total_s_values++;
 	if (!q_opt) {
@@ -343,7 +343,7 @@
 	if (b_opt) {
 	    for (n = 0;; ++n) {
 		cap = my_boolcodes[n];
-		if (cap == 0)
+		if (cap == NULL)
 		    break;
 		dumpit(cap);
 	    }
@@ -352,7 +352,7 @@
 	if (n_opt) {
 	    for (n = 0;; ++n) {
 		cap = my_numcodes[n];
-		if (cap == 0)
+		if (cap == NULL)
 		    break;
 		dumpit(cap);
 	    }
@@ -361,16 +361,16 @@
 	if (s_opt) {
 	    for (n = 0;; ++n) {
 		cap = my_strcodes[n];
-		if (cap == 0)
+		if (cap == NULL)
 		    break;
 		dumpit(cap);
 	    }
 	}
 #ifdef NCURSES_VERSION
-	if (x_opt && (my_blob == 0) && y_opt) {
+	if (x_opt && (my_blob == NULL) && y_opt) {
 #if NCURSES_XNAMES
 	    NCURSES_CONST TERMTYPE *term = (TERMTYPE *) cur_term;
-	    if (term != 0
+	    if (term != NULL
 		&& ((NUM_BOOLEANS(term) != BOOLCOUNT)
 		    || (NUM_NUMBERS(term) != NUMCOUNT)
 		    || (NUM_STRINGS(term) != STRCOUNT))) {
@@ -429,16 +429,16 @@
      * None of the arrays could be larger than the input-file, and since it
      * is small, just allocate the maximum for simplicity.
      */
-    if ((my_blob = malloc((size_t) sb.st_size + 1)) == 0 ||
-	(my_boolcodes = typeCalloc(char *, sb.st_size)) == 0 ||
-	  (my_numcodes = typeCalloc(char *, sb.st_size)) == 0 ||
-	  (my_numvalues = typeCalloc(char *, sb.st_size)) == 0 ||
-	  (my_strcodes = typeCalloc(char *, sb.st_size)) == 0 ||
-	  (my_strvalues = typeCalloc(char *, sb.st_size)) == 0) {
+    if ((my_blob = malloc((size_t) sb.st_size + 1)) == NULL ||
+	(my_boolcodes = typeCalloc(char *, sb.st_size)) == NULL ||
+	  (my_numcodes = typeCalloc(char *, sb.st_size)) == NULL ||
+	  (my_numvalues = typeCalloc(char *, sb.st_size)) == NULL ||
+	  (my_strcodes = typeCalloc(char *, sb.st_size)) == NULL ||
+	  (my_strvalues = typeCalloc(char *, sb.st_size)) == NULL) {
 	failed("cannot allocate memory for input-file");
     }
 
-    if ((fp = fopen(input_name, "r")) == 0) {
+    if ((fp = fopen(input_name, "r")) == NULL) {
 	failed("cannot open input-file");
     } else {
 	len = fread(my_blob, sizeof(char), (size_t) sb.st_size, fp);
@@ -674,11 +674,11 @@
 	    break;
 	}
     }
-    my_boolcodes[count_bools] = 0;
-    my_numcodes[count_nums] = 0;
-    my_numvalues[count_nums] = 0;
-    my_strcodes[count_strs] = 0;
-    my_strvalues[count_strs] = 0;
+    my_boolcodes[count_bools] = NULL;
+    my_numcodes[count_nums] = NULL;
+    my_numvalues[count_nums] = NULL;
+    my_strcodes[count_strs] = NULL;
+    my_strvalues[count_strs] = NULL;
 
 #if 0
     printf("bools:%d\n", (int) count_bools);
@@ -702,11 +702,11 @@
     int pass;
     size_t count;
     size_t length = 1;
-    char **result = 0;
-    char *unused = 0;
+    char **result = NULL;
+    char *unused = NULL;
 
     for (pass = 0; pass < 2; ++pass) {
-	for (count = 0; list[count] != 0; ++count) {
+	for (count = 0; list[count] != NULL; ++count) {
 	    size_t chunk = strlen(list[count]) + 1;
 	    if (pass == 0) {
 		length += chunk;
@@ -720,7 +720,7 @@
 	    char *blob = malloc(length);
 	    result = typeCalloc(char *, count + 1);
 	    unused = blob;
-	    if (blob == 0 || result == 0)
+	    if (blob == NULL || result == NULL)
 		failed("copy_code_list failed");
 	}
     }
@@ -786,7 +786,7 @@
 #if defined(NCURSES_VERSION) || defined(HAVE_CURSES_DATA_OSPEED)
     bool v_opt = FALSE;
 #endif
-    NCURSES_CONST char *input_name = 0;
+    NCURSES_CONST char *input_name = NULL;
 
     int repeat;
     int r_opt = 1;
@@ -864,7 +864,7 @@
 		for (n = optind; n < argc; ++n) {
 		    brute_force(argv[n]);
 		}
-	    } else if ((name = getenv("TERM")) != 0) {
+	    } else if ((name = getenv("TERM")) != NULL) {
 		brute_force(name);
 	    } else {
 		static NCURSES_CONST char dumb[] = "dumb";
@@ -872,7 +872,7 @@
 	    }
 	}
     } else {
-	if (input_name != 0) {
+	if (input_name != NULL) {
 	    parse_description(input_name);
 	}
 #if USE_CODE_LISTS
@@ -891,7 +891,7 @@
 		for (n = optind; n < argc; ++n) {
 		    demo_termcap(argv[n]);
 		}
-	    } else if ((name = getenv("TERM")) != 0) {
+	    } else if ((name = getenv("TERM")) != NULL) {
 		demo_termcap(name);
 	    } else {
 		static NCURSES_CONST char dumb[] = "dumb";
Index: test/demo_terminfo.c
Prereq:  1.61 
--- ncurses-6.5-20241130+/test/demo_terminfo.c	2024-11-30 18:31:01.000000000 +0000
+++ ncurses-6.5-20241207/test/demo_terminfo.c	2024-12-07 22:27:13.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey
  *
- * $Id: demo_terminfo.c,v 1.61 2024/11/30 18:31:01 tom Exp $
+ * $Id: demo_terminfo.c,v 1.62 2024/12/07 22:27:13 tom Exp $
  *
  * A simple demo of the terminfo interface.
  */
@@ -141,17 +141,17 @@
 static char *
 next_dbitem(void)
 {
-    char *result = 0;
+    char *result = NULL;
 
     if (db_list) {
-	if ((result = db_list[db_item]) == 0) {
+	if ((result = db_list[db_item]) == NULL) {
 	    db_item = 0;
 	    result = db_list[0];
 	} else {
 	    db_item++;
 	}
     }
-    if (result != 0)
+    if (result != NULL)
 	printf("** %s\n", result);
     return result;
 }
@@ -165,7 +165,7 @@
 	for (n = 0; db_list[n]; ++n)
 	    free(db_list[n]);
 	free(db_list);
-	db_list = 0;
+	db_list = NULL;
     }
 }
 #endif
@@ -176,7 +176,7 @@
     const char *str;
     int num;
 
-    if ((str = tigetstr(cap)) != 0 && (str != (char *) -1)) {
+    if ((str = tigetstr(cap)) != NULL && (str != (char *) -1)) {
 	total_values++;
 	total_s_values++;
 	if (!q_opt) {
@@ -339,7 +339,7 @@
     if (b_opt) {
 	for (n = 0;; ++n) {
 	    cap = my_boolcodes[n];
-	    if (cap == 0)
+	    if (cap == NULL)
 		break;
 	    dumpit(cap, fullname(bool, n));
 	}
@@ -348,7 +348,7 @@
     if (n_opt) {
 	for (n = 0;; ++n) {
 	    cap = my_numcodes[n];
-	    if (cap == 0)
+	    if (cap == NULL)
 		break;
 	    dumpit(cap, fullname(num, n));
 	}
@@ -357,17 +357,17 @@
     if (s_opt) {
 	for (n = 0;; ++n) {
 	    cap = my_strcodes[n];
-	    if (cap == 0)
+	    if (cap == NULL)
 		break;
 	    dumpit(cap, fullname(str, n));
 	}
     }
 #ifdef NCURSES_VERSION
-    if (x_opt && (my_blob == 0)) {
+    if (x_opt && (my_blob == NULL)) {
 	if (y_opt) {
 #if NCURSES_XNAMES
 	    const TERMTYPE *term = (TERMTYPE *) cur_term;
-	    if (term != 0
+	    if (term != NULL
 		&& ((NUM_BOOLEANS(term) != BOOLCOUNT)
 		    || (NUM_NUMBERS(term) != NUMCOUNT)
 		    || (NUM_STRINGS(term) != STRCOUNT))) {
@@ -455,16 +455,16 @@
      * None of the arrays could be larger than the input-file, and since it
      * is small, just allocate the maximum for simplicity.
      */
-    if ((my_blob = malloc((size_t) sb.st_size + 1)) == 0 ||
-	(my_boolcodes = typeCalloc(char *, sb.st_size)) == 0 ||
-	  (my_numcodes = typeCalloc(char *, sb.st_size)) == 0 ||
-	  (my_numvalues = typeCalloc(char *, sb.st_size)) == 0 ||
-	  (my_strcodes = typeCalloc(char *, sb.st_size)) == 0 ||
-	  (my_strvalues = typeCalloc(char *, sb.st_size)) == 0) {
+    if ((my_blob = malloc((size_t) sb.st_size + 1)) == NULL ||
+	(my_boolcodes = typeCalloc(char *, sb.st_size)) == NULL ||
+	  (my_numcodes = typeCalloc(char *, sb.st_size)) == NULL ||
+	  (my_numvalues = typeCalloc(char *, sb.st_size)) == NULL ||
+	  (my_strcodes = typeCalloc(char *, sb.st_size)) == NULL ||
+	  (my_strvalues = typeCalloc(char *, sb.st_size)) == NULL) {
 	failed("cannot allocate memory for input-file");
     }
 
-    if ((fp = fopen(input_name, "r")) == 0) {
+    if ((fp = fopen(input_name, "r")) == NULL) {
 	failed("cannot open input-file");
     } else {
 	len = fread(my_blob, sizeof(char), (size_t) sb.st_size, fp);
@@ -704,11 +704,11 @@
 	    break;
 	}
     }
-    my_boolcodes[count_bools] = 0;
-    my_numcodes[count_nums] = 0;
-    my_numvalues[count_nums] = 0;
-    my_strcodes[count_strs] = 0;
-    my_strvalues[count_strs] = 0;
+    my_boolcodes[count_bools] = NULL;
+    my_numcodes[count_nums] = NULL;
+    my_numvalues[count_nums] = NULL;
+    my_strcodes[count_strs] = NULL;
+    my_strvalues[count_strs] = NULL;
 
 #if 0
     printf("# bools:%d\n", (int) count_bools);
@@ -732,11 +732,11 @@
     int pass;
     size_t count;
     size_t length = 1;
-    char **result = 0;
-    char *unused = 0;
+    char **result = NULL;
+    char *unused = NULL;
 
     for (pass = 0; pass < 2; ++pass) {
-	for (count = 0; list[count] != 0; ++count) {
+	for (count = 0; list[count] != NULL; ++count) {
 	    size_t chunk = strlen(list[count]) + 1;
 	    if (pass == 0) {
 		length += chunk;
@@ -750,7 +750,7 @@
 	    char *blob = malloc(length);
 	    result = typeCalloc(char *, count + 1);
 	    unused = blob;
-	    if (blob == 0 || result == 0)
+	    if (blob == NULL || result == NULL)
 		failed("copy_code_list failed");
 	}
     }
@@ -815,7 +815,7 @@
     int repeat;
     NCURSES_CONST char *name;
     int r_opt = 1;
-    const char *input_name = 0;
+    const char *input_name = NULL;
 
     while ((ch = getopt(argc, argv, OPTS_COMMON "abd:e:fi:nqr:sxy")) != -1) {
 	switch (ch) {
@@ -888,7 +888,7 @@
 		for (n = optind; n < argc; ++n) {
 		    brute_force(argv[n]);
 		}
-	    } else if ((name = getenv("TERM")) != 0) {
+	    } else if ((name = getenv("TERM")) != NULL) {
 		brute_force(name);
 	    } else {
 		static NCURSES_CONST char dumb[] = "dumb";
@@ -896,7 +896,7 @@
 	    }
 	}
     } else {
-	if (input_name != 0) {
+	if (input_name != NULL) {
 	    parse_description(input_name);
 	}
 #if USE_CODE_LISTS
@@ -915,7 +915,7 @@
 		for (n = optind; n < argc; ++n) {
 		    demo_terminfo(argv[n]);
 		}
-	    } else if ((name = getenv("TERM")) != 0) {
+	    } else if ((name = getenv("TERM")) != NULL) {
 		demo_terminfo(name);
 	    } else {
 		static NCURSES_CONST char dumb[] = "dumb";
@@ -933,8 +933,8 @@
 
 #if NO_LEAKS
     free_dblist();
-    if (input_name != 0) {
-	if (my_blob != 0) {
+    if (input_name != NULL) {
+	if (my_blob != NULL) {
 	    free(my_blob);
 	    free(my_boolcodes);
 	    free(my_numcodes);
Index: test/ditto.c
Prereq:  1.59 
--- ncurses-6.5-20241130+/test/ditto.c	2023-09-23 17:08:43.000000000 +0000
+++ ncurses-6.5-20241207/test/ditto.c	2024-12-07 23:02:27.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2018-2023,2024 Thomas E. Dickey                                *
  * Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey (1998-on)
  *
- * $Id: ditto.c,v 1.59 2023/09/23 17:08:43 tom Exp $
+ * $Id: ditto.c,v 1.60 2024/12/07 23:02:27 tom Exp $
  *
  * The program illustrates how to set up multiple screens from a single
  * program.
@@ -157,15 +157,15 @@
     int aslave;
     char slave_name[1024];
     char s_option[sizeof(slave_name) + 80];
-    const char *xterm_prog = 0;
+    const char *xterm_prog = NULL;
 
-    if ((xterm_prog = getenv("XTERM_PROG")) == 0)
+    if ((xterm_prog = getenv("XTERM_PROG")) == NULL)
 	xterm_prog = "xterm";
 
-    if (openpty(&amaster, &aslave, slave_name, 0, 0) != 0
+    if (openpty(&amaster, &aslave, slave_name, NULL, NULL) != 0
 	|| strlen(slave_name) > sizeof(slave_name) - 1)
 	failed("openpty");
-    if (strrchr(slave_name, '/') == 0) {
+    if (strrchr(slave_name, '/') == NULL) {
 	errno = EISDIR;
 	failed(slave_name);
     }
@@ -176,7 +176,7 @@
 	_exit(0);
     }
     fp = fdopen(amaster, "r+");
-    if (fp == 0)
+    if (fp == NULL)
 	failed(path);
 #else
     struct stat sb;
@@ -266,7 +266,7 @@
 			     target->output,
 			     target->input);
 
-    if (target->screen == 0)
+    if (target->screen == NULL)
 	failed("newterm");
 
     (void) USING_SCREEN(target->screen, init_screen, target);
@@ -429,7 +429,7 @@
 	}
     }
 
-    if ((data = typeCalloc(DITTO, (size_t) argc)) == 0)
+    if ((data = typeCalloc(DITTO, (size_t) argc)) == NULL)
 	failed("calloc data");
 
     assert(data != 0);
@@ -478,7 +478,7 @@
      */
     for (j = argc - 1; j >= 0; j--) {
 	LockIt();
-	USING_SCREEN(data[j].screen, close_screen, 0);
+	USING_SCREEN(data[j].screen, close_screen, NULL);
 	fprintf(data[j].output, "**Closed\r\n");
 
 	/*
Index: test/dots.c
Prereq:  1.46 
--- ncurses-6.5-20241130+/test/dots.c	2024-10-06 21:17:54.000000000 +0000
+++ ncurses-6.5-20241207/test/dots.c	2024-12-07 22:27:13.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey <dickey@clark.net> 1999
  *
- * $Id: dots.c,v 1.46 2024/10/06 21:17:54 tom Exp $
+ * $Id: dots.c,v 1.47 2024/12/07 22:27:13 tom Exp $
  *
  * A simple demo of the terminfo interface.
  */
@@ -102,7 +102,7 @@
 get_number(NCURSES_CONST char *cap, int map)
 {
     int result = map;
-    if (cap != 0) {
+    if (cap != NULL) {
 	int check = tigetnum(cap);
 	if (check > 0)
 	    result = check;
@@ -191,12 +191,12 @@
     SetupAlarm(r_option);
     InitAndCatch(setupterm((char *) 0, 1, (int *) 0), onsig);
 
-    srand((unsigned) time(0));
+    srand((unsigned) time(NULL));
 
     outs(clear_screen);
     outs(cursor_invisible);
 
-#define GetNumber(ln,sn) get_number(f_option ? #sn : 0, ln)
+#define GetNumber(ln,sn) get_number(f_option ? #sn : NULL, ln)
     my_colors = GetNumber(max_colors, colors);
     if (my_colors > 1) {
 	if (!VALID_STRING(set_a_foreground)
Index: test/dots_curses.c
Prereq:  1.26 
--- ncurses-6.5-20241130+/test/dots_curses.c	2024-11-30 17:48:07.000000000 +0000
+++ ncurses-6.5-20241207/test/dots_curses.c	2024-12-07 22:32:11.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey
  *
- * $Id: dots_curses.c,v 1.26 2024/11/30 17:48:07 tom Exp $
+ * $Id: dots_curses.c,v 1.27 2024/12/07 22:32:11 tom Exp $
  *
  * A simple demo of the curses interface used for comparison with termcap.
  */
@@ -170,7 +170,7 @@
 	}
     }
 
-    srand((unsigned) time(0));
+    srand((unsigned) time(NULL));
 
     SetupAlarm(r_option);
     InitAndCatch(initscr(), onsig);
Index: test/dots_mvcur.c
Prereq:  1.32 
--- ncurses-6.5-20241130+/test/dots_mvcur.c	2024-10-06 21:17:54.000000000 +0000
+++ ncurses-6.5-20241207/test/dots_mvcur.c	2024-12-07 22:32:11.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey - 2007
  *
- * $Id: dots_mvcur.c,v 1.32 2024/10/06 21:17:54 tom Exp $
+ * $Id: dots_mvcur.c,v 1.33 2024/12/07 22:32:11 tom Exp $
  *
  * A simple demo of the terminfo interface, and mvcur.
  */
@@ -103,7 +103,7 @@
 get_number(NCURSES_CONST char *cap, int map)
 {
     int result = map;
-    if (cap != 0) {
+    if (cap != NULL) {
 	int check = tigetnum(cap);
 	if (check > 0)
 	    result = check;
@@ -195,18 +195,18 @@
     InitAndCatch((sp = newterm((char *) 0, stdout, stdin)), onsig);
     refresh();			/* needed with Solaris curses to cancel endwin */
 
-    if (sp == 0) {
+    if (sp == NULL) {
 	fprintf(stderr, "Cannot initialize terminal\n");
 	ExitProgram(EXIT_FAILURE);
     }
 
-    srand((unsigned) time(0));
+    srand((unsigned) time(NULL));
 
     outs(clear_screen);
     outs(cursor_home);
     outs(cursor_invisible);
 
-#define GetNumber(ln,sn) get_number(f_option ? #sn : 0, ln)
+#define GetNumber(ln,sn) get_number(f_option ? #sn : NULL, ln)
     my_colors = GetNumber(max_colors, colors);
     if (my_colors > 1) {
 	if (!VALID_STRING(set_a_foreground)
Index: test/dots_termcap.c
Prereq:  1.35 
--- ncurses-6.5-20241130+/test/dots_termcap.c	2024-10-06 21:18:35.000000000 +0000
+++ ncurses-6.5-20241207/test/dots_termcap.c	2024-12-07 22:32:11.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey
  *
- * $Id: dots_termcap.c,v 1.35 2024/10/06 21:18:35 tom Exp $
+ * $Id: dots_termcap.c,v 1.37 2024/12/07 22:32:11 tom Exp $
  *
  * A simple demo of the termcap interface.
  */
@@ -153,7 +153,7 @@
 /*
  * napms is a curses function which happens to be usable without initializing
  * the screen, but if this program happened to be build with a "real" termcap
- * library, there is nothing like napms. 
+ * library, there is nothing like napms.
  */
 #if HAVE_NAPMS
 #define my_napms(ms) napms(ms)
@@ -178,9 +178,9 @@
 get_number(NCURSES_CONST char *cap, const char *env)
 {
     int result = tgetnum(cap);
-    const char *value = env ? getenv(env) : 0;
-    if (value != 0 && *value != 0) {
-	char *next = 0;
+    const char *value = env ? getenv(env) : NULL;
+    if (value != NULL && *value != 0) {
+	char *next = NULL;
 	long check = strtol(value, &next, 10);
 	if (check > 0 && *next == '\0')
 	    result = (int) check;
@@ -263,12 +263,12 @@
 	}
     }
 
-    if ((name = getenv("TERM")) == 0) {
+    if ((name = getenv("TERM")) == NULL) {
 	fprintf(stderr, "TERM is not set\n");
 	ExitProgram(EXIT_FAILURE);
     }
 
-    srand((unsigned) time(0));
+    srand((unsigned) time(NULL));
 
     SetupAlarm((unsigned) r_option);
     InitAndCatch(ch = tgetent(buffer, name), onsig);
@@ -285,7 +285,7 @@
     }
 
     num_colors = tgetnum("Co");
-#define GetNumber(cap,env) get_number(cap, e_option ? env : 0)
+#define GetNumber(cap,env) get_number(cap, e_option ? env : NULL)
     num_lines = GetNumber("li", "LINES");
     num_columns = GetNumber("co", "COLUMNS");
 
Index: test/dots_xcurses.c
Prereq:  1.31 
--- ncurses-6.5-20241130+/test/dots_xcurses.c	2024-11-30 17:41:18.000000000 +0000
+++ ncurses-6.5-20241207/test/dots_xcurses.c	2024-12-07 22:32:11.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey
  *
- * $Id: dots_xcurses.c,v 1.31 2024/11/30 17:41:18 tom Exp $
+ * $Id: dots_xcurses.c,v 1.32 2024/12/07 22:32:11 tom Exp $
  *
  * A simple demo of the wide-curses interface used for comparison with termcap.
  */
@@ -202,7 +202,7 @@
     }
 
     setlocale(LC_ALL, "");
-    srand((unsigned) time(0));
+    srand((unsigned) time(NULL));
 
     SetupAlarm(r_option);
     InitAndCatch(initscr(), onsig);
Index: test/dump_window.c
Prereq:  1.5 
--- ncurses-6.5-20241130+/test/dump_window.c	2023-11-11 00:30:50.000000000 +0000
+++ ncurses-6.5-20241207/test/dump_window.c	2024-12-07 23:03:07.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2020,2023 Thomas E. Dickey                                *
+ * Copyright 2018-2023,2024 Thomas E. Dickey                                *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
  * copy of this software and associated documentation files (the            *
@@ -26,7 +26,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: dump_window.c,v 1.5 2023/11/11 00:30:50 tom Exp $
+ * $Id: dump_window.c,v 1.6 2024/12/07 23:03:07 tom Exp $
  */
 #include <dump_window.h>
 
@@ -37,7 +37,7 @@
 {
     int result = 0;
     close_dump();
-    if ((dumpfp = fopen(fn, "a")) != 0)
+    if ((dumpfp = fopen(fn, "a")) != NULL)
 	result = 1;
     return result;
 }
@@ -45,9 +45,9 @@
 void
 close_dump(void)
 {
-    if (dumpfp != 0) {
+    if (dumpfp != NULL) {
 	fclose(dumpfp);
-	dumpfp = 0;
+	dumpfp = NULL;
     }
 }
 
@@ -55,14 +55,14 @@
 dump_window(WINDOW *w)
 {
     wgetch(w);
-    if (dumpfp != 0) {
+    if (dumpfp != NULL) {
 	int y, x;
 	int oldy, oldx;
 	int maxy, maxx;
 	int pass;
-	char *cvec = 0;
-	char *avec = 0;
-	char *pvec = 0;
+	char *cvec = NULL;
+	char *avec = NULL;
+	char *pvec = NULL;
 	int ccnt = 0;
 	int acnt = 0;
 	int pcnt = 0;
Index: test/dup_field.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/test/dup_field.c	2024-10-06 20:07:19.000000000 +0000
+++ ncurses-6.5-20241207/test/dup_field.c	2024-12-07 22:32:11.000000000 +0000
@@ -26,7 +26,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: dup_field.c,v 1.11 2024/10/06 20:07:19 tom Exp $
+ * $Id: dup_field.c,v 1.12 2024/12/07 22:32:11 tom Exp $
  *
  * Demonstrate dup_field().
  */
@@ -91,7 +91,7 @@
 	const char *code = keyname(commands[n].code);
 	size_t need = 5;
 #ifdef NCURSES_VERSION
-	if ((name = form_request_name(commands[n].result)) == 0)
+	if ((name = form_request_name(commands[n].result)) == NULL)
 #endif
 	    name = commands[n].help;
 	need = 5 + strlen(code) + strlen(name);
@@ -101,9 +101,9 @@
     }
     msgs[used++] =
 	strdup("Arrow keys move within a field as you would expect.");
-    msgs[used] = 0;
+    msgs[used] = NULL;
     popup_msg2(stdscr, msgs);
-    for (n = 0; msgs[n] != 0; ++n) {
+    for (n = 0; msgs[n] != NULL; ++n) {
 	free(msgs[n]);
     }
     free(msgs);
@@ -347,7 +347,7 @@
 
     all_fields[n] = (FIELD *) 0;
 
-    if ((form = new_form(all_fields)) != 0) {
+    if ((form = new_form(all_fields)) != NULL) {
 	int finished = 0;
 
 	post_form(form);
@@ -369,7 +369,7 @@
 
 	free_form(form);
     }
-    for (c = 0; all_fields[c] != 0; c++) {
+    for (c = 0; all_fields[c] != NULL; c++) {
 	free_edit_field(all_fields[c]);
 	free_field(all_fields[c]);
     }
Index: test/echochar.c
Prereq:  1.26 
--- ncurses-6.5-20241130+/test/echochar.c	2023-05-27 20:13:10.000000000 +0000
+++ ncurses-6.5-20241207/test/echochar.c	2024-12-07 23:03:07.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2019-2023,2024 Thomas E. Dickey                                *
  * Copyright 2006-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: echochar.c,v 1.26 2023/05/27 20:13:10 tom Exp $
+ * $Id: echochar.c,v 1.27 2024/12/07 23:03:07 tom Exp $
  *
  * Demonstrate the echochar function (compare to dots.c).
  * Thomas Dickey - 2006/11/4
@@ -108,7 +108,7 @@
     double c;
     bool use_colors;
     bool opt_r = FALSE;
-    char *my_pairs = 0;
+    char *my_pairs = NULL;
     int last_fg = 0;
     int last_bg = 0;
 
@@ -134,10 +134,10 @@
 	if (COLOR_PAIRS > 0) {
 	    my_pairs = typeCalloc(char, (size_t) COLOR_PAIRS);
 	}
-	use_colors = (my_pairs != 0);
+	use_colors = (my_pairs != NULL);
     }
 
-    srand((unsigned) time(0));
+    srand((unsigned) time(NULL));
 
     curs_set(0);
 
Index: test/edit_field.c
Prereq:  1.32 
--- ncurses-6.5-20241130+/test/edit_field.c	2024-06-29 17:49:56.000000000 +0000
+++ ncurses-6.5-20241207/test/edit_field.c	2024-12-07 22:22:51.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: edit_field.c,v 1.32 2024/06/29 17:49:56 tom Exp $
+ * $Id: edit_field.c,v 1.33 2024/12/07 22:22:51 tom Exp $
  *
  * A wrapper for form_driver() which keeps track of the user's editing changes
  * for each field, and makes the resulting length available as a
@@ -188,7 +188,7 @@
 	const char *code = keyname(commands[n].code);
 	size_t need = 5;
 #ifdef NCURSES_VERSION
-	if ((name = form_request_name(commands[n].result)) == 0)
+	if ((name = form_request_name(commands[n].result)) == NULL)
 #endif
 	    name = commands[n].help;
 	need = 5 + strlen(code) + strlen(name);
@@ -198,9 +198,9 @@
     }
     msgs[used++] =
 	strdup("Arrow keys move within a field as you would expect.");
-    msgs[used] = 0;
+    msgs[used] = NULL;
     popup_msg2(stdscr, msgs);
-    for (n = 0; msgs[n] != 0; ++n) {
+    for (n = 0; msgs[n] != NULL; ++n) {
 	free(msgs[n]);
     }
     free(msgs);
@@ -249,7 +249,7 @@
 {
     char empty[1];
     FieldAttrs *ptr = field_attrs(f);
-    if (ptr == 0) {
+    if (ptr == NULL) {
 	int rows, cols, frow, fcol, nrow, nbuf;
 
 	ptr = typeCalloc(FieldAttrs, (size_t) 1);
@@ -259,7 +259,7 @@
 	    ptr->row_lengths = typeCalloc(int, (size_t) nrow + 1);
 	}
     }
-    if (value == 0) {
+    if (value == NULL) {
 	value = empty;
 	*value = '\0';
     }
@@ -421,7 +421,7 @@
 free_edit_field(FIELD *f)
 {
     FieldAttrs *ptr = field_attrs(f);
-    if (ptr != 0) {
+    if (ptr != NULL) {
 	free(ptr->row_lengths);
 	free(ptr);
     }
Index: test/filter.c
Prereq:  1.40 
--- ncurses-6.5-20241130+/test/filter.c	2024-11-30 16:49:53.000000000 +0000
+++ ncurses-6.5-20241207/test/filter.c	2024-12-07 22:40:19.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author:  Thomas E. Dickey 1998
  *
- * $Id: filter.c,v 1.40 2024/11/30 16:49:53 tom Exp $
+ * $Id: filter.c,v 1.41 2024/12/07 22:40:19 tom Exp $
  *
  * An example of the 'filter()' function in ncurses, this program prompts
  * for commands and executes them (like a command shell).  It illustrates
@@ -264,12 +264,12 @@
 /*
  * Cancel xterm's alternate-screen mode (from dialog -TD)
  */
-#define isprivate(s) ((s) != 0 && strstr(s, "\033[?") != 0)
+#define isprivate(s) ((s) != NULL && strstr(s, "\033[?") != NULL)
 static void
 cancel_altscreen(void)
 {
     if (isatty(fileno(stdout))
-	&& key_mouse != 0	/* xterm and kindred */
+	&& key_mouse != NULL	/* xterm and kindred */
 	&& isprivate(enter_ca_mode)
 	&& isprivate(exit_ca_mode)) {
 	/*
@@ -292,8 +292,8 @@
 	 * implementation of alternate-screen in rxvt, etc., which clear more
 	 * of the display than they should.
 	 */
-	enter_ca_mode = 0;
-	exit_ca_mode = 0;
+	enter_ca_mode = NULL;
+	exit_ca_mode = NULL;
     }
 }
 #endif
@@ -380,7 +380,7 @@
     if (i_option) {
 	initscr();
     } else {
-	if (newterm((char *) 0, stdout, stdin) == 0) {
+	if (newterm((char *) 0, stdout, stdin) == NULL) {
 	    fprintf(stderr, "cannot initialize terminal\n");
 	    ExitProgram(EXIT_FAILURE);
 	}
Index: test/foldkeys.c
Prereq:  1.12 
--- ncurses-6.5-20241130+/test/foldkeys.c	2023-02-25 16:51:01.000000000 +0000
+++ ncurses-6.5-20241207/test/foldkeys.c	2024-12-07 23:03:07.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2018-2023,2024 Thomas E. Dickey                                *
  * Copyright 2006-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey, 2006
  *
- * $Id: foldkeys.c,v 1.12 2023/02/25 16:51:01 tom Exp $
+ * $Id: foldkeys.c,v 1.13 2024/12/07 23:03:07 tom Exp $
  *
  * Demonstrate a method for altering key definitions at runtime.
  *
@@ -55,7 +55,7 @@
 {
     FILE *fp;
 
-    if ((fp = fopen(MY_LOGFILE, "a")) != 0) {
+    if ((fp = fopen(MY_LOGFILE, "a")) != NULL) {
 	char temp[256];
 	int y, x, n;
 	int need = sizeof(temp) - 1;
@@ -112,7 +112,7 @@
     for (code = 0; code < STRCOUNT; ++code) {
 	NCURSES_CONST char *name = strnames[code];
 	NCURSES_CONST char *value = tigetstr(name);
-	if (value != 0 && value != (NCURSES_CONST char *) -1) {
+	if (value != NULL && value != (NCURSES_CONST char *) -1) {
 	    info[info_len].name = strnames[code];
 	    info[info_len].code = key_defined(value);
 	    info[info_len].value = value;
@@ -129,7 +129,7 @@
      */
     for (code = KEY_MAX; code < MAX_KEYS; ++code) {
 	NCURSES_CONST char *name = keyname(code);
-	if (name != 0) {
+	if (name != NULL) {
 	    info[info_len].name = name;
 	    info[info_len].code = code;
 	    info[info_len].value = tigetstr(name);
@@ -156,7 +156,7 @@
 		      final) == 3
 	    && *final != ';'
 	    && (need = strlen(info[j].value)) != 0
-	    && (value = strdup(info[j].value)) != 0) {
+	    && (value = strdup(info[j].value)) != NULL) {
 	    (void) need;	/* _nc_SLIMIT is normally nothing  */
 	    _nc_SPRINTF(value, _nc_SLIMIT(need) "\033[%d%c", first, *final);
 	    for (k = 0; k < info_len; ++k) {
@@ -232,7 +232,7 @@
     if (optind < argc)
 	usage(FALSE);
 
-    if (newterm(0, stdout, stdin) == 0) {
+    if (newterm(NULL, stdout, stdin) == NULL) {
 	fprintf(stderr, "Cannot initialize terminal\n");
 	ExitProgram(EXIT_FAILURE);
     }
@@ -262,7 +262,7 @@
 	printw("Keycode %d, name %s%s\n",
 	       ch,
 	       escaped ? "ESC-" : "",
-	       name != 0 ? name : "<null>");
+	       name != NULL ? name : "<null>");
 	log_last_line(stdscr);
 	clrtoeol();
 	if (ch == 'q')
Index: test/form_driver_w.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/test/form_driver_w.c	2024-10-06 23:13:40.000000000 +0000
+++ ncurses-6.5-20241207/test/form_driver_w.c	2024-12-07 22:32:11.000000000 +0000
@@ -32,7 +32,7 @@
  ****************************************************************************/
 
 /*
- * $Id: form_driver_w.c,v 1.18 2024/10/06 23:13:40 tom Exp $
+ * $Id: form_driver_w.c,v 1.19 2024/12/07 22:32:11 tom Exp $
  *
  * Test form_driver_w (int, int, wchar_t), a wide char aware
  * replacement of form_driver.
@@ -74,7 +74,7 @@
 	"  ^D,^Q,ESC           - quit program",
 	"  <Tab>,<Down>        - move to next field",
 	"  <BackTab>,<Up>      - move to previous field",
-	0
+	NULL
     };
 
 #define NUM_FIELDS 3
Index: test/gdc.c
Prereq:  1.63 
--- ncurses-6.5-20241130+/test/gdc.c	2024-11-30 18:56:02.000000000 +0000
+++ ncurses-6.5-20241207/test/gdc.c	2024-12-07 22:32:11.000000000 +0000
@@ -34,7 +34,7 @@
  * modified 10-18-89 for curses (jrl)
  * 10-18-89 added signal handling
  *
- * $Id: gdc.c,v 1.63 2024/11/30 18:56:02 tom Exp $
+ * $Id: gdc.c,v 1.64 2024/12/07 22:32:11 tom Exp $
  */
 
 #include <test.priv.h>
@@ -294,8 +294,8 @@
     InitAndCatch({
 	if (redirected) {
 	    NCURSES_CONST char *name = getenv("TERM");
-	    if (name == 0
-		|| newterm(name, ofp, ifp) == 0) {
+	    if (name == NULL
+		|| newterm(name, ofp, ifp) == NULL) {
 		fprintf(stderr, "cannot open terminal\n");
 		ExitProgram(EXIT_FAILURE);
 	    }
Index: test/inch_wide.c
Prereq:  1.14 
--- ncurses-6.5-20241130+/test/inch_wide.c	2024-10-06 23:14:31.000000000 +0000
+++ ncurses-6.5-20241207/test/inch_wide.c	2024-12-07 22:32:11.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: inch_wide.c,v 1.14 2024/10/06 23:14:31 tom Exp $
+ * $Id: inch_wide.c,v 1.15 2024/12/07 22:32:11 tom Exp $
  */
 /*
        int in_wch(cchar_t *wcval);
@@ -70,11 +70,11 @@
 	" h,j,k,l (and arrow-keys) - move viewport",
 	" w                        - recur to new window",
 	"                            for next input file",
-	0
+	NULL
     };
 
-    WINDOW *txtbox = 0;
-    WINDOW *txtwin = 0;
+    WINDOW *txtbox = NULL;
+    WINDOW *txtwin = NULL;
     FILE *fp;
     int j;
     int txt_x = 0, txt_y = 0;
@@ -82,7 +82,7 @@
     cchar_t ch;
     cchar_t text[MAX_COLS];
 
-    if (argv[level] == 0) {
+    if (argv[level] == NULL) {
 	beep();
 	return FALSE;
     }
@@ -110,7 +110,7 @@
     txt_x = 0;
     wmove(txtwin, txt_y, txt_x);
 
-    if ((fp = fopen(argv[level], "r")) != 0) {
+    if ((fp = fopen(argv[level], "r")) != NULL) {
 	while ((j = fgetc(fp)) != EOF) {
 	    if (waddch(txtwin, UChar(j)) != OK) {
 		break;
@@ -155,7 +155,7 @@
 	    break;
 	case 'w':
 	    test_inchs(level + 1, argv, chrwin, strwin);
-	    if (txtbox != 0) {
+	    if (txtbox != NULL) {
 		touchwin(txtbox);
 		wnoutrefresh(txtbox);
 	    } else {
Index: test/inchs.c
Prereq:  1.20 
--- ncurses-6.5-20241130+/test/inchs.c	2024-10-06 21:17:54.000000000 +0000
+++ ncurses-6.5-20241207/test/inchs.c	2024-12-07 22:32:11.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: inchs.c,v 1.20 2024/10/06 21:17:54 tom Exp $
+ * $Id: inchs.c,v 1.21 2024/12/07 22:32:11 tom Exp $
  *
  * Author: Thomas E Dickey
  */
@@ -80,17 +80,17 @@
 	" h,j,k,l (and arrow-keys) - move viewport",
 	" w                        - recur to new window",
 	"                            for next input file",
-	0
+	NULL
     };
-    WINDOW *txtbox = 0;
-    WINDOW *txtwin = 0;
+    WINDOW *txtbox = NULL;
+    WINDOW *txtwin = NULL;
     FILE *fp;
     int ch, j;
     int txt_x = 0, txt_y = 0;
     int base_y;
     chtype text[MAX_COLS];
 
-    if (argv[level] == 0) {
+    if (argv[level] == NULL) {
 	beep();
 	return FALSE;
     }
@@ -109,7 +109,7 @@
 	txtwin = stdscr;
 	base_y = BASE_Y;
     }
-    if (txtwin == 0)
+    if (txtwin == NULL)
 	failed("cannot create txtwin");
 
     keypad(txtwin, TRUE);	/* enable keyboard mapping */
@@ -120,7 +120,7 @@
     txt_x = 0;
     wmove(txtwin, txt_y, txt_x);
 
-    if ((fp = fopen(argv[level], "r")) != 0) {
+    if ((fp = fopen(argv[level], "r")) != NULL) {
 	while ((j = fgetc(fp)) != EOF) {
 	    if (waddch(txtwin, UChar(j)) != OK) {
 		break;
@@ -165,7 +165,7 @@
 	    break;
 	case 'w':
 	    test_inchs(level + 1, argv, chrwin, strwin);
-	    if (txtbox != 0) {
+	    if (txtbox != NULL) {
 		touchwin(txtbox);
 		wnoutrefresh(txtbox);
 	    } else {
Index: test/ins_wide.c
Prereq:  1.31 
--- ncurses-6.5-20241130+/test/ins_wide.c	2024-10-05 19:26:24.000000000 +0000
+++ ncurses-6.5-20241207/test/ins_wide.c	2024-12-07 22:32:11.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: ins_wide.c,v 1.31 2024/10/05 19:26:24 tom Exp $
+ * $Id: ins_wide.c,v 1.32 2024/12/07 22:32:11 tom Exp $
  *
  * Demonstrate the wins_wstr() and wins_wch functions.
  * Thomas Dickey - 2002/11/23
@@ -225,9 +225,9 @@
     int row2, col2;
     int length;
     wchar_t buffer[BUFSIZ];
-    WINDOW *look = 0;
-    WINDOW *work = 0;
-    WINDOW *show = 0;
+    WINDOW *look = NULL;
+    WINDOW *work = NULL;
+    WINDOW *show = NULL;
     int margin = (2 * MY_TABSIZE) - 1;
     Options option = (Options) ((int) (m_opt ? oMove : oDefault)
 				| (int) ((w_opt || (level > 0))
Index: test/insdelln.c
Prereq:  1.17 
--- ncurses-6.5-20241130+/test/insdelln.c	2024-10-06 21:08:52.000000000 +0000
+++ ncurses-6.5-20241207/test/insdelln.c	2024-12-07 22:32:11.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: insdelln.c,v 1.17 2024/10/06 21:08:52 tom Exp $
+ * $Id: insdelln.c,v 1.18 2024/12/07 22:32:11 tom Exp $
  *
  * test-driver for deleteln, wdeleteln, insdelln, winsdelln, insertln, winsertln
  */
@@ -71,7 +71,7 @@
     };
     /* *INDENT-ON* */
 
-    const char *result = 0;
+    const char *result = NULL;
 
     if (has_colors()) {
 	static bool first = TRUE;
@@ -107,7 +107,7 @@
     };
     /* *INDENT-ON* */
 
-    const char *result = 0;
+    const char *result = NULL;
 
     if (state < SIZEOF(table)) {
 	*attr = table[state].attr;
@@ -144,9 +144,9 @@
     getyx(win, y, x);
     wmove(win, 0, 0);
     wprintw(win, "Count %d", sp->count);
-    if (sp->v_msg != 0)
+    if (sp->v_msg != NULL)
 	wprintw(win, " Video %s", sp->v_msg);
-    if (sp->c_msg != 0)
+    if (sp->c_msg != NULL)
 	wprintw(win, " Color %s", sp->c_msg);
     wclrtoeol(win);
     wmove(win, y, x);
@@ -165,10 +165,10 @@
     WINDOW *win1 = newwin(sp->y_max - 2, sp->x_max - 2,
 			  sp->y_beg + 1, sp->x_beg + 1);
 
-    if (win1 != 0 && sp->y_max > 4 && sp->x_max > 4) {
+    if (win1 != NULL && sp->y_max > 4 && sp->x_max > 4) {
 	WINDOW *win2 = derwin(win1, sp->y_max - 4, sp->x_max - 4, 1, 1);
 
-	if (win2 != 0) {
+	if (win2 != NULL) {
 	    box(win1, 0, 0);
 	    wrefresh(win1);
 	    func(win2);
@@ -222,7 +222,7 @@
 	,"q     quit"
 	,"=     resets count to zero."
 	,"?     shows this help-window"
-	,0
+	,NULL
     };
 
     popup_msg(win, table);
@@ -234,14 +234,14 @@
     switch (sp->ch) {
     case ' ':			/* next test-iteration */
 	if (has_colors()) {
-	    if ((sp->c_msg = color_params(++(sp->c), &(sp->pair))) == 0) {
+	    if ((sp->c_msg = color_params(++(sp->c), &(sp->pair))) == NULL) {
 		sp->c_msg = color_params(sp->c = 0, &(sp->pair));
-		if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == 0) {
+		if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == NULL) {
 		    sp->v_msg = video_params(sp->v = 0, &(sp->attr));
 		}
 	    }
 	} else {
-	    if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == 0) {
+	    if ((sp->v_msg = video_params(++(sp->v), &(sp->attr))) == NULL) {
 		sp->v_msg = video_params(sp->v = 0, &(sp->attr));
 	    }
 	}
Index: test/inserts.c
Prereq:  1.35 
--- ncurses-6.5-20241130+/test/inserts.c	2024-10-05 19:26:24.000000000 +0000
+++ ncurses-6.5-20241207/test/inserts.c	2024-12-07 22:33:32.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: inserts.c,v 1.35 2024/10/05 19:26:24 tom Exp $
+ * $Id: inserts.c,v 1.36 2024/12/07 22:33:32 tom Exp $
  *
  * Demonstrate the winsstr() and winsch functions.
  * Thomas Dickey - 2002/10/19
@@ -147,9 +147,9 @@
     int row2, col2;
     int length;
     char buffer[BUFSIZ];
-    WINDOW *look = 0;
-    WINDOW *work = 0;
-    WINDOW *show = 0;
+    WINDOW *look = NULL;
+    WINDOW *work = NULL;
+    WINDOW *show = NULL;
     int margin = (2 * MY_TABSIZE) - 1;
     Options option = (Options) ((unsigned) (m_opt
 					    ? oMove
Index: test/key_names.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/test/key_names.c	2022-12-04 00:40:11.000000000 +0000
+++ ncurses-6.5-20241207/test/key_names.c	2024-12-07 23:00:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2022 Thomas E. Dickey                                     *
+ * Copyright 2020-2022,2024 Thomas E. Dickey                                *
  * Copyright 2007-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: key_names.c,v 1.11 2022/12/04 00:40:11 tom Exp $
+ * $Id: key_names.c,v 1.12 2024/12/07 23:00:37 tom Exp $
  */
 
 #include <test.priv.h>
@@ -100,7 +100,7 @@
     for (n = -1; n < KEY_MAX + 512; n++) {
 	int check = wcwidth((wchar_t) n);
 	const char *result = check >= 0 ? key_name((wchar_t) n) : "?";
-	if (result != 0)
+	if (result != NULL)
 	    printf("%d(%5o):%s\n", n, n, result);
     }
     ExitProgram(EXIT_SUCCESS);
Index: test/keynames.c
Prereq:  1.13 
--- ncurses-6.5-20241130+/test/keynames.c	2022-12-04 00:40:11.000000000 +0000
+++ ncurses-6.5-20241207/test/keynames.c	2024-12-07 23:00:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020,2022 Thomas E. Dickey                                     *
+ * Copyright 2020-2022,2024 Thomas E. Dickey                                *
  * Copyright 1998-2006,2008 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: keynames.c,v 1.13 2022/12/04 00:40:11 tom Exp $
+ * $Id: keynames.c,v 1.14 2024/12/07 23:00:37 tom Exp $
  */
 
 #include <test.priv.h>
@@ -97,7 +97,7 @@
 
     for (n = -1; n < KEY_MAX + 512; n++) {
 	const char *result = keyname(n);
-	if (result != 0)
+	if (result != NULL)
 	    printf("%d(%5o):%s\n", n, n, result);
     }
     ExitProgram(EXIT_SUCCESS);
Index: test/linedata.h
Prereq:  1.8 
--- ncurses-6.5-20241130+/test/linedata.h	2020-02-02 23:34:34.000000000 +0000
+++ ncurses-6.5-20241207/test/linedata.h	2024-12-07 23:00:37.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018,2020 Thomas E. Dickey                                     *
+ * Copyright 2018-2020,2024 Thomas E. Dickey                                *
  * Copyright 2009-2010,2012 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -28,7 +28,7 @@
  ****************************************************************************/
 
 /*
- * $Id: linedata.h,v 1.8 2020/02/02 23:34:34 tom Exp $
+ * $Id: linedata.h,v 1.9 2024/12/07 23:00:37 tom Exp $
  *
  * Utility functions for reading a line of text from a file.
  */
@@ -55,7 +55,7 @@
 static void
 init_linedata(const char *name)
 {
-    if ((linedata = fopen(name, "r")) == 0) {
+    if ((linedata = fopen(name, "r")) == NULL) {
 	failed(name);
     }
 }
@@ -64,11 +64,11 @@
 read_linedata(WINDOW *work)
 {
     int result;
-    if (linedata != 0) {
+    if (linedata != NULL) {
 	result = fgetc(linedata);
 	if (result == EOF) {
 	    fclose(linedata);
-	    linedata = 0;
+	    linedata = NULL;
 	    result = read_linedata(work);
 	} else {
 	    wrefresh(work);
Index: test/list_keys.c
Prereq:  1.36 
--- ncurses-6.5-20241130+/test/list_keys.c	2024-11-30 18:07:01.000000000 +0000
+++ ncurses-6.5-20241207/test/list_keys.c	2024-12-07 22:33:32.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: list_keys.c,v 1.36 2024/11/30 18:07:01 tom Exp $
+ * $Id: list_keys.c,v 1.37 2024/12/07 22:33:32 tom Exp $
  *
  * Author: Thomas E Dickey
  *
@@ -86,7 +86,7 @@
 {
     const char *result = name;
     int n;
-    for (n = 0; strnames[n] != 0; ++n) {
+    for (n = 0; strnames[n] != NULL; ++n) {
 	if (!strcmp(name, strnames[n])) {
 	    result = strfnames[n];
 	    break;
@@ -104,7 +104,7 @@
     if (show && t_opt)
 	fputc('"', stdout);
 
-    if (value != 0 && value != (char *) -1) {
+    if (value != NULL && value != (char *) -1) {
 	while (*value != 0) {
 	    char buffer[10];
 	    int ch = UChar(*value++);
@@ -356,7 +356,7 @@
 	if (widths2 < check)
 	    widths2 = check;
     }
-    for (j = 0; Name(j) != 0; ++j) {
+    for (j = 0; Name(j) != NULL; ++j) {
 	if (valid_key(Name(j), terms, count)) {
 	    const char *label = f_opt ? full_name(Name(j)) : Name(j);
 	    check = (int) strlen(label);
@@ -399,7 +399,7 @@
 
     widthsx = widths0 + ((count + 1) * widths2);
 
-    for (j = 0; Name(j) != 0; ++j) {
+    for (j = 0; Name(j) != NULL; ++j) {
 	if (j == 0 || (Type(j) != Type(j - 1)))
 	    draw_line(widthsx);
 	if (valid_key(Name(j), terms, count)) {
@@ -498,7 +498,7 @@
 	int n;
 	for (n = optind; n < argc; ++n) {
 	    setupterm((NCURSES_CONST char *) argv[n], 1, &status);
-	    if (status > 0 && cur_term != 0) {
+	    if (status > 0 && cur_term != NULL) {
 		terms[found++] = cur_term;
 	    }
 	}
Index: test/move_field.c
Prereq:  1.19 
--- ncurses-6.5-20241130+/test/move_field.c	2024-10-06 21:12:35.000000000 +0000
+++ ncurses-6.5-20241207/test/move_field.c	2024-12-07 22:33:32.000000000 +0000
@@ -26,7 +26,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: move_field.c,v 1.19 2024/10/06 21:12:35 tom Exp $
+ * $Id: move_field.c,v 1.20 2024/12/07 22:33:32 tom Exp $
  *
  * Demonstrate move_field().
  */
@@ -91,7 +91,7 @@
 	const char *code = keyname(commands[n].code);
 	size_t need = 5;
 #ifdef NCURSES_VERSION
-	if ((name = form_request_name(commands[n].result)) == 0)
+	if ((name = form_request_name(commands[n].result)) == NULL)
 #endif
 	    name = commands[n].help;
 	need = 5 + strlen(code) + strlen(name);
@@ -101,9 +101,9 @@
     }
     msgs[used++] =
 	strdup("Arrow keys move within a field as you would expect.");
-    msgs[used] = 0;
+    msgs[used] = NULL;
     popup_msg2(stdscr, msgs);
-    for (n = 0; msgs[n] != 0; ++n) {
+    for (n = 0; msgs[n] != NULL; ++n) {
 	free(msgs[n]);
     }
     free(msgs);
@@ -444,7 +444,7 @@
 
     all_fields[n] = (FIELD *) 0;
 
-    if ((form = new_form(all_fields)) != 0) {
+    if ((form = new_form(all_fields)) != NULL) {
 	int finished = 0;
 
 	post_form(form);
@@ -466,7 +466,7 @@
 
 	free_form(form);
     }
-    for (c = 0; all_fields[c] != 0; c++) {
+    for (c = 0; all_fields[c] != NULL; c++) {
 	free_edit_field(all_fields[c]);
 	free_field(all_fields[c]);
     }
Index: test/movewindow.c
Prereq:  1.56 
--- ncurses-6.5-20241130+/test/movewindow.c	2024-10-06 18:44:26.000000000 +0000
+++ ncurses-6.5-20241207/test/movewindow.c	2024-12-07 22:33:32.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: movewindow.c,v 1.56 2024/10/06 18:44:26 tom Exp $
+ * $Id: movewindow.c,v 1.57 2024/12/07 22:33:32 tom Exp $
  *
  * Demonstrate move functions for windows and derived windows from the curses
  * library.
@@ -149,7 +149,7 @@
     res.y = uli;
     res.x = ulj;
 
-    if (child != 0) {
+    if (child != NULL) {
 	if (relative) {
 	    getparyx(child, i, j);
 	} else {
@@ -256,20 +256,20 @@
     bool result = FALSE;
 
     head_line("Use arrows to move cursor, anything else to mark corner 1");
-    if ((tmp = selectcell(parent, 0,
+    if ((tmp = selectcell(parent, NULL,
 			  min_line, min_col,
 			  max_line, max_col,
 			  FALSE,
-			  (bool *) 0)) != 0) {
+			  (bool *) 0)) != NULL) {
 	*ul = *tmp;
 	MvWAddCh(parent, ul->y, ul->x, '*');
 
 	head_line("Use arrows to move cursor, anything else to mark corner 2");
-	if ((tmp = selectcell(parent, 0,
+	if ((tmp = selectcell(parent, NULL,
 			      ul->y, ul->x,
 			      max_line, max_col,
 			      FALSE,
-			      (bool *) 0)) != 0) {
+			      (bool *) 0)) != NULL) {
 	    *lr = *tmp;
 	    MvWAddCh(parent, lr->y, lr->x, '*');
 	    wmove(parent, lr->y, lr->x);
@@ -348,7 +348,7 @@
 static WINDOW *
 parent_of(NCURSES_CONST WINDOW *win)
 {
-    WINDOW *result = 0;
+    WINDOW *result = NULL;
     int n = window2num(win);
     if (n >= 0)
 	result = all_windows[n].parent;
@@ -429,7 +429,7 @@
     WINDOW *parent = parent_of(win);
     bool result = FALSE;
 
-    if (parent != 0) {
+    if (parent != NULL) {
 	bool top = (parent == stdscr);
 	int min_col = top ? COL_MIN : 0;
 	int max_col = top ? COL_MAX : getmaxx(parent);
@@ -445,7 +445,7 @@
 				 min_line, min_col,
 				 max_line, max_col,
 				 FALSE,
-				 &more)) != 0) {
+				 &more)) != NULL) {
 	    int y0, x0;
 	    getbegyx(parent, y0, x0);
 	    /*
@@ -494,7 +494,7 @@
     WINDOW *parent = parent_of(win);
     bool result = FALSE;
 
-    if (parent != 0) {
+    if (parent != NULL) {
 	bool top = (parent == stdscr);
 	int min_col = top ? COL_MIN : 0;
 	int max_col = top ? COL_MAX : getmaxx(parent);
@@ -509,7 +509,7 @@
 				 min_line, min_col,
 				 max_line, max_col,
 				 TRUE,
-				 &more)) != 0) {
+				 &more)) != NULL) {
 	    if (mvderwin(win, tmp->y, tmp->x) != ERR) {
 		refresh_all(win);
 		doupdate();
@@ -577,16 +577,16 @@
 create_my_window(WINDOW *current)
 {
     PAIR ul, lr;
-    WINDOW *result = 0;
+    WINDOW *result = NULL;
 
     if (getwindow(stdscr, &ul, &lr)) {
 	result = newwin(lines_of(ul, lr), cols_of(ul, lr), pair_of(ul));
-	if (result != 0) {
+	if (result != NULL) {
 	    fill_window(result, 'c');
 	    add_window(stdscr, result);
 	}
     }
-    if (result == 0)
+    if (result == NULL)
 	result = current;
     return result;
 }
@@ -595,16 +595,16 @@
 create_my_derwin(WINDOW *parent)
 {
     PAIR ul, lr;
-    WINDOW *result = 0;
+    WINDOW *result = NULL;
 
     if (getwindow(parent, &ul, &lr)) {
 	result = derwin(parent, lines_of(ul, lr), cols_of(ul, lr), pair_of(ul));
-	if (result != 0) {
+	if (result != NULL) {
 	    fill_window(result, 'd');
 	    add_window(parent, result);
 	}
     }
-    if (result == 0)
+    if (result == NULL)
 	result = parent;
     return result;
 }
@@ -613,7 +613,7 @@
 create_my_subwin(WINDOW *parent)
 {
     PAIR ul, lr;
-    WINDOW *result = 0;
+    WINDOW *result = NULL;
 
     if (getwindow(parent, &ul, &lr)) {
 	result = subwin(parent,
@@ -621,12 +621,12 @@
 			cols_of(ul, lr),
 			ul.y + getbegy(parent),
 			ul.x + getbegx(parent));
-	if (result != 0) {
+	if (result != NULL) {
 	    fill_window(result, 's');
 	    add_window(parent, result);
 	}
     }
-    if (result == 0)
+    if (result == NULL)
 	result = parent;
     return result;
 }
@@ -718,7 +718,7 @@
     nonl();
     intrflush(stdscr, FALSE);
 
-    add_window(0, current_win = stdscr);
+    add_window(NULL, current_win = stdscr);
 
 #ifdef NCURSES_MOUSE_VERSION
     (void) mousemask(BUTTON1_CLICKED, (mmask_t *) NULL);
Index: test/ncurses.c
Prereq:  1.544 
--- ncurses-6.5-20241130+/test/ncurses.c	2024-11-30 18:54:06.000000000 +0000
+++ ncurses-6.5-20241207/test/ncurses.c	2024-12-07 23:22:39.000000000 +0000
@@ -41,7 +41,7 @@
    Author: Eric S. Raymond <esr@snark.thyrsus.com> 1993
            Thomas E. Dickey (beginning revision 1.27 in 1996).
 
-$Id: ncurses.c,v 1.544 2024/11/30 18:54:06 tom Exp $
+$Id: ncurses.c,v 1.545 2024/12/07 23:22:39 tom Exp $
 
 ***************************************************************************/
 
@@ -121,23 +121,23 @@
 #endif
 
 #if HAVE_WCSRTOMBS
-#define count_wchars(src, len, state)      wcsrtombs(0,   &src, len, state)
-#define trans_wchars(dst, src, len, state) wcsrtombs(dst, &src, len, state)
+#define count_wchars(src, len, state)      wcsrtombs(NULL, &src, len, state)
+#define trans_wchars(dst, src, len, state) wcsrtombs(dst,  &src, len, state)
 #define reset_wchars(state) init_mb(state)
 #elif HAVE_WCSTOMBS && HAVE_MBTOWC && HAVE_MBLEN
-#define count_wchars(src, len, state)      wcstombs(0,   src, len)
-#define trans_wchars(dst, src, len, state) wcstombs(dst, src, len)
+#define count_wchars(src, len, state)      wcstombs(NULL, src, len)
+#define trans_wchars(dst, src, len, state) wcstombs(dst,  src, len)
 #define reset_wchars(state) IGNORE_RC(mblen(NULL, 0)), IGNORE_RC(mbtowc(NULL, NULL, 0))
 #define state_unused
 #endif
 
 #if HAVE_MBSRTOWCS
-#define count_mbytes(src, len, state)      mbsrtowcs(0,   &src, len, state)
-#define trans_mbytes(dst, src, len, state) mbsrtowcs(dst, &src, len, state)
+#define count_mbytes(src, len, state)      mbsrtowcs(NULL, &src, len, state)
+#define trans_mbytes(dst, src, len, state) mbsrtowcs(dst,  &src, len, state)
 #define reset_mbytes(state) init_mb(state)
 #elif HAVE_MBSTOWCS && HAVE_MBTOWC && HAVE_MBLEN
-#define count_mbytes(src, len, state)      mbstowcs(0,   src, len)
-#define trans_mbytes(dst, src, len, state) mbstowcs(dst, src, len)
+#define count_mbytes(src, len, state)      mbstowcs(NULL, src, len)
+#define trans_mbytes(dst, src, len, state) mbstowcs(dst,  src, len)
 #define reset_mbytes(state) IGNORE_RC(mblen(NULL, 0)), IGNORE_RC(mbtowc(NULL, NULL, 0))
 #define state_unused
 #endif
@@ -328,7 +328,7 @@
 
     source[0] = fullwidth_digit(digit + '0');
     source[1] = 0;
-    setcchar(target, source, A_NORMAL, 0, 0);
+    setcchar(target, source, A_NORMAL, 0, NULL);
 }
 #endif
 
@@ -683,7 +683,7 @@
 	const char *msg = help[n];
 	int row = 1 + (int) (n % chk);
 	int col = (n >= chk) ? COLS / 2 : 0;
-	int flg = ((strstr(msg, "toggle") != 0)
+	int flg = ((strstr(msg, "toggle") != NULL)
 		   && (flags[UChar(*msg)] != FALSE));
 	if (*msg == '^' && ExitOnEscape())
 	    msg = "^[,^q -- quit";
@@ -717,16 +717,16 @@
     WINDOW *frame;
 } WINSTACK;
 
-static WINSTACK *winstack = 0;
+static WINSTACK *winstack = NULL;
 static unsigned len_winstack = 0;
 
 static void
 forget_boxes(void)
 {
-    if (winstack != 0) {
+    if (winstack != NULL) {
 	free(winstack);
     }
-    winstack = 0;
+    winstack = NULL;
     len_winstack = 0;
 }
 
@@ -737,7 +737,7 @@
 
     assert(level < (unsigned) COLS);
 
-    if (winstack == 0) {
+    if (winstack == NULL) {
 	len_winstack = 20;
 	winstack = typeMalloc(WINSTACK, len_winstack);
     } else if (need >= len_winstack) {
@@ -1030,7 +1030,7 @@
 	high -= 2;
 	wide -= 2;
 	werase(winstack[n].text);
-	box_set(winstack[n].frame, 0, 0);
+	box_set(winstack[n].frame, NULL, NULL);
 	wnoutrefresh(winstack[n].frame);
 	wprintw(winstack[n].text,
 		"size %dx%d\n",
@@ -1048,7 +1048,7 @@
 wcstos(const wchar_t *src)
 {
     int need;
-    char *result = 0;
+    char *result = NULL;
     const wchar_t *tmp = src;
 #ifndef state_unused
     mbstate_t state;
@@ -1057,11 +1057,11 @@
     reset_wchars(state);
     if ((need = (int) count_wchars(tmp, 0, &state)) > 0) {
 	unsigned have = (unsigned) need;
-	if ((result = typeCalloc(char, have + 1)) != 0) {
+	if ((result = typeCalloc(char, have + 1)) != NULL) {
 	    tmp = src;
 	    if (trans_wchars(result, tmp, have, &state) != have) {
 		free(result);
-		result = 0;
+		result = NULL;
 	    }
 	} else {
 	    failed("wcstos");
@@ -1124,7 +1124,7 @@
 		for (n = 0; (wchar_buf[n] = (wchar_t) wint_buf[n]) != 0; ++n) {
 		    ;
 		}
-		if ((temp = wcstos(wchar_buf)) != 0) {
+		if ((temp = wcstos(wchar_buf)) != NULL) {
 		    wprintw(win, "I saw %d characters:\n\t`%s'.",
 			    (int) wcslen(wchar_buf), temp);
 		    free(temp);
@@ -1161,7 +1161,7 @@
 		WINDOW *wb = newwin(high, wide, new_y, new_x);
 		WINDOW *wi = newwin(high - 2, wide - 2, new_y + 1, new_x + 1);
 
-		box_set(wb, 0, 0);
+		box_set(wb, NULL, NULL);
 		wrefresh(wb);
 		wmove(wi, 0, 0);
 		remember_boxes(level, wi, wb);
@@ -1614,7 +1614,7 @@
 		Repaint();
 		break;
 	    case HELP_KEY_1:
-		if ((helpwin = newwin(LINES - 1, COLS - 2, 0, 0)) != 0) {
+		if ((helpwin = newwin(LINES - 1, COLS - 2, 0, 0)) != NULL) {
 		    box(helpwin, 0, 0);
 		    attr_legend(helpwin);
 		    wGetchar(helpwin);
@@ -1837,7 +1837,7 @@
 
     blank[0] = ' ';
     blank[1] = 0;
-    setcchar(&normal, blank, A_NORMAL, pair, 0);
+    setcchar(&normal, blank, A_NORMAL, pair, NULL);
     bkgrnd(&normal);
     bkgrndset(&normal);
 }
@@ -1854,7 +1854,7 @@
     if (getbkgrnd(&ch) != ERR) {
 	wchar_t wch[CCHARW_MAX];
 
-	if (getcchar(&ch, wch, &attr, &pair, 0) != ERR) {
+	if (getcchar(&ch, wch, &attr, &pair, NULL) != ERR) {
 	    result = attr;
 	}
     }
@@ -1895,17 +1895,17 @@
 	    wchar_t fill[2];
 	    fill[0] = *s;
 	    fill[1] = L'\0';
-	    setcchar(&ch, fill, attr, pair, 0);
+	    setcchar(&ch, fill, attr, pair, NULL);
 	    (void) wadd_wch(win, &ch);
 	}
     } else {
 	attr_t old_attr = 0;
 	NCURSES_PAIRS_T old_pair = 0;
 
-	(void) (wattr_get) (win, &old_attr, &old_pair, 0);
-	(void) wattr_set(win, attr, pair, 0);
+	(void) (wattr_get) (win, &old_attr, &old_pair, NULL);
+	(void) wattr_set(win, attr, pair, NULL);
 	(void) waddwstr(win, wide_attr_test_string);
-	(void) wattr_set(win, old_attr, old_pair, 0);
+	(void) wattr_set(win, old_attr, old_pair, NULL);
     }
     if (skip)
 	printw("%*s", skip, " ");
@@ -1969,8 +1969,8 @@
 		Repaint();
 		break;
 	    case HELP_KEY_1:
-		if ((helpwin = newwin(LINES - 1, COLS - 2, 0, 0)) != 0) {
-		    box_set(helpwin, 0, 0);
+		if ((helpwin = newwin(LINES - 1, COLS - 2, 0, 0)) != NULL) {
+		    box_set(helpwin, NULL, NULL);
 		    attr_legend(helpwin);
 		    wGetchar(helpwin);
 		    delwin(helpwin);
@@ -2074,7 +2074,7 @@
 	    set_wide_background(pair);
 	    erase();
 
-	    box_set(stdscr, 0, 0);
+	    box_set(stdscr, NULL, NULL);
 	    MvAddStr(0, 20, "Character attribute test display");
 
 	    for (j = 0; j < my_size; ++j) {
@@ -2258,7 +2258,7 @@
     int col_limit;
     int row_limit;
     int per_row;
-    char *numbered = 0;
+    char *numbered = NULL;
     const char *hello;
     bool done = FALSE;
     bool opt_acsc = FALSE;
@@ -2275,7 +2275,7 @@
     }
 
     numbered = typeCalloc(char, COLS + 1);
-    done = ((COLS < 16) || (numbered == 0));
+    done = ((COLS < 16) || (numbered == NULL));
 
     /*
      * Because the number of colors is usually a power of two, we also use
@@ -2481,7 +2481,7 @@
 	    }
 	    break;
 	case HELP_KEY_1:
-	    if ((helpwin = newwin(LINES - 1, COLS - 2, 0, 0)) != 0) {
+	    if ((helpwin = newwin(LINES - 1, COLS - 2, 0, 0)) != NULL) {
 		box(helpwin, 0, 0);
 		color_legend(helpwin, FALSE);
 		wGetchar(helpwin);
@@ -2527,7 +2527,7 @@
     int col_limit;
     int row_limit;
     int per_row;
-    char *numbered = 0;
+    char *numbered = NULL;
     const char *hello;
     bool done = FALSE;
     bool opt_acsc = FALSE;
@@ -2537,7 +2537,7 @@
     bool opt_nums = FALSE;
     bool opt_xchr = FALSE;
     int opt_zoom = 0;
-    wchar_t *buffer = 0;
+    wchar_t *buffer = NULL;
     WINDOW *helpwin;
 
     if (!UseColors) {
@@ -2546,7 +2546,7 @@
     }
     numbered = typeCalloc(char, COLS + 1);
     buffer = typeCalloc(wchar_t, COLS + 1);
-    done = ((COLS < 16) || (numbered == 0) || (buffer == 0));
+    done = ((COLS < 16) || (numbered == NULL) || (buffer == NULL));
 
     /*
      * Because the number of colors is usually a power of two, we also use
@@ -2765,7 +2765,7 @@
 	    }
 	    break;
 	case HELP_KEY_1:
-	    if ((helpwin = newwin(LINES - 1, COLS - 2, 0, 0)) != 0) {
+	    if ((helpwin = newwin(LINES - 1, COLS - 2, 0, 0)) != NULL) {
 		box(helpwin, 0, 0);
 		color_legend(helpwin, TRUE);
 		wGetchar(helpwin);
@@ -2875,14 +2875,14 @@
 	}
 	reset_prog_mode();
     }
-    if (palette_file != 0) {
+    if (palette_file != NULL) {
 	FILE *fp = fopen(palette_file, "r");
-	if (fp != 0) {
+	if (fp != NULL) {
 	    char buffer[BUFSIZ];
 	    int red, green, blue;
 	    int scale = 1000;
 	    int c;
-	    while (fgets(buffer, sizeof(buffer), fp) != 0) {
+	    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
 		if (sscanf(buffer, "scale:%d", &c) == 1) {
 		    scale = c;
 		    if (scale < 100)
@@ -3387,7 +3387,7 @@
 	case '8':
 	    MvAddStr(SLK_WORK, 0, "Please enter the label value: ");
 	    _nc_STRCPY(buf, "", sizeof(buf));
-	    if ((s = slk_label(c - '0')) != 0) {
+	    if ((s = slk_label(c - '0')) != NULL) {
 		_nc_STRNCPY(buf, s, (size_t) 8);
 	    }
 	    wGetstring(stdscr, buf, 8);
@@ -3508,7 +3508,7 @@
 	case '8':
 	    MvAddStr(SLK_WORK, 0, "Please enter the label value: ");
 	    *buf = 0;
-	    if ((s = slk_label(c - '0')) != 0) {
+	    if ((s = slk_label(c - '0')) != NULL) {
 		char *temp = strdup(s);
 		size_t used = strlen(temp);
 		size_t want = SLKLEN;
@@ -3821,7 +3821,7 @@
     int c = 'a';
     int pagesize = 32;
     char *term = getenv("TERM");
-    const char *pch_kludge = ((term != 0 && strstr(term, "linux"))
+    const char *pch_kludge = ((term != NULL && strstr(term, "linux"))
 			      ? "p=PC, "
 			      : "");
     attr_t attr = A_NORMAL;
@@ -3831,7 +3831,7 @@
     int bg = COLOR_BLACK;
     unsigned at_code = 0;
     NCURSES_PAIRS_T pair = 0;
-    void (*last_show_acs) (int, attr_t, NCURSES_PAIRS_T) = 0;
+    void (*last_show_acs) (int, attr_t, NCURSES_PAIRS_T) = NULL;
     ATTR_TBL my_list[SIZEOF(attrs_to_test)];
     unsigned my_size = init_attr_list(my_list, termattrs());
 
@@ -3864,12 +3864,12 @@
 	case '2':
 	case '3':
 	    digit = (c - '0');
-	    last_show_acs = 0;
+	    last_show_acs = NULL;
 	    break;
 	case '-':
 	    if (digit > 0) {
 		--digit;
-		last_show_acs = 0;
+		last_show_acs = NULL;
 	    } else {
 		beep();
 	    }
@@ -3877,7 +3877,7 @@
 	case '+':
 	    if (digit < 3) {
 		++digit;
-		last_show_acs = 0;
+		last_show_acs = NULL;
 	    } else {
 		beep();
 	    }
@@ -3901,7 +3901,7 @@
 	}
 	if (pagesize != 32) {
 	    show_256_chars(repeat, attr, pair);
-	} else if (last_show_acs != 0) {
+	} else if (last_show_acs != NULL) {
 	    last_show_acs(repeat, attr, pair);
 	} else {
 	    show_upper_chars(digit * pagesize + 128, pagesize, repeat, attr, pair);
@@ -3941,8 +3941,8 @@
 	TEST_CCHAR(src, {
 	    attr |= (test_attrs & A_ALTCHARSET);
 	    setcchar(dst, test_wch, attr, pair, NULL);
-	}, {
-	    ;
+	}
+	, {;
 	});
     } while (0);
     return dst;
@@ -3981,7 +3981,7 @@
 
 	memset(&codes, 0, sizeof(codes));
 	codes[0] = code;
-	setcchar(&temp, codes, attr, pair, 0);
+	setcchar(&temp, codes, attr, pair, NULL);
 	move(row, col);
 	if (wcwidth(code) == 0 && code != 0) {
 	    AddCh((chtype) space |
@@ -4020,7 +4020,7 @@
 
 	memset(&codes, 0, sizeof(codes));
 	codes[0] = code;
-	setcchar(&temp, codes, attr, pair, 0);
+	setcchar(&temp, codes, attr, pair, NULL);
 
 	do {
 	    int y, x;
@@ -4298,10 +4298,10 @@
     char temp[80];
 
     MvPrintw(row, col, "%*s : ", COLS / 4, name);
-    (void) attr_set(attr, pair, 0);
+    (void) attr_set(attr, pair, NULL);
     _nc_STRNCPY(temp, code, 20);
     addstr(temp);
-    (void) attr_set(A_NORMAL, 0, 0);
+    (void) attr_set(A_NORMAL, 0, NULL);
     return n + 1;
 }
 
@@ -4373,7 +4373,7 @@
     int bg = COLOR_BLACK;
     unsigned at_code = 0;
     NCURSES_PAIRS_T pair = 0;
-    void (*last_show_wacs) (int, attr_t, NCURSES_PAIRS_T) = 0;
+    void (*last_show_wacs) (int, attr_t, NCURSES_PAIRS_T) = NULL;
     W_ATTR_TBL my_list[SIZEOF(w_attrs_to_test)];
     unsigned my_size = init_w_attr_list(my_list, term_attrs());
     char at_page[20];
@@ -4436,26 +4436,26 @@
 		    at_page[--len] = '\0';
 	    } else if (c < 256 && isdigit(c)) {
 		digit = (unsigned) (c - '0');
-		last_show_wacs = 0;
+		last_show_wacs = NULL;
 	    } else if (c == '+') {
 		++digit;
 		_nc_SPRINTF(at_page, _nc_SLIMIT(sizeof(at_page)) "%02x", digit);
-		last_show_wacs = 0;
+		last_show_wacs = NULL;
 	    } else if (c == '-' && digit > 0) {
 		--digit;
 		_nc_SPRINTF(at_page, _nc_SLIMIT(sizeof(at_page)) "%02x",
 			    UChar(digit));
-		last_show_wacs = 0;
+		last_show_wacs = NULL;
 	    } else if (c == '>' && repeat < (COLS / 4)) {
 		++repeat;
 	    } else if (c == '<' && repeat > 1) {
 		--repeat;
 	    } else if (c == '_') {
 		space = (space == ' ') ? '_' : ' ';
-		last_show_wacs = 0;
+		last_show_wacs = NULL;
 	    } else if (cycle_w_attr(c, &at_code, &attr, my_list, my_size)
 		       || cycle_colors(c, &fg, &bg, &pair)) {
-		if (last_show_wacs != 0)
+		if (last_show_wacs != NULL)
 		    break;
 	    } else {
 		beep();
@@ -4465,7 +4465,7 @@
 	}
 	if (pagesize != 32) {
 	    show_paged_widechars(digit, pagesize, repeat, space, attr, pair);
-	} else if (last_show_wacs != 0) {
+	} else if (last_show_wacs != NULL) {
 	    last_show_wacs(repeat, attr, pair);
 	} else {
 	    show_upper_widechars(digit * 32 + 128, repeat, space, attr, pair);
@@ -4615,7 +4615,7 @@
 static WINDOW *
 frame_win(FRAME * curp)
 {
-    return (curp != 0) ? curp->wind : stdscr;
+    return (curp != NULL) ? curp->wind : stdscr;
 }
 
 /* We need to know if these flags are actually set, so don't look in FRAME.
@@ -4834,7 +4834,7 @@
     outerbox(ul, lr, TRUE);
     refresh();
 
-    if (rwindow != 0)
+    if (rwindow != NULL)
 	wrefresh(rwindow);
 
     move(0, 0);
@@ -4865,9 +4865,9 @@
 static FRAME *
 delete_framed(FRAME * fp, bool showit)
 {
-    FRAME *np = 0;
+    FRAME *np = NULL;
 
-    if (fp != 0) {
+    if (fp != NULL) {
 	fp->last->next = fp->next;
 	fp->next->last = fp->last;
 
@@ -4905,7 +4905,7 @@
 	transient((FRAME *) 0, (char *) 0);
 	switch (c) {
 	case CTRL('C'):
-	    if ((neww = typeCalloc(FRAME, (size_t) 1)) == 0) {
+	    if ((neww = typeCalloc(FRAME, (size_t) 1)) == NULL) {
 		failed("scroll_test");
 		goto breakout;
 	    }
@@ -4915,7 +4915,7 @@
 		goto breakout;
 	    }
 
-	    if (current == 0) {	/* First element,  */
+	    if (current == NULL) {	/* First element,  */
 		neww->next = neww;	/*   so point it at itself */
 		neww->last = neww;
 	    } else {
@@ -4970,7 +4970,7 @@
 
 #if HAVE_PUTWIN && HAVE_GETWIN
 	case CTRL('W'):	/* save and delete window */
-	    if ((current != 0) && (current == current->next)) {
+	    if ((current != NULL) && (current == current->next)) {
 		transient(current, "Will not save/delete ONLY window");
 		break;
 	    } else if ((fp = fopen(DUMPFILE, "w")) == (FILE *) 0) {
@@ -4991,13 +4991,13 @@
 	    if ((fp = fopen(DUMPFILE, "r")) == (FILE *) 0) {
 		transient(current, "Can't open screen dump file");
 	    } else {
-		if ((neww = typeCalloc(FRAME, (size_t) 1)) != 0) {
+		if ((neww = typeCalloc(FRAME, (size_t) 1)) != NULL) {
 
-		    neww->next = current ? current->next : 0;
+		    neww->next = current ? current->next : NULL;
 		    neww->last = current;
-		    if (neww->last != 0)
+		    if (neww->last != NULL)
 			neww->last->next = neww;
-		    if (neww->next != 0)
+		    if (neww->next != NULL)
 			neww->next->last = neww;
 
 		    neww->wind = getwin(fp);
@@ -5119,7 +5119,7 @@
 	 && (c != ERR));
 
   breakout:
-    while (current != 0)
+    while (current != NULL)
 	current = delete_framed(current, FALSE);
 
     scrollok(stdscr, TRUE);	/* reset to driver's default */
@@ -5180,7 +5180,7 @@
 {
     wmove(stdscr, LINES - 1, 0);
     wclrtoeol(stdscr);
-    if (text != 0 && *text != '\0') {
+    if (text != NULL && *text != '\0') {
 	waddstr(stdscr, text);
 	waddstr(stdscr, "; ");
     }
@@ -5194,10 +5194,10 @@
 mkpanel(NCURSES_COLOR_T color, int rows, int cols, int tly, int tlx)
 {
     WINDOW *win;
-    PANEL *pan = 0;
+    PANEL *pan = NULL;
 
-    if ((win = newwin(rows, cols, tly, tlx)) != 0) {
-	if ((pan = new_panel(win)) == 0) {
+    if ((win = newwin(rows, cols, tly, tlx)) != NULL) {
+	if ((pan = new_panel(win)) == NULL) {
 	    delwin(win);
 	} else if (UseColors) {
 	    NCURSES_COLOR_T fg = (NCURSES_COLOR_T) ((color == COLOR_BLUE)
@@ -5337,7 +5337,8 @@
 }
 
 static int
-demo_panels(void (*InitPanel) (WINDOW *), void (*FillPanel) (NCURSES_CONST PANEL *))
+demo_panels(void (*InitPanel) (WINDOW *),
+	    void (*FillPanel) (NCURSES_CONST PANEL *))
 {
     int count;
     int itmp;
@@ -5927,7 +5928,7 @@
 {
     WINDOW *panpad = newpad(PAD_HIGH, PAD_WIDE);
 
-    if (panpad == 0) {
+    if (panpad == NULL) {
 	Cannot("cannot create requested pad");
 	return ERR;
     }
@@ -5990,7 +5991,7 @@
     getbegyx(win, by, bx);
     sw = w / 3;
     sh = h / 3;
-    if ((subWin = subwin(win, sh, sw, by + h - sh - 2, bx + w - sw - 2)) == 0)
+    if ((subWin = subwin(win, sh, sw, by + h - sh - 2, bx + w - sw - 2)) == NULL)
 	return ERR;
 
 #ifdef A_COLOR
@@ -6138,7 +6139,7 @@
     refresh();
 
     for (ap = animals; *ap; ap++) {
-	if ((*ip = new_item(*ap, "")) != 0)
+	if ((*ip = new_item(*ap, "")) != NULL)
 	    ++ip;
     }
     *ip = (ITEM *) 0;
@@ -6216,8 +6217,8 @@
     static size_t need = 12;
     int n;
 
-    if (buf == 0) {
-	for (n = 0; t_tbl[n].name != 0; n++)
+    if (buf == NULL) {
+	for (n = 0; t_tbl[n].name != NULL; n++)
 	    need += strlen(t_tbl[n].name) + 2;
 	buf = typeMalloc(char, need);
 	if (!buf)
@@ -6228,7 +6229,7 @@
 	_nc_STRCAT(buf, t_tbl[0].name ? t_tbl[0].name : "", need);
 	_nc_STRCAT(buf, ", ", need);
     } else {
-	for (n = 1; t_tbl[n].name != 0; n++)
+	for (n = 1; t_tbl[n].name != NULL; n++)
 	    if ((tlevel & t_tbl[n].mask) == t_tbl[n].mask) {
 		_nc_STRCAT(buf, t_tbl[n].name, need);
 		_nc_STRCAT(buf, ", ", need);
@@ -6260,14 +6261,14 @@
 	    i = current_item(m);
 	    if (i == items[0]) {
 		if (item_value(i)) {
-		    for (p = items + 1; *p != 0; p++)
+		    for (p = items + 1; *p != NULL; p++)
 			if (item_value(*p)) {
 			    set_item_value(*p, FALSE);
 			    changed = TRUE;
 			}
 		}
 	    } else {
-		for (p = items + 1; *p != 0; p++)
+		for (p = items + 1; *p != NULL; p++)
 		    if (item_value(*p)) {
 			set_item_value(items[0], FALSE);
 			changed = TRUE;
@@ -6300,8 +6301,8 @@
 
     refresh();
 
-    for (n = 0; t_tbl[n].name != 0; n++) {
-	if ((*ip = new_item(t_tbl[n].name, "")) != 0) {
+    for (n = 0; t_tbl[n].name != NULL; n++) {
+	if ((*ip = new_item(t_tbl[n].name, "")) != NULL) {
 	    ++ip;
 	}
     }
@@ -6431,7 +6432,7 @@
 	size_t need = 80 + have;
 	char *temp = malloc(need);
 
-	if (temp != 0) {
+	if (temp != NULL) {
 	    size_t len;
 	    _nc_STRNCPY(temp, source ? source : "", have + 1);
 	    len = (size_t) (char *) field_userptr(me);
@@ -6735,7 +6736,7 @@
     set_field_type(f[n - 1], fty_passwd);
     f[n] = (FIELD *) 0;
 
-    if ((form = new_form(f)) != 0) {
+    if ((form = new_form(f)) != NULL) {
 	WINDOW *w;
 	int finished = 0;
 
@@ -6764,7 +6765,7 @@
 
 	free_form(form);
     }
-    for (c = 0; f[c] != 0; c++)
+    for (c = 0; f[c] != NULL; c++)
 	free_field(f[c]);
     free_fieldtype(fty_middle);
     free_fieldtype(fty_passwd);
@@ -6798,7 +6799,7 @@
     getmaxyx(stdscr, y, x);
     if (y < 23 || x < 80) {
 	Cannot("The screen is too small for this test");
-	result = 0;
+	result = NULL;
     } else {
 	int ymax = y - (overlap_HEAD + overlap_FOOT);
 	int high = ymax / 5;	/* equal-sized parts for cross */
@@ -7206,9 +7207,9 @@
     int shift = 0, last_refresh = -1;
     int state, flavor[OVERLAP_FLAVORS];
 
-    if ((win1 = make_overlap(0)) == 0) {
+    if ((win1 = make_overlap(0)) == NULL) {
 	return ERR;
-    } else if ((win2 = make_overlap(1)) == 0) {
+    } else if ((win2 = make_overlap(1)) == NULL) {
 	delwin(win1);
 	return ERR;
     }
@@ -7406,9 +7407,9 @@
     int shift = 0, last_refresh = -1;
     int state, flavor[OVERLAP_FLAVORS];
 
-    if ((win1 = make_overlap(0)) == 0) {
+    if ((win1 = make_overlap(0)) == NULL) {
 	return ERR;
-    } else if ((win2 = make_overlap(1)) == 0) {
+    } else if ((win2 = make_overlap(1)) == NULL) {
 	delwin(win1);
 	return ERR;
     }
@@ -7902,7 +7903,7 @@
     bool monochrome = FALSE;
 #if HAVE_COLOR_CONTENT
     bool xterm_colors = FALSE;
-    NCURSES_CONST char *palette_file = 0;
+    NCURSES_CONST char *palette_file = NULL;
 #endif
 
     setlocale(LC_ALL, "");
@@ -7972,7 +7973,7 @@
 #endif
 #ifdef TRACE
 	case 'D':
-	    save_trace = (unsigned) strtol(optarg, 0, 0);
+	    save_trace = (unsigned) strtol(optarg, NULL, 0);
 	    break;
 #endif
 #if HAVE_COLOR_CONTENT
Index: test/padview.c
Prereq:  1.26 
--- ncurses-6.5-20241130+/test/padview.c	2024-11-30 18:14:46.000000000 +0000
+++ ncurses-6.5-20241207/test/padview.c	2024-12-07 22:40:19.000000000 +0000
@@ -29,7 +29,7 @@
 /*
  * clone of view.c, using pads
  *
- * $Id: padview.c,v 1.26 2024/11/30 18:14:46 tom Exp $
+ * $Id: padview.c,v 1.27 2024/12/07 22:40:19 tom Exp $
  */
 
 #include <test.priv.h>
@@ -124,7 +124,7 @@
     size_t len;
     struct stat sb;
     char *my_blob;
-    char **my_vec = 0;
+    char **my_vec = NULL;
     WINDOW *my_pad;
 
     if (stat(filename, &sb) != 0
@@ -136,11 +136,11 @@
 	failed("input is empty");
     }
 
-    if ((fp = fopen(filename, "r")) == 0) {
+    if ((fp = fopen(filename, "r")) == NULL) {
 	failed("cannot open input-file");
     }
 
-    if ((my_blob = malloc((size_t) sb.st_size + 1)) == 0) {
+    if ((my_blob = malloc((size_t) sb.st_size + 1)) == NULL) {
 	failed("cannot allocate memory for input-file");
     }
 
@@ -171,7 +171,7 @@
 	}
 	num_lines = k;
 	if (pass == 0) {
-	    if (((my_vec = typeCalloc(char *, (size_t) k + 2)) == 0)) {
+	    if (((my_vec = typeCalloc(char *, (size_t) k + 2)) == NULL)) {
 		failed("cannot allocate line-vector #1");
 	    }
 	} else {
@@ -199,7 +199,7 @@
     }
     width = (width + 1) * 5;
     my_pad = newpad(height, width);
-    if (my_pad == 0)
+    if (my_pad == NULL)
 	failed("cannot allocate pad workspace");
     if (try_color) {
 	wattrset(my_pad, COLOR_PAIR(my_pair));
@@ -301,7 +301,7 @@
 	"  s              - use entered count for halfdelay() parameter",
 	"                 - if no entered count, stop nodelay()",
 	"  <space>        - begin nodelay()",
-	0
+	NULL
     };
 
     int ch;
@@ -337,9 +337,9 @@
 #ifdef TRACE
 	case 'D':
 	    {
-		char *next = 0;
+		char *next = NULL;
 		int tvalue = (int) strtol(optarg, &next, 0);
-		if (tvalue < 0 || (next != 0 && *next != 0))
+		if (tvalue < 0 || (next != NULL && *next != 0))
 		    usage(FALSE);
 		curses_trace((unsigned) tvalue);
 	    }
Index: test/pair_content.c
Prereq:  1.24 
--- ncurses-6.5-20241130+/test/pair_content.c	2024-11-30 18:31:01.000000000 +0000
+++ ncurses-6.5-20241207/test/pair_content.c	2024-12-07 22:45:15.000000000 +0000
@@ -26,7 +26,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: pair_content.c,v 1.24 2024/11/30 18:31:01 tom Exp $
+ * $Id: pair_content.c,v 1.25 2024/12/07 22:45:15 tom Exp $
  */
 
 #define NEED_TIME_H
@@ -181,7 +181,7 @@
 	my_color_t fg;
 	my_color_t bg;
 	if (PairContent(pair, &fg, &bg) == OK) {
-	    if (expected != 0) {
+	    if (expected != NULL) {
 		if (fg != expected[pair].fg)
 		    success = FALSE;
 		if (bg != expected[pair].bg)
Index: test/picsmap.c
Prereq:  1.152 
--- ncurses-6.5-20241130+/test/picsmap.c	2024-11-30 21:39:57.000000000 +0000
+++ ncurses-6.5-20241207/test/picsmap.c	2024-12-07 22:48:03.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: picsmap.c,v 1.152 2024/11/30 21:39:57 tom Exp $
+ * $Id: picsmap.c,v 1.153 2024/12/07 22:48:03 tom Exp $
  *
  * Author: Thomas E. Dickey
  *
@@ -109,7 +109,7 @@
 static void warning(const char *fmt, ...) GCC_PRINTFLIKE(1, 2);
 static int gather_c_values(int);
 
-static FILE *logfp = 0;
+static FILE *logfp = NULL;
 static double aspect_ratio = 0.6;
 static bool in_curses = FALSE;
 static bool debugging = FALSE;
@@ -138,7 +138,7 @@
 static void
 logmsg(const char *fmt, ...)
 {
-    if (logfp != 0) {
+    if (logfp != NULL) {
 	va_list ap;
 	va_start(ap, fmt);
 	vfprintf(logfp, fmt, ap);
@@ -151,7 +151,7 @@
 static void
 logmsg2(const char *fmt, ...)
 {
-    if (logfp != 0) {
+    if (logfp != NULL) {
 	va_list ap;
 	va_start(ap, fmt);
 	vfprintf(logfp, fmt, ap);
@@ -163,7 +163,7 @@
 static void
 close_log(void)
 {
-    if (logfp != 0) {
+    if (logfp != NULL) {
 	logmsg("Allocations:");
 	logmsg("%8ld file", (long) how_much.file);
 	logmsg("%8ld name", (long) how_much.name);
@@ -174,7 +174,7 @@
 	logmsg("%8ld cell", (long) how_much.cell);
 	logmsg("%8ld window", LINES * COLS * (long) sizeof(NCURSES_CH_T));
 	fclose(logfp);
-	logfp = 0;
+	logfp = NULL;
     }
 }
 
@@ -199,7 +199,7 @@
 static void
 warning(const char *fmt, ...)
 {
-    if (logfp != 0) {
+    if (logfp != NULL) {
 	va_list ap;
 	va_start(ap, fmt);
 	vfprintf(logfp, fmt, ap);
@@ -219,7 +219,7 @@
 static void
 free_data(char **data)
 {
-    if (data != 0) {
+    if (data != NULL) {
 	free(data[0]);
 	free(data);
     }
@@ -228,12 +228,12 @@
 static PICS_HEAD *
 free_pics_head(PICS_HEAD * pics)
 {
-    if (pics != 0) {
+    if (pics != NULL) {
 	free(pics->fgcol);
 	free(pics->cells);
 	free(pics->name);
 	free(pics);
-	pics = 0;
+	pics = NULL;
     }
     return pics;
 }
@@ -305,14 +305,14 @@
     reading_ncols[next].count = 0;
 
     check_c_values(__LINE__);
-    if ((ft = tfind(I2P(next), &reading_ntree, compare_c_values)) != 0) {
+    if ((ft = tfind(I2P(next), &reading_ntree, compare_c_values)) != NULL) {
 	found = P2I(*ft);
     } else {
 	if (reading_last + 2 >= reading_size) {
 	    int more = ((MAX(reading_last, reading_size) + 2) * 3) / 2;
 	    int last = reading_last + 1;
 	    FG_NODE *p = typeRealloc(FG_NODE, more, reading_ncols);
-	    if (p == 0)
+	    if (p == NULL)
 		goto done;
 
 	    reading_size = more;
@@ -323,7 +323,7 @@
 	}
 	++reading_last;
 	how_much.pair += sizeof(FG_NODE);
-	if ((ft = tsearch(I2P(next), &reading_ntree, compare_c_values)) != 0) {
+	if ((ft = tsearch(I2P(next), &reading_ntree, compare_c_values)) != NULL) {
 	    found = P2I(*ft);
 	    if (found != next)
 		logmsg("OOPS expected slot %d, got %d", next, found);
@@ -370,24 +370,24 @@
 
     reading_last = 0;
     reading_size = 0;
-    reading_ncols = 0;
+    reading_ncols = NULL;
 }
 
 static void
 dispose_c_values(void)
 {
 #if HAVE_TSEARCH
-    if (reading_ntree != 0) {
+    if (reading_ntree != NULL) {
 	int n;
 	for (n = 0; n < reading_last; ++n) {
 	    tdelete(I2P(n), &reading_ntree, compare_c_values);
 	}
-	reading_ntree = 0;
+	reading_ntree = NULL;
     }
 #endif
-    if (reading_ncols != 0) {
+    if (reading_ncols != NULL) {
 	free(reading_ncols);
-	reading_ncols = 0;
+	reading_ncols = NULL;
     }
     reading_last = 0;
     reading_size = 0;
@@ -413,7 +413,7 @@
 static char **
 read_file(const char *filename)
 {
-    char **result = 0;
+    char **result = NULL;
     struct stat sb;
 
     if (!quiet) {
@@ -430,9 +430,9 @@
 	result = typeCalloc(char *, size + 1);
 	how_much.file += ((size + 1) * 2);
 
-	if (blob != 0 && result != 0) {
+	if (blob != NULL && result != NULL) {
 	    FILE *fp = fopen(filename, "r");
-	    if (fp != 0) {
+	    if (fp != NULL) {
 		logmsg("opened %s", filename);
 
 		if (fread(blob, sizeof(char), size, fp) == size) {
@@ -457,7 +457,7 @@
 			    result[k++] = blob + j;
 			}
 		    }
-		    result[k] = 0;
+		    result[k] = NULL;
 		    if (k && !binary) {
 			debugmsg2("[%5d] %s\n", k, result[k - 1]);
 		    }
@@ -471,7 +471,7 @@
 	    debugmsg("...file is empty");
 	    free(blob);
 	    free(result);
-	    result = 0;
+	    result = NULL;
 	} else if (binary) {
 	    debugmsg("...file is non-text");
 	}
@@ -548,20 +548,20 @@
 read_palette(const char *filename)
 {
     static const char *data_dir = DATA_DIR;
-    char **result = 0;
+    char **result = NULL;
     size_t last = strlen(filename);
     size_t need = (strlen(data_dir) + 20 + last);
     char *full_name = malloc(need);
     char *s;
     struct stat sb;
 
-    if (full_name != 0) {
+    if (full_name != NULL) {
 	int tries;
 	for (tries = 0; tries < 8; ++tries) {
 
 	    *(s = full_name) = '\0';
 	    if (tries & 1) {
-		if (strchr(filename, '/') == 0) {
+		if (strchr(filename, '/') == NULL) {
 		    _nc_SPRINTF(full_name, _nc_SLIMIT(need) "%s/", data_dir);
 		} else {
 		    continue;
@@ -582,7 +582,7 @@
 		    if (*t == '-') {
 			if (sscanf(t, "-%d%c", &num, &chr) == 2 &&
 			    chr == 'c' &&
-			    (tc = strchr(t, chr)) != 0 &&
+			    (tc = strchr(t, chr)) != NULL &&
 			    !(strncmp) (tc, "color", 5)) {
 			    found = 1;
 			}
@@ -622,7 +622,7 @@
 static void
 init_palette(const char *palette_file)
 {
-    if (palette_file != 0) {
+    if (palette_file != NULL) {
 	char **data = read_palette(palette_file);
 
 	all_colors = typeMalloc(RGB_DATA, (unsigned) COLORS);
@@ -641,12 +641,12 @@
 #else
 	memset(all_colors, 0, sizeof(RGB_DATA) * (size_t) COLORS);
 #endif
-	if (data != 0) {
+	if (data != NULL) {
 	    int n;
 	    int red, green, blue;
 	    int scale = MaxSCALE;
 	    int c;
-	    for (n = 0; data[n] != 0; ++n) {
+	    for (n = 0; data[n] != NULL; ++n) {
 		if (sscanf(data[n], "scale:%d", &c) == 1) {
 		    scale = c;
 		} else if (sscanf(data[n], "%d:%d %d %d",
@@ -677,9 +677,9 @@
 	}
 
 	if ((power2 != COLORS) || ((shift % 3) != 0)) {
-	    if (all_colors == 0) {
+	    if (all_colors == NULL) {
 		init_palette(getenv("TERM"));
-		if (all_colors == 0) {
+		if (all_colors == NULL) {
 		    giveup("With %d colors, you need a palette-file", COLORS);
 		}
 	    }
@@ -704,7 +704,7 @@
 	int green = (value & 0x00ff00) >> 8;
 	int blue  = (value & 0x0000ff) >> 0;
 
-	if (all_colors != 0) {
+	if (all_colors != NULL) {
 #define Diff2(n,m) ((m) - all_colors[n].m) * ((m) - all_colors[n].m)
 #define Diff2S(n) Diff2(n,red) + Diff2(n,green) + Diff2(n,blue)
 	    int d2 = Diff2S(0);
@@ -823,7 +823,7 @@
 		limit = -1;
 		ip = va_arg(ap, int *);
 		lv = strtol(source, &cp, ch == 'd' ? 10 : 16);
-		if (cp != 0 && cp != source) {
+		if (cp != NULL && cp != source) {
 		    *ip = (int) lv;
 		    source = cp;
 		} else {
@@ -834,13 +834,13 @@
 		/* floating point for pixels... */
 		fp = va_arg(ap, float *);
 		lv = strtol(source, &cp, 10);
-		if (cp == 0 || cp == source)
+		if (cp == NULL || cp == source)
 		    goto finish;
 		*fp = (float) lv;
 		source = cp;
 		if (*source == '.') {
 		    lv = strtol(++source, &cp, 10);
-		    if (cp == 0 || cp == source)
+		    if (cp == NULL || cp == source)
 			goto finish;
 		    {
 			float scale = 1.0f;
@@ -907,7 +907,7 @@
 	    s += cpp;
 	    while (*s++ == '\t') {
 		char *t;
-		for (t = arg2; (*s != '\0') && strchr("\t\"", *s) == 0;) {
+		for (t = arg2; (*s != '\0') && strchr("\t\"", *s) == NULL;) {
 		    if (*s == ' ') {
 			s = skip_cs(s);
 			break;
@@ -915,7 +915,7 @@
 		    *t++ = *s++;
 		    *t = '\0';
 		}
-		for (t = arg3; (*s != '\0') && strchr("\t\"", *s) == 0;) {
+		for (t = arg3; (*s != '\0') && strchr("\t\"", *s) == NULL;) {
 		    *t++ = *s++;
 		    *t = '\0';
 		}
@@ -938,14 +938,14 @@
     char *s, *t;
     size_t item = 0;
     size_t need;
-    RGB_NAME *result = 0;
+    RGB_NAME *result = NULL;
 
-    for (need = 0; data[need] != 0; ++need) ;
+    for (need = 0; data[need] != NULL; ++need) ;
 
     result = typeCalloc(RGB_NAME, need + 2);
     how_much.name += (sizeof(RGB_NAME) * (need + 2));
 
-    for (n = 0; data[n] != 0; ++n) {
+    for (n = 0; data[n] != NULL; ++n) {
 	if (strlen(t = data[n]) >= sizeof(buf) - 1)
 	    continue;
 	t = strcpy(buf, t);
@@ -993,10 +993,10 @@
 static RGB_NAME *
 lookup_rgb(const char *name)
 {
-    RGB_NAME *result = 0;
-    if (rgb_table != 0) {
+    RGB_NAME *result = NULL;
+    if (rgb_table != NULL) {
 	int n;
-	for (n = 0; rgb_table[n].name != 0; ++n) {
+	for (n = 0; rgb_table[n].name != NULL; ++n) {
 	    if (!CaselessCmp(name, rgb_table[n].name)) {
 		result = &rgb_table[n];
 		break;
@@ -1029,7 +1029,7 @@
     gather_c_values(0);
     gather_c_values(0xffffff);
 
-    for (n = 0; data[n] != 0; ++n) {
+    for (n = 0; data[n] != NULL; ++n) {
 	if (strlen(s = data[n]) >= sizeof(buf) - 1)
 	    continue;
 	switch (state) {
@@ -1037,10 +1037,10 @@
 	case 1:
 	case 2:
 	    if (sscanf(s, "#define %1024s %d%c", buf, &num, &ch) >= 2) {
-		if ((t = strstr(buf, "_width")) != 0) {
+		if ((t = strstr(buf, "_width")) != NULL) {
 		    state |= 1;
 		    result->wide = (short) bytes_of(num);
-		} else if ((t = strstr(buf, "_height")) != 0) {
+		} else if ((t = strstr(buf, "_height")) != NULL) {
 		    state |= 2;
 		    result->high = (short) num;
 		} else {
@@ -1067,7 +1067,7 @@
 		result->cells = typeCalloc(PICS_CELL, cells);
 		how_much.cell += (sizeof(PICS_CELL) * cells);
 
-		if ((s = strchr(s, L_CURLY)) == 0)
+		if ((s = strchr(s, L_CURLY)) == NULL)
 		    break;
 		++s;
 	    } else {
@@ -1147,14 +1147,14 @@
     char arg1[BUFSIZ];
     char arg2[BUFSIZ];
     char arg3[BUFSIZ];
-    char **list = 0;
+    char **list = NULL;
 
     debugmsg("called parse_xpm");
 
     result = typeCalloc(PICS_HEAD, 1);
     how_much.head += sizeof(PICS_HEAD);
 
-    for (n = 0; data[n] != 0; ++n) {
+    for (n = 0; data[n] != NULL; ++n) {
 	if (strlen(s = data[n]) >= sizeof(buf) - 1)
 	    continue;
 	s = strcpy(buf, s);
@@ -1201,7 +1201,7 @@
 	    num_colors++;
 	    free(list[reading_last]);
 	    list[reading_last] = strdup(arg1);
-	    if ((by_name = lookup_rgb(arg3)) != 0) {
+	    if ((by_name = lookup_rgb(arg3)) != NULL) {
 		found = gather_c_values(by_name->value);
 	    } else if (*arg3 == '#') {
 		char *rgb = arg3 + 1;
@@ -1227,7 +1227,7 @@
 	    if (num_colors >= result->colors) {
 		finish_c_values(result);
 		state = 4;
-		if (list[0] == 0)
+		if (list[0] == NULL)
 		    list[0] = strdup("\033");
 	    }
 	    break;
@@ -1239,7 +1239,7 @@
 
 		    /* FIXME - factor out */
 		    for (c = 0; c < result->colors; ++c) {
-			if (list[c] == 0) {
+			if (list[c] == NULL) {
 			    /* should not happen... */
 			    continue;
 			}
@@ -1314,8 +1314,8 @@
     result = typeCalloc(PICS_HEAD, 1);
     how_much.head += sizeof(PICS_HEAD);
 
-    if ((pp = popen(cmd, "r")) != 0) {
-	if (fgets(buffer, sizeof(buffer), pp) != 0) {
+    if ((pp = popen(cmd, "r")) != NULL) {
+	if (fgets(buffer, sizeof(buffer), pp) != NULL) {
 	    size_t n = strlen(filename);
 	    debugmsg2("...read %s", buffer);
 	    if (strlen(buffer) > n &&
@@ -1341,12 +1341,12 @@
 	_nc_STRCAT(cmd, " 2>/dev/null", need);
 
     logmsg("...opening pipe to %s", cmd);
-    if ((pp = popen(cmd, "r")) != 0) {
+    if ((pp = popen(cmd, "r")) != NULL) {
 	int count = 0;
 	int col = 0;
 	int row = 0;
 	int len = 0;
-	while (fgets(buffer, sizeof(buffer), pp) != 0) {
+	while (fgets(buffer, sizeof(buffer), pp) != NULL) {
 	    debugmsg2("[%5d] %s", count + 1, buffer);
 	    if (strlen(buffer) > 160) {		/* 80 columns would be enough */
 		okay = FALSE;
@@ -1380,7 +1380,7 @@
 		const char *t = s;
 		bool matched = FALSE;
 
-		if (s != 0) {
+		if (s != NULL) {
 		    /* after the "#RGB", there are differences - just ignore */
 		    while (*s != '\0' && !isspace(UChar(*s)))
 			++s;
@@ -1472,11 +1472,11 @@
 read_picture(const char *filename, char **data)
 {
     PICS_HEAD *pics;
-    if ((pics = parse_xbm(data)) == 0) {
+    if ((pics = parse_xbm(data)) == NULL) {
 	dispose_c_values();
-	if ((pics = parse_xpm(data)) == 0) {
+	if ((pics = parse_xpm(data)) == NULL) {
 	    dispose_c_values();
-	    if ((pics = parse_img(filename)) == 0) {
+	    if ((pics = parse_img(filename)) == NULL) {
 		dispose_c_values();
 		free_data(data);
 		warning("unexpected file-format for \"%s\"", filename);
@@ -1638,7 +1638,7 @@
     int total;
     char buffer[256];
 
-    if (logfp == 0)
+    if (logfp == NULL)
 	return;
 
     qsort(pics->fgcol, (size_t) pics->colors, sizeof(FG_NODE), compare_fg_counts);
@@ -1729,7 +1729,7 @@
     int ch;
     int opt_d = FALSE;
     char ignore_ch;
-    const char *palette_path = 0;
+    const char *palette_path = NULL;
     const char *rgb_path = RGB_PATH;
 
     while ((ch = getopt(argc, argv, OPTS_COMMON "a:dLF:p:qr:s:x:")) != -1) {
@@ -1751,7 +1751,7 @@
 	    debugging = TRUE;
 	    break;
 	case 'F':
-	    if ((logfp = fopen(optarg, "a")) == 0)
+	    if ((logfp = fopen(optarg, "a")) == NULL)
 		failed(optarg);
 	    break;
 	case 'p':
@@ -1810,11 +1810,11 @@
 	    PICS_HEAD *pics;
 	    char **data = read_file(argv[n]);
 
-	    if (data == 0) {
+	    if (data == NULL) {
 		warning("cannot read \"%s\"", argv[n]);
 		continue;
 	    }
-	    if ((pics = read_picture(argv[n], data)) != 0) {
+	    if ((pics = read_picture(argv[n], data)) != NULL) {
 		if (in_curses) {
 		    show_picture(pics);
 		} else {
Index: test/popup_msg.c
Prereq:  1.14 
--- ncurses-6.5-20241130+/test/popup_msg.c	2024-10-26 19:28:11.000000000 +0000
+++ ncurses-6.5-20241207/test/popup_msg.c	2024-12-07 22:22:51.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: popup_msg.c,v 1.14 2024/10/26 19:28:11 Stas.Sergeev Exp $
+ * $Id: popup_msg.c,v 1.15 2024/12/07 22:22:51 tom Exp $
  *
  * Show a multi-line message in a window which may extend beyond the screen.
  *
@@ -78,16 +78,16 @@
     int last_y;
     int ch = ERR;
 
-    for (n = 0; msg[n] != 0; ++n) {
+    for (n = 0; msg[n] != NULL; ++n) {
 	int check = (int) strlen(msg[n]);
 	if (width < check)
 	    width = check;
     }
     length = n;
 
-    if ((help = newwin(high, wide, y0, x0)) == 0)
+    if ((help = newwin(high, wide, y0, x0)) == NULL)
 	return;
-    if ((data = newpad(length + 2, width + 1)) == 0) {
+    if ((data = newpad(length + 2, width + 1)) == NULL) {
 	delwin(help);
 	return;
     }
Index: test/railroad.c
Prereq:  1.27 
--- ncurses-6.5-20241130+/test/railroad.c	2024-10-05 19:26:24.000000000 +0000
+++ ncurses-6.5-20241207/test/railroad.c	2024-12-07 22:48:03.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey - 2000
  *
- * $Id: railroad.c,v 1.27 2024/10/05 19:26:24 tom Exp $
+ * $Id: railroad.c,v 1.28 2024/12/07 22:48:03 tom Exp $
  *
  * A simple demo of the termcap interface.
  */
@@ -83,13 +83,13 @@
 static void
 Backup(void)
 {
-    tputs(backup != 0 ? backup : "\b", 1, outc);
+    tputs(backup != NULL ? backup : "\b", 1, outc);
 }
 
 static void
 MyShowCursor(int flag)
 {
-    if (startC != 0 && finisC != 0) {
+    if (startC != NULL && finisC != NULL) {
 	tputs(flag ? startC : finisC, 1, outc);
     }
 }
@@ -97,7 +97,7 @@
 static void
 StandOut(int flag)
 {
-    if (startS != 0 && finisS != 0) {
+    if (startS != NULL && finisS != NULL) {
 	tputs(flag ? startS : finisS, 1, outc);
     }
 }
@@ -105,7 +105,7 @@
 static void
 Underline(int flag)
 {
-    if (startU != 0 && finisU != 0) {
+    if (startU != NULL && finisU != NULL) {
 	tputs(flag ? startU : finisU, 1, outc);
     }
 }
@@ -116,7 +116,7 @@
     const char *base = string;
     int first, last;
 
-    if (moveit != 0) {
+    if (moveit != NULL) {
 	tputs(tgoto(moveit, 0, height - 1), 1, outc);
 	tputs(wipeit, 1, outc);
     }
@@ -124,7 +124,7 @@
     while (*string != 0) {
 	int ch = *string;
 	if (ch != ' ') {
-	    if (moveit != 0) {
+	    if (moveit != NULL) {
 		for (first = length - 2; first >= (string - base); first--) {
 		    if (first < length - 1) {
 			tputs(tgoto(moveit, first + 1, height - 1), 1, outc);
@@ -152,7 +152,7 @@
 		    Underline(0);
 		}
 	    }
-	    if (moveit != 0)
+	    if (moveit != NULL)
 		Backup();
 	}
 	StandOut(1);
@@ -161,7 +161,7 @@
 	fflush(stdout);
 	string++;
     }
-    if (moveit != 0)
+    if (moveit != NULL)
 	tputs(wipeit, 1, outc);
     putchar('\n');
 }
@@ -190,7 +190,7 @@
     char area[1024], *ap = area;
     int z;
 
-    if (name == 0)
+    if (name == NULL)
 #ifdef EXP_WIN32_DRIVER
 	name = "ms-terminal";
 #else
@@ -205,12 +205,12 @@
 	length = tgetnum("co");
 	moveit = tgetstr("cm", &ap);
 
-	if (wipeit == 0
-	    || moveit == 0
+	if (wipeit == NULL
+	    || moveit == NULL
 	    || height <= 0
 	    || length <= 0) {
-	    wipeit = 0;
-	    moveit = 0;
+	    wipeit = NULL;
+	    moveit = NULL;
 	    height = 0;
 	    length = 0;
 	}
@@ -276,7 +276,7 @@
     } else {
 	static char world[] = "Hello World";
 	static char *hello[] =
-	{world, 0};
+	{world, NULL};
 	railroad(hello);
     }
     ExitProgram(EXIT_SUCCESS);
Index: test/rain.c
Prereq:  1.62 
--- ncurses-6.5-20241130+/test/rain.c	2024-10-06 21:09:00.000000000 +0000
+++ ncurses-6.5-20241207/test/rain.c	2024-12-07 22:46:42.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: rain.c,v 1.62 2024/10/06 21:09:00 tom Exp $
+ * $Id: rain.c,v 1.63 2024/12/07 22:46:42 tom Exp $
  */
 #include <test.priv.h>
 #include <popup_msg.h>
@@ -335,7 +335,7 @@
 	" s          do single-step",
 	" <space>    undo single-step",
 	"",
-	0
+	NULL
     };
 
     bool done = FALSE;
Index: test/redraw.c
Prereq:  1.18 
--- ncurses-6.5-20241130+/test/redraw.c	2024-10-06 21:17:54.000000000 +0000
+++ ncurses-6.5-20241207/test/redraw.c	2024-12-07 22:46:42.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: redraw.c,v 1.18 2024/10/06 21:17:54 tom Exp $
+ * $Id: redraw.c,v 1.19 2024/12/07 22:46:42 tom Exp $
  *
  * Demonstrate the redrawwin() and wredrawln() functions.
  * Thomas Dickey - 2006/11/4
@@ -76,7 +76,7 @@
 	"",
 	"Other control characters are added to the screen in printable form.",
 	"Other printable characters are added to the screen as is.",
-	0
+	NULL
     };
 
     WINDOW *win1;
Index: test/savescreen.c
Prereq:  1.66 
--- ncurses-6.5-20241130+/test/savescreen.c	2024-11-30 18:48:40.000000000 +0000
+++ ncurses-6.5-20241207/test/savescreen.c	2024-12-07 22:46:42.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: savescreen.c,v 1.66 2024/11/30 18:48:40 tom Exp $
+ * $Id: savescreen.c,v 1.67 2024/12/07 22:46:42 tom Exp $
  *
  * Demonstrate save/restore functions from the curses library.
  * Thomas Dickey - 2007/7/14
@@ -89,7 +89,7 @@
     if (!keep_dumps) {
 	int n;
 
-	for (n = 0; files[n] != 0; ++n) {
+	for (n = 0; files[n] != NULL; ++n) {
 	    unlink(files[n]);
 	}
     }
@@ -173,7 +173,7 @@
     NCURSES_CONST char *filename = files[which];
     bool dumped = FALSE;
 
-    if (filename != 0) {
+    if (filename != NULL) {
 	dumped = TRUE;
 	show_what(color, ++which, last);
 	if (scr_dump(filename) == ERR) {
@@ -230,7 +230,7 @@
 	"   a           toggle between '#' and graphic symbol for drawing",
 	"   c           change color drawn by line to next in palette",
 	"   h,j,k,l or arrows to move around the screen, drawing",
-	0
+	NULL
     };
     popup_msg(stdscr, msgs);
 }
@@ -247,7 +247,7 @@
 	"   q           quit",
 	"   <space>     load the next screen",
 	"   <backspace> load the previous screen",
-	0
+	NULL
     };
     popup_msg(stdscr, msgs);
 }
@@ -286,7 +286,7 @@
     bool replaying = FALSE;
     bool done = FALSE;
     char **files;
-    NCURSES_CONST char *fill_by = 0;
+    NCURSES_CONST char *fill_by = NULL;
 #if USE_WIDEC_SUPPORT
     cchar_t mycc;
     static const wchar_t mywc[2] =
@@ -366,7 +366,7 @@
 	 * After that, use color pairs for constructing a test-pattern, e.g.,
 	 * imitating xterm's scripts.
 	 */
-	if (fill_by == 0) {
+	if (fill_by == NULL) {
 	    if (COLORS <= 256) {
 		for (n = 0; n < COLORS; ++n)
 		    init_pair((short) (n + MAX_ANSI), (short) n, (short) n);
@@ -407,7 +407,7 @@
 	    }
 #endif
 	}
-	if ((fill_by == 0) && !replaying) {
+	if ((fill_by == NULL) && !replaying) {
 #if USE_WIDEC_SUPPORT
 	    int cube = 0;
 #endif
@@ -484,9 +484,9 @@
 	}
     }
 
-    if (fill_by != 0) {
+    if (fill_by != NULL) {
 	FILE *fp = fopen(fill_by, "r");
-	if (fp != 0) {
+	if (fp != NULL) {
 	    bool filled = FALSE;
 	    move(1, 0);
 	    while ((ch = fgetc(fp)) != EOF) {
@@ -577,7 +577,7 @@
 	int x = 0;
 	int color = 0;
 	int altchars = 0;
-	bool dirty = use_colors || (fill_by != 0);
+	bool dirty = use_colors || (fill_by != NULL);
 
 	while (!done) {
 	    switch (get_command(color, which, last)) {
Index: test/sp_tinfo.c
Prereq:  1.29 
--- ncurses-6.5-20241130+/test/sp_tinfo.c	2023-06-24 14:14:56.000000000 +0000
+++ ncurses-6.5-20241207/test/sp_tinfo.c	2024-12-07 23:03:07.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2019-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2019-2023,2024 Thomas E. Dickey                                *
  * Copyright 2017 Free Software Foundation, Inc.                            *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -28,7 +28,7 @@
  ****************************************************************************/
 
 /*
- * $Id: sp_tinfo.c,v 1.29 2023/06/24 14:14:56 tom Exp $
+ * $Id: sp_tinfo.c,v 1.30 2024/12/07 23:03:07 tom Exp $
  *
  * TOTO: add option for non-sp-funcs interface
  */
@@ -138,7 +138,7 @@
 show_string(MYDATA * data, const char *name, const char *value)
 {
     fprintf(data->fp, " %s = ", name);
-    if (value == 0) {
+    if (value == NULL) {
 	fprintf(data->fp, "(missing)");
     } else if (value == (char *) -1) {
 	fprintf(data->fp, "(canceled)");
@@ -218,7 +218,7 @@
     define_key_sp(sp, my_text, my_code);
     has_key_sp(sp, 0);
     key_defined_sp(sp, my_text);
-    if ((s = keybound_sp(sp, my_code, 0)) != 0)
+    if ((s = keybound_sp(sp, my_code, 0)) != NULL)
 	free(s);
 #endif
     keyname_sp(sp, '?');
@@ -240,7 +240,7 @@
     typeahead_sp(sp, FALSE);	/* waddch */
     use_env_sp(sp, FALSE);	/* newterm */
     use_tioctl_sp(sp, FALSE);	/* newterm */
-    intrflush_sp(sp, 0, 0);	/* wgetch */
+    intrflush_sp(sp, NULL, 0);	/* wgetch */
     flushinp_sp(sp);		/* waddch */
     halfdelay_sp(sp, 5);	/* wgetch */
 
Index: test/tclock.c
Prereq:  1.49 
--- ncurses-6.5-20241130+/test/tclock.c	2024-10-05 18:47:56.000000000 +0000
+++ ncurses-6.5-20241207/test/tclock.c	2024-12-07 22:46:42.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: tclock.c,v 1.49 2024/10/05 18:47:56 tom Exp $ */
+/* $Id: tclock.c,v 1.50 2024/12/07 22:46:42 tom Exp $ */
 
 #define NEED_TIME_H
 #include <test.priv.h>
@@ -220,7 +220,7 @@
     for (;;) {
 	napms(100);
 
-	tim = time(0);
+	tim = time(NULL);
 	t = localtime(&tim);
 
 	hours = (t->tm_hour + (t->tm_min / 60.0));
Index: test/test_add_wchstr.c
Prereq:  1.35 
--- ncurses-6.5-20241130+/test/test_add_wchstr.c	2024-10-05 19:26:24.000000000 +0000
+++ ncurses-6.5-20241207/test/test_add_wchstr.c	2024-12-07 22:41:11.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_add_wchstr.c,v 1.35 2024/10/05 19:26:24 tom Exp $
+ * $Id: test_add_wchstr.c,v 1.36 2024/12/07 22:41:11 tom Exp $
  *
  * Demonstrate the waddwchstr() and wadd_wch functions.
  * Thomas Dickey - 2009/9/12
@@ -88,7 +88,7 @@
 static size_t temp_length;
 
 #define TempBuffer(source_len, source_cast) \
-    if (source != 0) { \
+    if (source != NULL) { \
 	const char *temp; \
 	size_t need = source_len + 1; \
 	wchar_t have[2]; \
@@ -107,7 +107,7 @@
 	    if (!pass_ctls \
 	     && have[0] != 0 \
 	     && have[0] < 256 \
-	     && (temp = unctrl((chtype) have[0])) != 0 \
+	     && (temp = unctrl((chtype) have[0])) != NULL \
 	     && strlen(temp) > 1) { \
 		while (*temp != '\0') { \
 		    have[0] = (wchar_t) *temp++; \
@@ -117,9 +117,9 @@
 		setcchar(&temp_buffer[n++], have, A_NORMAL, 0, NULL); \
 	    } \
 	} while (have[0] != 0); \
-    } else if (temp_buffer != 0) { \
+    } else if (temp_buffer != NULL) { \
 	free(temp_buffer); \
-	temp_buffer = 0; \
+	temp_buffer = NULL; \
 	temp_length = 0; \
     } \
     return temp_buffer;
@@ -136,7 +136,7 @@
 	for (n = 0; source[n] != 0; ++n) {
 	    const char *s;
 
-	    if ((source[n] < 256) && (s = unctrl((chtype) source[n])) != 0) {
+	    if ((source[n] < 256) && (s = unctrl((chtype) source[n])) != NULL) {
 		adjust += (strlen(s) - 1);
 	    }
 	}
@@ -310,9 +310,9 @@
     int row2, col2;
     int length;
     wchar_t buffer[BUFSIZ];
-    WINDOW *look = 0;
-    WINDOW *work = 0;
-    WINDOW *show = 0;
+    WINDOW *look = NULL;
+    WINDOW *work = NULL;
+    WINDOW *show = NULL;
     int margin = (2 * MY_TABSIZE) - 1;
     Options option = (Options) ((unsigned) (m_opt
 					    ? oMove
Index: test/test_addchstr.c
Prereq:  1.30 
--- ncurses-6.5-20241130+/test/test_addchstr.c	2024-10-05 19:26:24.000000000 +0000
+++ ncurses-6.5-20241207/test/test_addchstr.c	2024-12-07 22:41:11.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_addchstr.c,v 1.30 2024/10/05 19:26:24 tom Exp $
+ * $Id: test_addchstr.c,v 1.31 2024/12/07 22:41:11 tom Exp $
  *
  * Demonstrate the waddchstr() and waddch functions.
  * Thomas Dickey - 2009/9/12
@@ -82,7 +82,7 @@
 
 	for (n = 0; n < result; ++n) {
 	    const char *s = unctrl(UChar(source[n]));
-	    if (s != 0) {
+	    if (s != NULL) {
 		adjust += (strlen(s) - 1);
 	    }
 	}
@@ -94,7 +94,7 @@
 static chtype *
 ChStr(const char *source)
 {
-    if (source != 0) {
+    if (source != NULL) {
 	size_t need = ChLen(source) + 1;
 	int n = 0;
 
@@ -107,7 +107,7 @@
 	do {
 	    const char *s;
 	    chtype ch = UChar(*source++);
-	    if (!pass_ctls && (s = unctrl(ch)) != 0) {
+	    if (!pass_ctls && (s = unctrl(ch)) != NULL) {
 		while (*s != '\0') {
 		    temp_buffer[n++] = UChar(*s++);
 		}
@@ -116,9 +116,9 @@
 	    }
 	} while (source[0] != 0);
 	temp_buffer[n] = 0;
-    } else if (temp_buffer != 0) {
+    } else if (temp_buffer != NULL) {
 	free(temp_buffer);
-	temp_buffer = 0;
+	temp_buffer = NULL;
 	temp_length = 0;
     }
     return temp_buffer;
@@ -218,9 +218,9 @@
     int row2, col2;
     int length;
     char buffer[BUFSIZ];
-    WINDOW *look = 0;
-    WINDOW *work = 0;
-    WINDOW *show = 0;
+    WINDOW *look = NULL;
+    WINDOW *work = NULL;
+    WINDOW *show = NULL;
     int margin = (2 * MY_TABSIZE) - 1;
     Options option = (Options) ((unsigned) (m_opt
 					    ? oMove
Index: test/test_addstr.c
Prereq:  1.21 
--- ncurses-6.5-20241130+/test/test_addstr.c	2024-10-05 19:27:33.000000000 +0000
+++ ncurses-6.5-20241207/test/test_addstr.c	2024-12-07 22:41:11.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_addstr.c,v 1.21 2024/10/05 19:27:33 tom Exp $
+ * $Id: test_addstr.c,v 1.22 2024/12/07 22:41:11 tom Exp $
  *
  * Demonstrate the waddstr() and waddch functions.
  * Thomas Dickey - 2009/9/12
@@ -140,9 +140,9 @@
     int row2, col2;
     int length;
     char buffer[BUFSIZ];
-    WINDOW *look = 0;
-    WINDOW *work = 0;
-    WINDOW *show = 0;
+    WINDOW *look = NULL;
+    WINDOW *work = NULL;
+    WINDOW *show = NULL;
     int margin = (2 * MY_TABSIZE) - 1;
     Options option = (Options) ((unsigned) (m_opt
 					    ? oMove
Index: test/test_addwstr.c
Prereq:  1.23 
--- ncurses-6.5-20241130+/test/test_addwstr.c	2024-10-05 19:27:33.000000000 +0000
+++ ncurses-6.5-20241207/test/test_addwstr.c	2024-12-07 22:41:11.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_addwstr.c,v 1.23 2024/10/05 19:27:33 tom Exp $
+ * $Id: test_addwstr.c,v 1.24 2024/12/07 22:41:11 tom Exp $
  *
  * Demonstrate the waddwstr() and wadd_wch functions.
  * Thomas Dickey - 2009/9/12
@@ -233,9 +233,9 @@
     int row2, col2;
     int length;
     wchar_t buffer[BUFSIZ];
-    WINDOW *look = 0;
-    WINDOW *work = 0;
-    WINDOW *show = 0;
+    WINDOW *look = NULL;
+    WINDOW *work = NULL;
+    WINDOW *show = NULL;
     int margin = (2 * MY_TABSIZE) - 1;
     Options option = (Options) ((unsigned) (m_opt
 					    ? oMove
Index: test/test_arrays.c
Prereq:  1.14 
--- ncurses-6.5-20241130+/test/test_arrays.c	2024-11-30 17:00:55.000000000 +0000
+++ ncurses-6.5-20241207/test/test_arrays.c	2024-12-07 22:46:42.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_arrays.c,v 1.14 2024/11/30 17:00:55 tom Exp $
+ * $Id: test_arrays.c,v 1.15 2024/12/07 22:46:42 tom Exp $
  *
  * Author: Thomas E Dickey
  *
@@ -66,7 +66,7 @@
     int n;
 
     printf("%s:\n", name);
-    for (n = 0; list[n] != 0; ++n) {
+    for (n = 0; list[n] != NULL; ++n) {
 	printf("%5d:%s\n", n, list[n]);
     }
 }
Index: test/test_get_wstr.c
Prereq:  1.16 
--- ncurses-6.5-20241130+/test/test_get_wstr.c	2024-10-06 23:15:10.000000000 +0000
+++ ncurses-6.5-20241207/test/test_get_wstr.c	2024-12-07 22:46:42.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_get_wstr.c,v 1.16 2024/10/06 23:15:10 tom Exp $
+ * $Id: test_get_wstr.c,v 1.17 2024/12/07 22:46:42 tom Exp $
  *
  * Author: Thomas E Dickey
  *
@@ -158,10 +158,10 @@
 	"",
 	"  w              - recur to subwindow",
 	"  ?,<F1>         - show help-screen",
-	0
+	NULL
     };
-    WINDOW *txtbox = 0;
-    WINDOW *txtwin = 0;
+    WINDOW *txtbox = NULL;
+    WINDOW *txtwin = NULL;
     FILE *fp;
     int ch;
     int rc;
@@ -172,7 +172,7 @@
     int actual;
     wint_t buffer[MAX_COLS];
 
-    if (argv[level] == 0) {
+    if (argv[level] == NULL) {
 	beep();
 	return FALSE;
     }
@@ -200,7 +200,7 @@
     txt_x = 0;
     wmove(txtwin, txt_y, txt_x);
 
-    if ((fp = fopen(argv[level], "r")) != 0) {
+    if ((fp = fopen(argv[level], "r")) != NULL) {
 	while ((ch = fgetc(fp)) != EOF) {
 	    if (waddch(txtwin, UChar(ch)) != OK) {
 		break;
@@ -250,7 +250,7 @@
 
 	case 'w':
 	    recursive_test(level + 1, argv, strwin);
-	    if (txtbox != 0) {
+	    if (txtbox != NULL) {
 		touchwin(txtbox);
 		wnoutrefresh(txtbox);
 	    } else {
Index: test/test_getstr.c
Prereq:  1.19 
--- ncurses-6.5-20241130+/test/test_getstr.c	2024-10-06 22:36:46.000000000 +0000
+++ ncurses-6.5-20241207/test/test_getstr.c	2024-12-07 22:46:42.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_getstr.c,v 1.19 2024/10/06 22:36:46 tom Exp $
+ * $Id: test_getstr.c,v 1.20 2024/12/07 22:46:42 tom Exp $
  *
  * Author: Thomas E Dickey
  *
@@ -165,10 +165,10 @@
 	"",
 	"  w              - recur to subwindow",
 	"  ?,<F1>         - show help-screen",
-	0
+	NULL
     };
-    WINDOW *txtbox = 0;
-    WINDOW *txtwin = 0;
+    WINDOW *txtbox = NULL;
+    WINDOW *txtwin = NULL;
     FILE *fp;
     int ch;
     int rc;
@@ -180,7 +180,7 @@
 
     char buffer[MAX_COLS];
 
-    if (argv[level] == 0) {
+    if (argv[level] == NULL) {
 	beep();
 	return FALSE;
     }
@@ -208,7 +208,7 @@
     txt_x = 0;
     wmove(txtwin, txt_y, txt_x);
 
-    if ((fp = fopen(argv[level], "r")) != 0) {
+    if ((fp = fopen(argv[level], "r")) != NULL) {
 	while ((ch = fgetc(fp)) != EOF) {
 	    if (waddch(txtwin, UChar(ch)) != OK) {
 		break;
@@ -258,7 +258,7 @@
 
 	case 'w':
 	    recursive_test(level + 1, argv, strwin);
-	    if (txtbox != 0) {
+	    if (txtbox != NULL) {
 		touchwin(txtbox);
 		wnoutrefresh(txtbox);
 	    } else {
Index: test/test_instr.c
Prereq:  1.15 
--- ncurses-6.5-20241130+/test/test_instr.c	2024-10-06 21:11:54.000000000 +0000
+++ ncurses-6.5-20241207/test/test_instr.c	2024-12-07 22:46:42.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_instr.c,v 1.15 2024/10/06 21:11:54 tom Exp $
+ * $Id: test_instr.c,v 1.16 2024/12/07 22:46:42 tom Exp $
  *
  * Author: Thomas E Dickey
  *
@@ -83,7 +83,7 @@
 	,"w     opens new window on the next filename."
 	,"q     quits the current file/window."
 	,"?     shows this help-window"
-	,0
+	,NULL
     };
 
     popup_msg(win, msgs);
@@ -92,8 +92,8 @@
 static int
 recursive_test(int level, char **argv, WINDOW *chrwin, WINDOW *strwin)
 {
-    WINDOW *txtbox = 0;
-    WINDOW *txtwin = 0;
+    WINDOW *txtbox = NULL;
+    WINDOW *txtwin = NULL;
     FILE *fp;
     int ch;
     int txt_x = 0, txt_y = 0;
@@ -102,7 +102,7 @@
 
     char buffer[MAX_COLS];
 
-    if (argv[level] == 0) {
+    if (argv[level] == NULL) {
 	beep();
 	return FALSE;
     }
@@ -131,7 +131,7 @@
     txt_x = 0;
     wmove(txtwin, txt_y, txt_x);
 
-    if ((fp = fopen(argv[level], "r")) != 0) {
+    if ((fp = fopen(argv[level], "r")) != NULL) {
 	while ((ch = fgetc(fp)) != EOF) {
 	    if (waddch(txtwin, UChar(ch)) != OK) {
 		break;
@@ -174,7 +174,7 @@
 	    break;
 	case 'w':
 	    recursive_test(level + 1, argv, chrwin, strwin);
-	    if (txtbox != 0) {
+	    if (txtbox != NULL) {
 		touchwin(txtbox);
 		wnoutrefresh(txtbox);
 	    } else {
Index: test/test_inwstr.c
Prereq:  1.11 
--- ncurses-6.5-20241130+/test/test_inwstr.c	2024-10-06 23:15:38.000000000 +0000
+++ ncurses-6.5-20241207/test/test_inwstr.c	2024-12-07 22:46:42.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_inwstr.c,v 1.11 2024/10/06 23:15:38 tom Exp $
+ * $Id: test_inwstr.c,v 1.12 2024/12/07 22:46:42 tom Exp $
  *
  * Author: Thomas E Dickey
  *
@@ -86,7 +86,7 @@
 	,"w     opens new window on the next filename."
 	,"q     quits the current file/window."
 	,"?     shows this help-window"
-	,0
+	,NULL
     };
 
     popup_msg(win, msgs);
@@ -95,8 +95,8 @@
 static int
 recursive_test(int level, char **argv, WINDOW *chrwin, WINDOW *strwin)
 {
-    WINDOW *txtbox = 0;
-    WINDOW *txtwin = 0;
+    WINDOW *txtbox = NULL;
+    WINDOW *txtwin = NULL;
     FILE *fp;
     int ch;
     int txt_x = 0, txt_y = 0;
@@ -104,7 +104,7 @@
     int limit = getmaxx(strwin) - 5;
     wchar_t buffer[MAX_COLS];
 
-    if (argv[level] == 0) {
+    if (argv[level] == NULL) {
 	beep();
 	return FALSE;
     }
@@ -132,7 +132,7 @@
     txt_x = 0;
     wmove(txtwin, txt_y, txt_x);
 
-    if ((fp = fopen(argv[level], "r")) != 0) {
+    if ((fp = fopen(argv[level], "r")) != NULL) {
 	while ((ch = fgetc(fp)) != EOF) {
 	    if (waddch(txtwin, UChar(ch)) != OK) {
 		break;
@@ -175,7 +175,7 @@
 	    break;
 	case 'w':
 	    recursive_test(level + 1, argv, chrwin, strwin);
-	    if (txtbox != 0) {
+	    if (txtbox != NULL) {
 		touchwin(txtbox);
 		wnoutrefresh(txtbox);
 	    } else {
Index: test/test_opaque.c
Prereq:  1.17 
--- ncurses-6.5-20241130+/test/test_opaque.c	2024-11-23 19:10:23.000000000 +0000
+++ ncurses-6.5-20241207/test/test_opaque.c	2024-12-07 22:46:42.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_opaque.c,v 1.17 2024/11/23 19:10:23 tom Exp $
+ * $Id: test_opaque.c,v 1.18 2024/12/07 22:46:42 tom Exp $
  *
  * Author: Thomas E Dickey
  *
@@ -269,8 +269,8 @@
 static int
 test_opaque(int level, char **argv, WINDOW *stswin)
 {
-    WINDOW *txtbox = 0;
-    WINDOW *txtwin = 0;
+    WINDOW *txtbox = NULL;
+    WINDOW *txtwin = NULL;
     FILE *fp;
     int ch;
     int txt_x = 0, txt_y = 0;
@@ -278,7 +278,7 @@
     bool in_status = FALSE;
     int active = 0;
 
-    if (argv[level] == 0) {
+    if (argv[level] == NULL) {
 	beep();
 	return FALSE;
     }
@@ -306,7 +306,7 @@
     txt_x = 0;
     wmove(txtwin, txt_y, txt_x);
 
-    if ((fp = fopen(argv[level], "r")) != 0) {
+    if ((fp = fopen(argv[level], "r")) != NULL) {
 	while ((ch = fgetc(fp)) != EOF) {
 	    if (waddch(txtwin, UChar(ch)) != OK) {
 		break;
@@ -393,7 +393,7 @@
 		break;
 	    case 'w':
 		test_opaque(level + 1, argv, stswin);
-		if (txtbox != 0) {
+		if (txtbox != NULL) {
 		    touchwin(txtbox);
 		    wnoutrefresh(txtbox);
 		} else {
Index: test/test_setupterm.c
Prereq:  1.17 
--- ncurses-6.5-20241130+/test/test_setupterm.c	2023-06-24 14:19:52.000000000 +0000
+++ ncurses-6.5-20241207/test/test_setupterm.c	2024-12-07 23:03:07.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020-2022,2023 Thomas E. Dickey                                *
+ * Copyright 2020-2023,2024 Thomas E. Dickey                                *
  * Copyright 2015,2016 Free Software Foundation, Inc.                       *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey
  *
- * $Id: test_setupterm.c,v 1.17 2023/06/24 14:19:52 tom Exp $
+ * $Id: test_setupterm.c,v 1.18 2024/12/07 23:03:07 tom Exp $
  *
  * A simple demo of setupterm/restartterm.
  */
@@ -98,9 +98,9 @@
     int expect_rc = -1;
     int expect_err = -1;
 
-    if (name == 0)
+    if (name == NULL)
 	name = getenv("TERM");
-    if (name == 0)
+    if (name == NULL)
 	name = "?";
 
     switch (*name) {
@@ -244,7 +244,7 @@
     }
 
     if (a_opt) {
-	static char predef[][9] =
+	static char predef[][12] =
 	{"vt100", "dumb", "lpr", "unknown", "none-such"};
 	if (optind < argc) {
 	    usage(FALSE);
Index: test/test_sgr.c
Prereq:  1.25 
--- ncurses-6.5-20241130+/test/test_sgr.c	2024-10-06 21:05:50.000000000 +0000
+++ ncurses-6.5-20241207/test/test_sgr.c	2024-12-07 22:48:21.000000000 +0000
@@ -30,7 +30,7 @@
 /*
  * Author: Thomas E. Dickey
  *
- * $Id: test_sgr.c,v 1.25 2024/10/06 21:05:50 tom Exp $
+ * $Id: test_sgr.c,v 1.26 2024/12/07 22:48:21 tom Exp $
  *
  * A simple demo of the sgr/sgr0 terminal capabilities.
  */
@@ -106,10 +106,10 @@
 static char *
 next_dbitem(void)
 {
-    char *result = 0;
+    char *result = NULL;
 
     if (db_list) {
-	if ((result = db_list[db_item]) == 0) {
+	if ((result = db_list[db_item]) == NULL) {
 	    db_item = 0;
 	    result = db_list[0];
 	} else {
@@ -129,7 +129,7 @@
 	for (n = 0; db_list[n]; ++n)
 	    free(db_list[n]);
 	free(db_list);
-	db_list = 0;
+	db_list = NULL;
     }
 }
 #endif
@@ -230,20 +230,20 @@
 				  BITS2P(7),
 				  BITS2P(8),
 				  BITS2P(9));
-	    if (values[count] != 0) {
+	    if (values[count] != NULL) {
 		values[count] = strdup(values[count]);
 	    }
 	}
 	for (count = 0; count < MAXSGR; ++count) {
-	    if (values[count] != 0) {
+	    if (values[count] != NULL) {
 		for (j = count + 1; j < MAXSGR; ++j) {
-		    if (values[j] == 0)
+		    if (values[j] == NULL)
 			continue;
 		    if (strcmp(values[count], values[j]))
 			continue;
 		    if (one_bit(count, j)) {
 			free(values[j]);
-			values[j] = 0;
+			values[j] = NULL;
 		    }
 		}
 	    }
@@ -253,7 +253,7 @@
 	    for (count = 0; count < MAXSGR; ++count) {
 		if ((count & mask) != 0)
 		    continue;
-		if (values[count] != 0 && values[count + mask] != 0) {
+		if (values[count] != NULL && values[count + mask] != NULL) {
 		    mask = 0;
 		    break;
 		}
@@ -272,14 +272,14 @@
 	    }
 	}
 	for (count = 0; count < MAXSGR; ++count) {
-	    if (values[count] != 0) {
+	    if (values[count] != NULL) {
 		bool found = FALSE;
 		if ((repeat & MASK_SMSO) != 0
 		    && (count & MASK_SMSO) != 0) {
 		    found = TRUE;
 		} else {
 		    for (j = 0; j < count; ++j) {
-			if (values[j] != 0 && !strcmp(values[j], values[count])) {
+			if (values[j] != NULL && !strcmp(values[j], values[count])) {
 			    if ((repeat & MASK_SMSO) != 0
 				&& (j & MASK_SMSO) != 0
 				&& (count & reason) != 0) {
@@ -366,7 +366,7 @@
 	for (n = optind; n < argc; ++n) {
 	    brute_force(argv[n]);
 	}
-    } else if ((name = getenv("TERM")) != 0) {
+    } else if ((name = getenv("TERM")) != NULL) {
 	brute_force(name);
     } else {
 	static const char dumb[] = "dumb";
Index: test/test_tparm.c
Prereq:  1.42 
--- ncurses-6.5-20241130+/test/test_tparm.c	2024-10-06 20:50:27.000000000 +0000
+++ ncurses-6.5-20241207/test/test_tparm.c	2024-12-07 23:13:34.000000000 +0000
@@ -29,7 +29,7 @@
 /*
  * Author: Thomas E. Dickey
  *
- * $Id: test_tparm.c,v 1.42 2024/10/06 20:50:27 tom Exp $
+ * $Id: test_tparm.c,v 1.43 2024/12/07 23:13:34 tom Exp $
  *
  * Exercise tparm/tiparm, either for all possible capabilities with fixed
  * parameters, or one capability with specific combinations of parameters.
@@ -52,7 +52,7 @@
 	    if (length + 2 >= limit) { \
 		limit *= 2; \
 		array = typeRealloc(char *, limit, array); \
-		if (array == 0) { \
+		if (array == NULL) { \
 		    failed("no memory: " #array); \
 		} \
 	    }
@@ -109,9 +109,9 @@
 static int
 isNumeric(NCURSES_CONST char *source)
 {
-    char *next = 0;
+    char *next = NULL;
     long value = strtol(source, &next, 0);
-    int result = (next == 0 || next == source || *next != '\0') ? 0 : 1;
+    int result = (next == NULL || next == source || *next != '\0') ? 0 : 1;
     (void) value;
     return result;
 }
@@ -121,10 +121,10 @@
 {
     int code = 1;
     if (VALID_STRING(value)) {
-	if (strstr(value, "%p") == 0
-	    && strstr(value, "%d") == 0
-	    && strstr(value, "%s") == 0
-	    && (!p_opt || strstr(value, "$<") == 0)) {
+	if (strstr(value, "%p") == NULL
+	    && strstr(value, "%d") == NULL
+	    && strstr(value, "%s") == NULL
+	    && (!p_opt || strstr(value, "$<") == NULL)) {
 	    if (v_opt > 2)
 		printf("? %s noparams\n", name);
 	    code = 0;
@@ -334,7 +334,7 @@
     }
     if (v_opt > 1) {
 	int n;
-	printf(".. %3d =", result != 0 ? (int) strlen(result) : -1);
+	printf(".. %3d =", result != NULL ? (int) strlen(result) : -1);
 	for (n = 0; n < nparam; ++n) {
 	    if (use_strings[n]) {
 		if (number[n]) {
@@ -398,7 +398,7 @@
     int r_run, t_run, n_run;
     char *old_term = getenv("TERM");
     int r_opt = 1;
-    char *t_opt = 0;
+    char *t_opt = NULL;
 
     int std_caps = 0;		/* predefine items in all_caps[] */
     int len_caps = 0;		/* cur # of items in all_caps[] */
@@ -423,7 +423,10 @@
     char **str_parms = typeCalloc(char *, max_parms);
     long use_parms = 1;
 
-    if (all_caps == 0 || all_terms == 0 || num_parms == 0 || str_parms == 0)
+    if (all_caps == NULL
+	|| all_terms == NULL
+	|| num_parms == NULL
+	|| str_parms == NULL)
 	failed("no memory");
 
     while ((ch = getopt(argc, argv, OPTS_COMMON "T:aipr:sv")) != -1) {
@@ -479,7 +482,7 @@
      */
     while (optind < argc) {
 	if (isNumeric(argv[optind])) {
-	    char *dummy = 0;
+	    char *dummy = NULL;
 	    long value = strtol(argv[optind], &dummy, 0);
 	    num_parms[len_parms] = (int) value;
 	}
@@ -504,11 +507,11 @@
      * Make a list of values for $TERM.  Accept "-" for standard input to
      * simplify scripting a check of the whole database.
      */
-    old_term = strdup((old_term == 0) ? "unknown" : old_term);
-    if (t_opt != 0) {
+    old_term = strdup((old_term == NULL) ? "unknown" : old_term);
+    if (t_opt != NULL) {
 	if (!strcmp(t_opt, "-")) {
 	    char buffer[BUFSIZ];
-	    while (fgets(buffer, sizeof(buffer) - 1, stdin) != 0) {
+	    while (fgets(buffer, sizeof(buffer) - 1, stdin) != NULL) {
 		char *s = buffer;
 		char *t;
 		while (isspace(UChar(s[0])))
@@ -520,7 +523,7 @@
 		if (len_terms + 2 >= max_terms) {
 		    max_terms *= 2;
 		    all_terms = typeRealloc(char *, max_terms, all_terms);
-		    if (all_terms == 0)
+		    if (all_terms == NULL)
 			failed("no memory: all_terms");
 		}
 		all_terms[len_terms++] = s;
@@ -528,12 +531,12 @@
 	} else {
 	    char *s = t_opt;
 	    NCURSES_CONST char *t;
-	    while ((t = strtok(s, ",")) != 0) {
-		s = 0;
+	    while ((t = strtok(s, ",")) != NULL) {
+		s = NULL;
 		if (len_terms + 2 >= max_terms) {
 		    max_terms *= 2;
 		    all_terms = typeRealloc(char *, max_terms, all_terms);
-		    if (all_terms == 0)
+		    if (all_terms == NULL)
 			failed("no memory: all_terms");
 		}
 		all_terms[len_terms++] = strdup(t);
@@ -542,7 +545,7 @@
     } else {
 	all_terms[len_terms++] = strdup(old_term);
     }
-    all_terms[len_terms] = 0;
+    all_terms[len_terms] = NULL;
     if (v_opt) {
 	printf("%d term%s:\n", PLURAL(len_terms));
 	if (v_opt > 3) {
@@ -561,7 +564,7 @@
      */
     if (len_caps == 0) {
 #if defined(HAVE_CURSES_DATA_BOOLNAMES) || defined(DECL_CURSES_DATA_BOOLNAMES)
-	for (n = 0; strnames[n] != 0; ++n) {
+	for (n = 0; strnames[n] != NULL; ++n) {
 	    GrowArray(all_caps, max_caps, len_caps);
 	    all_caps[len_caps++] = strdup(strnames[n]);
 	}
@@ -571,7 +574,7 @@
 #endif
     }
     std_caps = len_caps;
-    all_caps[len_caps] = 0;
+    all_caps[len_caps] = NULL;
     if (v_opt) {
 	printf("%d name%s%s\n", PLURAL(len_caps), COLONS(len_caps));
 	if (v_opt > 3) {
@@ -664,7 +667,7 @@
 		free(all_caps[n]);
 	    }
 #endif
-	    if (cur_term != 0) {
+	    if (cur_term != NULL) {
 		del_curterm(cur_term);
 	    } else {
 		printf("? no cur_term\n");
Index: test/test_vid_puts.c
Prereq:  1.17 
--- ncurses-6.5-20241130+/test/test_vid_puts.c	2022-12-10 22:28:50.000000000 +0000
+++ ncurses-6.5-20241207/test/test_vid_puts.c	2024-12-07 23:03:19.000000000 +0000
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2020-2021,2022 Thomas E. Dickey                                *
+ * Copyright 2020-2022,2024 Thomas E. Dickey                                *
  * Copyright 2013-2014,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_vid_puts.c,v 1.17 2022/12/10 22:28:50 tom Exp $
+ * $Id: test_vid_puts.c,v 1.18 2024/12/07 23:03:19 tom Exp $
  *
  * Demonstrate the vid_puts and vid_attr functions.
  * Thomas Dickey - 2013/01/12
@@ -63,7 +63,7 @@
 static void
 cleanup(void)
 {
-    if (cur_term != 0) {
+    if (cur_term != NULL) {
 	outs(exit_attribute_mode);
 	if (!outs(orig_colors))
 	    outs(orig_pair);
Index: test/test_vidputs.c
Prereq:  1.16 
--- ncurses-6.5-20241130+/test/test_vidputs.c	2024-10-06 21:17:54.000000000 +0000
+++ ncurses-6.5-20241207/test/test_vidputs.c	2024-12-07 22:53:07.000000000 +0000
@@ -27,7 +27,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 /*
- * $Id: test_vidputs.c,v 1.16 2024/10/06 21:17:54 tom Exp $
+ * $Id: test_vidputs.c,v 1.17 2024/12/07 22:53:07 tom Exp $
  *
  * Demonstrate the vidputs and vidattr functions.
  * Thomas Dickey - 2013/01/12
@@ -63,7 +63,7 @@
 static void
 cleanup(void)
 {
-    if (cur_term != 0) {
+    if (cur_term != NULL) {
 	outs(exit_attribute_mode);
 	if (!outs(orig_colors))
 	    outs(orig_pair);
Index: test/testcurs.c
Prereq:  1.59 
--- ncurses-6.5-20241130+/test/testcurs.c	2024-10-05 19:17:19.000000000 +0000
+++ ncurses-6.5-20241207/test/testcurs.c	2024-12-07 22:53:07.000000000 +0000
@@ -6,7 +6,7 @@
  *  wrs(5/28/93) -- modified to be consistent (perform identically) with either
  *                  PDCurses or under Unix System V, R4
  *
- * $Id: testcurs.c,v 1.59 2024/10/05 19:17:19 tom Exp $
+ * $Id: testcurs.c,v 1.60 2024/12/07 22:53:07 tom Exp $
  */
 
 #include <test.priv.h>
@@ -488,14 +488,14 @@
     *Buffer = 0;
     scanw("%s", Buffer);
 
-    if (TIGETSTR("cvvis", "vs") != 0) {
+    if (TIGETSTR("cvvis", "vs") != NULL) {
 	wclear(win);
 	curs_set(2);
 	MvWAddStr(win, 1, 1, "The cursor should appear as a block (visible)");
 	Continue(win);
     }
 
-    if (TIGETSTR("civis", "vi") != 0) {
+    if (TIGETSTR("civis", "vi") != NULL) {
 	wclear(win);
 	curs_set(0);
 	MvWAddStr(win, 1, 1,
@@ -503,7 +503,7 @@
 	Continue(win);
     }
 
-    if (TIGETSTR("cnorm", "ve") != 0) {
+    if (TIGETSTR("cnorm", "ve") != NULL) {
 	wclear(win);
 	curs_set(1);
 	MvWAddStr(win, 1, 1, "The cursor should be an underline (normal)");
@@ -592,7 +592,7 @@
 {
     WINDOW *pad;
 
-    if ((pad = newpad(50, 100)) != 0) {
+    if ((pad = newpad(50, 100)) != NULL) {
 	WINDOW *spad;
 
 	wattron(pad, A_REVERSE);
@@ -609,7 +609,7 @@
 	raw();
 	wgetch(pad);
 
-	if ((spad = subpad(pad, 12, 25, 6, 52)) != 0) {
+	if ((spad = subpad(pad, 12, 25, 6, 52)) != NULL) {
 	    MvWAddStr(spad, 2, 2, "This is a new subpad");
 	    box(spad, 0, 0);
 	    delwin(spad);
Index: test/view.c
Prereq:  1.149 
--- ncurses-6.5-20241130+/test/view.c	2024-11-30 18:15:06.000000000 +0000
+++ ncurses-6.5-20241207/test/view.c	2024-12-07 22:53:07.000000000 +0000
@@ -52,7 +52,7 @@
  * scroll operation worked, and the refresh() code only had to do a
  * partial repaint.
  *
- * $Id: view.c,v 1.149 2024/11/30 18:15:06 tom Exp $
+ * $Id: view.c,v 1.150 2024/12/07 22:53:07 tom Exp $
  */
 
 #include <test.priv.h>
@@ -114,7 +114,7 @@
 {
     endwin();
 #if NO_LEAKS
-    if (vec_lines != 0) {
+    if (vec_lines != NULL) {
 	int n;
 	for (n = 0; n < num_lines; ++n) {
 	    free(vec_lines[n]);
@@ -172,7 +172,7 @@
 	move(i, 0);
 	printw("%*d:", digits, actual);
 	clrtoeol();
-	if ((s = lptr[i - 1]) == 0) {
+	if ((s = lptr[i - 1]) == NULL) {
 	    continue;
 	}
 	len = ch_len(s);
@@ -233,7 +233,7 @@
     size_t len;
     struct stat sb;
     char *my_blob;
-    char **my_vec = 0;
+    char **my_vec = NULL;
     WINDOW *my_win;
 
     if (stat(filename, &sb) != 0
@@ -245,11 +245,11 @@
 	failed("input is empty");
     }
 
-    if ((fp = fopen(filename, "r")) == 0) {
+    if ((fp = fopen(filename, "r")) == NULL) {
 	failed("cannot open input-file");
     }
 
-    if ((my_blob = malloc((size_t) sb.st_size + 1)) == 0) {
+    if ((my_blob = malloc((size_t) sb.st_size + 1)) == NULL) {
 	failed("cannot allocate memory for input-file");
     }
 
@@ -280,7 +280,7 @@
 	}
 	num_lines = k;
 	if (pass == 0) {
-	    if (((my_vec = typeCalloc(char *, (size_t) k + 2)) == 0)) {
+	    if (((my_vec = typeCalloc(char *, (size_t) k + 2)) == NULL)) {
 		failed("cannot allocate line-vector #1");
 	    }
 	} else {
@@ -307,11 +307,11 @@
     }
     width = (width + 1) * 5;
     my_win = newwin(2, width, 0, 0);
-    if (my_win == 0) {
+    if (my_win == NULL) {
 	failed("cannot allocate temporary window");
     }
 
-    if ((vec_lines = typeCalloc(NCURSES_CH_T *, (size_t) num_lines + 2)) == 0) {
+    if ((vec_lines = typeCalloc(NCURSES_CH_T *, (size_t) num_lines + 2)) == NULL) {
 	failed("cannot allocate line-vector #2");
     }
 
@@ -358,7 +358,7 @@
 	    x = width - 1;
 	wmove(my_win, 0, 0);
 	/* "x + 1" works with standard curses; some implementations are buggy */
-	if ((vec_lines[k] = typeCalloc(NCURSES_CH_T, x + width + 1)) == 0) {
+	if ((vec_lines[k] = typeCalloc(NCURSES_CH_T, x + width + 1)) == NULL) {
 	    failed("cannot allocate line-vector #3");
 	}
 #if USE_WIDEC_SUPPORT
@@ -427,7 +427,7 @@
 	"  s              - use entered count for halfdelay() parameter",
 	"                 - if no entered count, stop nodelay()",
 	"  <space>        - begin nodelay()",
-	0
+	NULL
     };
 
     int ch;
@@ -462,9 +462,9 @@
 #ifdef TRACE
 	case 'D':
 	    {
-		char *next = 0;
+		char *next = NULL;
 		int tvalue = (int) strtol(optarg, &next, 0);
-		if (tvalue < 0 || (next != 0 && *next != 0))
+		if (tvalue < 0 || (next != NULL && *next != 0))
 		    usage(FALSE);
 		curses_trace((unsigned) tvalue);
 	    }
Index: test/xmas.c
Prereq:  1.39 
--- ncurses-6.5-20241130+/test/xmas.c	2022-12-04 00:40:11.000000000 +0000
+++ ncurses-6.5-20241207/test/xmas.c	2024-12-07 22:53:07.000000000 +0000
@@ -92,7 +92,7 @@
 /******************************************************************************/
 
 /*
- * $Id: xmas.c,v 1.39 2022/12/04 00:40:11 tom Exp $
+ * $Id: xmas.c,v 1.40 2024/12/07 22:53:07 tom Exp $
  */
 #include <test.priv.h>
 
@@ -140,7 +140,7 @@
 {
     if (has_colors()) {
 	int n = (int) (color + 1);
-	if (my_pairs == 0)
+	if (my_pairs == NULL)
 	    my_pairs = typeCalloc(bool, (size_t) (COLORS + 1));
 	if (!my_pairs[n]) {
 	    init_pair((short) n, (short) color, (short) my_bg);
@@ -638,7 +638,7 @@
     stop_curses();
 
 #if NO_LEAKS
-    if (my_pairs != 0)
+    if (my_pairs != NULL)
 	free(my_pairs);
 #endif
 
@@ -715,44 +715,44 @@
     }
     curs_set(0);
 
-    if ((treescrn = newwin(16, 27, 3, 53)) == 0 ||
-	(treescrn2 = newwin(16, 27, 3, 53)) == 0 ||
-	(treescrn3 = newwin(16, 27, 3, 53)) == 0 ||
-	(treescrn4 = newwin(16, 27, 3, 53)) == 0 ||
-	(treescrn5 = newwin(16, 27, 3, 53)) == 0 ||
-	(treescrn6 = newwin(16, 27, 3, 53)) == 0 ||
-	(treescrn7 = newwin(16, 27, 3, 53)) == 0 ||
-	(treescrn8 = newwin(16, 27, 3, 53)) == 0 ||
-
-	(dotdeer0 = newwin(3, 71, 0, 8)) == 0 ||
-
-	(stardeer0 = newwin(4, 56, 0, 8)) == 0 ||
-
-	(lildeer0 = newwin(7, 53, 0, 8)) == 0 ||
-	(lildeer1 = newwin(2, 4, 0, 0)) == 0 ||
-	(lildeer2 = newwin(2, 4, 0, 0)) == 0 ||
-	(lildeer3 = newwin(2, 4, 0, 0)) == 0 ||
-
-	(middeer0 = newwin(15, 42, 0, 8)) == 0 ||
-	(middeer1 = newwin(3, 7, 0, 0)) == 0 ||
-	(middeer2 = newwin(3, 7, 0, 0)) == 0 ||
-	(middeer3 = newwin(3, 7, 0, 0)) == 0 ||
-
-	(bigdeer0 = newwin(10, 23, 0, 0)) == 0 ||
-	(bigdeer1 = newwin(10, 23, 0, 0)) == 0 ||
-	(bigdeer2 = newwin(10, 23, 0, 0)) == 0 ||
-	(bigdeer3 = newwin(10, 23, 0, 0)) == 0 ||
-	(bigdeer4 = newwin(10, 23, 0, 0)) == 0 ||
-
-	(lookdeer0 = newwin(10, 25, 0, 0)) == 0 ||
-	(lookdeer1 = newwin(10, 25, 0, 0)) == 0 ||
-	(lookdeer2 = newwin(10, 25, 0, 0)) == 0 ||
-	(lookdeer3 = newwin(10, 25, 0, 0)) == 0 ||
-	(lookdeer4 = newwin(10, 25, 0, 0)) == 0 ||
+    if ((treescrn = newwin(16, 27, 3, 53)) == NULL ||
+	(treescrn2 = newwin(16, 27, 3, 53)) == NULL ||
+	(treescrn3 = newwin(16, 27, 3, 53)) == NULL ||
+	(treescrn4 = newwin(16, 27, 3, 53)) == NULL ||
+	(treescrn5 = newwin(16, 27, 3, 53)) == NULL ||
+	(treescrn6 = newwin(16, 27, 3, 53)) == NULL ||
+	(treescrn7 = newwin(16, 27, 3, 53)) == NULL ||
+	(treescrn8 = newwin(16, 27, 3, 53)) == NULL ||
+
+	(dotdeer0 = newwin(3, 71, 0, 8)) == NULL ||
+
+	(stardeer0 = newwin(4, 56, 0, 8)) == NULL ||
+
+	(lildeer0 = newwin(7, 53, 0, 8)) == NULL ||
+	(lildeer1 = newwin(2, 4, 0, 0)) == NULL ||
+	(lildeer2 = newwin(2, 4, 0, 0)) == NULL ||
+	(lildeer3 = newwin(2, 4, 0, 0)) == NULL ||
+
+	(middeer0 = newwin(15, 42, 0, 8)) == NULL ||
+	(middeer1 = newwin(3, 7, 0, 0)) == NULL ||
+	(middeer2 = newwin(3, 7, 0, 0)) == NULL ||
+	(middeer3 = newwin(3, 7, 0, 0)) == NULL ||
+
+	(bigdeer0 = newwin(10, 23, 0, 0)) == NULL ||
+	(bigdeer1 = newwin(10, 23, 0, 0)) == NULL ||
+	(bigdeer2 = newwin(10, 23, 0, 0)) == NULL ||
+	(bigdeer3 = newwin(10, 23, 0, 0)) == NULL ||
+	(bigdeer4 = newwin(10, 23, 0, 0)) == NULL ||
+
+	(lookdeer0 = newwin(10, 25, 0, 0)) == NULL ||
+	(lookdeer1 = newwin(10, 25, 0, 0)) == NULL ||
+	(lookdeer2 = newwin(10, 25, 0, 0)) == NULL ||
+	(lookdeer3 = newwin(10, 25, 0, 0)) == NULL ||
+	(lookdeer4 = newwin(10, 25, 0, 0)) == NULL ||
 
-	(w_holiday = newwin(1, 26, 3, 27)) == 0 ||
+	(w_holiday = newwin(1, 26, 3, 27)) == NULL ||
 
-	(w_del_msg = newwin(1, 19, 23, 60)) == 0) {
+	(w_del_msg = newwin(1, 19, 23, 60)) == NULL) {
 	stop_curses();
 	fprintf(stderr, "Cannot create windows - screen too small\n");
 	ExitProgram(EXIT_FAILURE);
